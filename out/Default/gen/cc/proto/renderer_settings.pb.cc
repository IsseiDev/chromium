// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: renderer_settings.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "renderer_settings.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace cc {
namespace proto {

void protobuf_ShutdownFile_renderer_5fsettings_2eproto() {
  delete BufferToTextureTarget::default_instance_;
  delete RendererSettings::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_renderer_5fsettings_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_renderer_5fsettings_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  BufferToTextureTarget::default_instance_ = new BufferToTextureTarget();
  RendererSettings::default_instance_ = new RendererSettings();
  BufferToTextureTarget::default_instance_->InitAsDefaultInstance();
  RendererSettings::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_renderer_5fsettings_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_renderer_5fsettings_2eproto_once_);
void protobuf_AddDesc_renderer_5fsettings_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_renderer_5fsettings_2eproto_once_,
                 &protobuf_AddDesc_renderer_5fsettings_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_renderer_5fsettings_2eproto {
  StaticDescriptorInitializer_renderer_5fsettings_2eproto() {
    protobuf_AddDesc_renderer_5fsettings_2eproto();
  }
} static_descriptor_initializer_renderer_5fsettings_2eproto_;
#endif

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForBufferToTextureTarget(
    BufferToTextureTarget* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BufferToTextureTarget::kBufferUsageFieldNumber;
const int BufferToTextureTarget::kBufferFormatFieldNumber;
const int BufferToTextureTarget::kTextureTargetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BufferToTextureTarget::BufferToTextureTarget()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cc.proto.BufferToTextureTarget)
}

void BufferToTextureTarget::InitAsDefaultInstance() {
}

BufferToTextureTarget::BufferToTextureTarget(const BufferToTextureTarget& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cc.proto.BufferToTextureTarget)
}

void BufferToTextureTarget::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  buffer_usage_ = 0u;
  buffer_format_ = 0u;
  texture_target_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BufferToTextureTarget::~BufferToTextureTarget() {
  // @@protoc_insertion_point(destructor:cc.proto.BufferToTextureTarget)
  SharedDtor();
}

void BufferToTextureTarget::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BufferToTextureTarget::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BufferToTextureTarget& BufferToTextureTarget::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_renderer_5fsettings_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_renderer_5fsettings_2eproto();
#endif
  return *default_instance_;
}

BufferToTextureTarget* BufferToTextureTarget::default_instance_ = NULL;

BufferToTextureTarget* BufferToTextureTarget::New(::google::protobuf::Arena* arena) const {
  BufferToTextureTarget* n = new BufferToTextureTarget;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BufferToTextureTarget::Clear() {
// @@protoc_insertion_point(message_clear_start:cc.proto.BufferToTextureTarget)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(BufferToTextureTarget, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<BufferToTextureTarget*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(buffer_usage_, texture_target_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool BufferToTextureTarget::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForBufferToTextureTarget, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cc.proto.BufferToTextureTarget)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 buffer_usage = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buffer_usage_)));
          set_has_buffer_usage();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_buffer_format;
        break;
      }

      // optional uint32 buffer_format = 2;
      case 2: {
        if (tag == 16) {
         parse_buffer_format:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buffer_format_)));
          set_has_buffer_format();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_texture_target;
        break;
      }

      // optional uint32 texture_target = 3;
      case 3: {
        if (tag == 24) {
         parse_texture_target:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &texture_target_)));
          set_has_texture_target();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cc.proto.BufferToTextureTarget)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cc.proto.BufferToTextureTarget)
  return false;
#undef DO_
}

void BufferToTextureTarget::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cc.proto.BufferToTextureTarget)
  // optional uint32 buffer_usage = 1;
  if (has_buffer_usage()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->buffer_usage(), output);
  }

  // optional uint32 buffer_format = 2;
  if (has_buffer_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->buffer_format(), output);
  }

  // optional uint32 texture_target = 3;
  if (has_texture_target()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->texture_target(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cc.proto.BufferToTextureTarget)
}

int BufferToTextureTarget::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cc.proto.BufferToTextureTarget)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional uint32 buffer_usage = 1;
    if (has_buffer_usage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buffer_usage());
    }

    // optional uint32 buffer_format = 2;
    if (has_buffer_format()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buffer_format());
    }

    // optional uint32 texture_target = 3;
    if (has_texture_target()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->texture_target());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BufferToTextureTarget::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BufferToTextureTarget*>(&from));
}

void BufferToTextureTarget::MergeFrom(const BufferToTextureTarget& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.BufferToTextureTarget)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_buffer_usage()) {
      set_buffer_usage(from.buffer_usage());
    }
    if (from.has_buffer_format()) {
      set_buffer_format(from.buffer_format());
    }
    if (from.has_texture_target()) {
      set_texture_target(from.texture_target());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void BufferToTextureTarget::CopyFrom(const BufferToTextureTarget& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.BufferToTextureTarget)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BufferToTextureTarget::IsInitialized() const {

  return true;
}

void BufferToTextureTarget::Swap(BufferToTextureTarget* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BufferToTextureTarget::InternalSwap(BufferToTextureTarget* other) {
  std::swap(buffer_usage_, other->buffer_usage_);
  std::swap(buffer_format_, other->buffer_format_);
  std::swap(texture_target_, other->texture_target_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string BufferToTextureTarget::GetTypeName() const {
  return "cc.proto.BufferToTextureTarget";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BufferToTextureTarget

// optional uint32 buffer_usage = 1;
bool BufferToTextureTarget::has_buffer_usage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BufferToTextureTarget::set_has_buffer_usage() {
  _has_bits_[0] |= 0x00000001u;
}
void BufferToTextureTarget::clear_has_buffer_usage() {
  _has_bits_[0] &= ~0x00000001u;
}
void BufferToTextureTarget::clear_buffer_usage() {
  buffer_usage_ = 0u;
  clear_has_buffer_usage();
}
 ::google::protobuf::uint32 BufferToTextureTarget::buffer_usage() const {
  // @@protoc_insertion_point(field_get:cc.proto.BufferToTextureTarget.buffer_usage)
  return buffer_usage_;
}
 void BufferToTextureTarget::set_buffer_usage(::google::protobuf::uint32 value) {
  set_has_buffer_usage();
  buffer_usage_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.BufferToTextureTarget.buffer_usage)
}

// optional uint32 buffer_format = 2;
bool BufferToTextureTarget::has_buffer_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void BufferToTextureTarget::set_has_buffer_format() {
  _has_bits_[0] |= 0x00000002u;
}
void BufferToTextureTarget::clear_has_buffer_format() {
  _has_bits_[0] &= ~0x00000002u;
}
void BufferToTextureTarget::clear_buffer_format() {
  buffer_format_ = 0u;
  clear_has_buffer_format();
}
 ::google::protobuf::uint32 BufferToTextureTarget::buffer_format() const {
  // @@protoc_insertion_point(field_get:cc.proto.BufferToTextureTarget.buffer_format)
  return buffer_format_;
}
 void BufferToTextureTarget::set_buffer_format(::google::protobuf::uint32 value) {
  set_has_buffer_format();
  buffer_format_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.BufferToTextureTarget.buffer_format)
}

// optional uint32 texture_target = 3;
bool BufferToTextureTarget::has_texture_target() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void BufferToTextureTarget::set_has_texture_target() {
  _has_bits_[0] |= 0x00000004u;
}
void BufferToTextureTarget::clear_has_texture_target() {
  _has_bits_[0] &= ~0x00000004u;
}
void BufferToTextureTarget::clear_texture_target() {
  texture_target_ = 0u;
  clear_has_texture_target();
}
 ::google::protobuf::uint32 BufferToTextureTarget::texture_target() const {
  // @@protoc_insertion_point(field_get:cc.proto.BufferToTextureTarget.texture_target)
  return texture_target_;
}
 void BufferToTextureTarget::set_texture_target(::google::protobuf::uint32 value) {
  set_has_texture_target();
  texture_target_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.BufferToTextureTarget.texture_target)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForRendererSettings(
    RendererSettings* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RendererSettings::kAllowAntialiasingFieldNumber;
const int RendererSettings::kForceAntialiasingFieldNumber;
const int RendererSettings::kForceBlendingWithShadersFieldNumber;
const int RendererSettings::kPartialSwapEnabledFieldNumber;
const int RendererSettings::kFinishRenderingOnResizeFieldNumber;
const int RendererSettings::kShouldClearRootRenderPassFieldNumber;
const int RendererSettings::kDisableDisplayVsyncFieldNumber;
const int RendererSettings::kReleaseOverlayResourcesAfterGpuQueryFieldNumber;
const int RendererSettings::kRefreshRateFieldNumber;
const int RendererSettings::kHighpThresholdMinFieldNumber;
const int RendererSettings::kTextureIdAllocationChunkSizeFieldNumber;
const int RendererSettings::kUseGpuMemoryBufferResourcesFieldNumber;
const int RendererSettings::kPreferredTileFormatFieldNumber;
const int RendererSettings::kBufferToTextureTargetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RendererSettings::RendererSettings()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cc.proto.RendererSettings)
}

void RendererSettings::InitAsDefaultInstance() {
}

RendererSettings::RendererSettings(const RendererSettings& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cc.proto.RendererSettings)
}

void RendererSettings::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  allow_antialiasing_ = false;
  force_antialiasing_ = false;
  force_blending_with_shaders_ = false;
  partial_swap_enabled_ = false;
  finish_rendering_on_resize_ = false;
  should_clear_root_render_pass_ = false;
  disable_display_vsync_ = false;
  release_overlay_resources_after_gpu_query_ = false;
  refresh_rate_ = 0;
  highp_threshold_min_ = 0u;
  texture_id_allocation_chunk_size_ = 0u;
  use_gpu_memory_buffer_resources_ = false;
  preferred_tile_format_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RendererSettings::~RendererSettings() {
  // @@protoc_insertion_point(destructor:cc.proto.RendererSettings)
  SharedDtor();
}

void RendererSettings::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RendererSettings::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RendererSettings& RendererSettings::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_renderer_5fsettings_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_renderer_5fsettings_2eproto();
#endif
  return *default_instance_;
}

RendererSettings* RendererSettings::default_instance_ = NULL;

RendererSettings* RendererSettings::New(::google::protobuf::Arena* arena) const {
  RendererSettings* n = new RendererSettings;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RendererSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:cc.proto.RendererSettings)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RendererSettings, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RendererSettings*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(allow_antialiasing_, release_overlay_resources_after_gpu_query_);
  }
  if (_has_bits_[8 / 32] & 7936u) {
    ZR_(refresh_rate_, preferred_tile_format_);
  }

#undef ZR_HELPER_
#undef ZR_

  buffer_to_texture_target_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool RendererSettings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForRendererSettings, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cc.proto.RendererSettings)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool allow_antialiasing = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &allow_antialiasing_)));
          set_has_allow_antialiasing();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_force_antialiasing;
        break;
      }

      // optional bool force_antialiasing = 2;
      case 2: {
        if (tag == 16) {
         parse_force_antialiasing:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &force_antialiasing_)));
          set_has_force_antialiasing();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_force_blending_with_shaders;
        break;
      }

      // optional bool force_blending_with_shaders = 3;
      case 3: {
        if (tag == 24) {
         parse_force_blending_with_shaders:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &force_blending_with_shaders_)));
          set_has_force_blending_with_shaders();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_partial_swap_enabled;
        break;
      }

      // optional bool partial_swap_enabled = 4;
      case 4: {
        if (tag == 32) {
         parse_partial_swap_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &partial_swap_enabled_)));
          set_has_partial_swap_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_finish_rendering_on_resize;
        break;
      }

      // optional bool finish_rendering_on_resize = 5;
      case 5: {
        if (tag == 40) {
         parse_finish_rendering_on_resize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &finish_rendering_on_resize_)));
          set_has_finish_rendering_on_resize();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_should_clear_root_render_pass;
        break;
      }

      // optional bool should_clear_root_render_pass = 6;
      case 6: {
        if (tag == 48) {
         parse_should_clear_root_render_pass:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &should_clear_root_render_pass_)));
          set_has_should_clear_root_render_pass();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_disable_display_vsync;
        break;
      }

      // optional bool disable_display_vsync = 7;
      case 7: {
        if (tag == 56) {
         parse_disable_display_vsync:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &disable_display_vsync_)));
          set_has_disable_display_vsync();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_release_overlay_resources_after_gpu_query;
        break;
      }

      // optional bool release_overlay_resources_after_gpu_query = 8;
      case 8: {
        if (tag == 64) {
         parse_release_overlay_resources_after_gpu_query:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &release_overlay_resources_after_gpu_query_)));
          set_has_release_overlay_resources_after_gpu_query();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_refresh_rate;
        break;
      }

      // optional double refresh_rate = 9;
      case 9: {
        if (tag == 73) {
         parse_refresh_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &refresh_rate_)));
          set_has_refresh_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_highp_threshold_min;
        break;
      }

      // optional uint32 highp_threshold_min = 10;
      case 10: {
        if (tag == 80) {
         parse_highp_threshold_min:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &highp_threshold_min_)));
          set_has_highp_threshold_min();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_texture_id_allocation_chunk_size;
        break;
      }

      // optional uint32 texture_id_allocation_chunk_size = 11;
      case 11: {
        if (tag == 88) {
         parse_texture_id_allocation_chunk_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &texture_id_allocation_chunk_size_)));
          set_has_texture_id_allocation_chunk_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_use_gpu_memory_buffer_resources;
        break;
      }

      // optional bool use_gpu_memory_buffer_resources = 12;
      case 12: {
        if (tag == 96) {
         parse_use_gpu_memory_buffer_resources:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_gpu_memory_buffer_resources_)));
          set_has_use_gpu_memory_buffer_resources();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_preferred_tile_format;
        break;
      }

      // optional uint32 preferred_tile_format = 13;
      case 13: {
        if (tag == 104) {
         parse_preferred_tile_format:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &preferred_tile_format_)));
          set_has_preferred_tile_format();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_buffer_to_texture_target;
        break;
      }

      // repeated .cc.proto.BufferToTextureTarget buffer_to_texture_target = 14;
      case 14: {
        if (tag == 114) {
         parse_buffer_to_texture_target:
          DO_(input->IncrementRecursionDepth());
         parse_loop_buffer_to_texture_target:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_buffer_to_texture_target()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_loop_buffer_to_texture_target;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cc.proto.RendererSettings)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cc.proto.RendererSettings)
  return false;
#undef DO_
}

void RendererSettings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cc.proto.RendererSettings)
  // optional bool allow_antialiasing = 1;
  if (has_allow_antialiasing()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->allow_antialiasing(), output);
  }

  // optional bool force_antialiasing = 2;
  if (has_force_antialiasing()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->force_antialiasing(), output);
  }

  // optional bool force_blending_with_shaders = 3;
  if (has_force_blending_with_shaders()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->force_blending_with_shaders(), output);
  }

  // optional bool partial_swap_enabled = 4;
  if (has_partial_swap_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->partial_swap_enabled(), output);
  }

  // optional bool finish_rendering_on_resize = 5;
  if (has_finish_rendering_on_resize()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->finish_rendering_on_resize(), output);
  }

  // optional bool should_clear_root_render_pass = 6;
  if (has_should_clear_root_render_pass()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->should_clear_root_render_pass(), output);
  }

  // optional bool disable_display_vsync = 7;
  if (has_disable_display_vsync()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->disable_display_vsync(), output);
  }

  // optional bool release_overlay_resources_after_gpu_query = 8;
  if (has_release_overlay_resources_after_gpu_query()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->release_overlay_resources_after_gpu_query(), output);
  }

  // optional double refresh_rate = 9;
  if (has_refresh_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->refresh_rate(), output);
  }

  // optional uint32 highp_threshold_min = 10;
  if (has_highp_threshold_min()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->highp_threshold_min(), output);
  }

  // optional uint32 texture_id_allocation_chunk_size = 11;
  if (has_texture_id_allocation_chunk_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->texture_id_allocation_chunk_size(), output);
  }

  // optional bool use_gpu_memory_buffer_resources = 12;
  if (has_use_gpu_memory_buffer_resources()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->use_gpu_memory_buffer_resources(), output);
  }

  // optional uint32 preferred_tile_format = 13;
  if (has_preferred_tile_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->preferred_tile_format(), output);
  }

  // repeated .cc.proto.BufferToTextureTarget buffer_to_texture_target = 14;
  for (unsigned int i = 0, n = this->buffer_to_texture_target_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      14, this->buffer_to_texture_target(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cc.proto.RendererSettings)
}

int RendererSettings::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cc.proto.RendererSettings)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional bool allow_antialiasing = 1;
    if (has_allow_antialiasing()) {
      total_size += 1 + 1;
    }

    // optional bool force_antialiasing = 2;
    if (has_force_antialiasing()) {
      total_size += 1 + 1;
    }

    // optional bool force_blending_with_shaders = 3;
    if (has_force_blending_with_shaders()) {
      total_size += 1 + 1;
    }

    // optional bool partial_swap_enabled = 4;
    if (has_partial_swap_enabled()) {
      total_size += 1 + 1;
    }

    // optional bool finish_rendering_on_resize = 5;
    if (has_finish_rendering_on_resize()) {
      total_size += 1 + 1;
    }

    // optional bool should_clear_root_render_pass = 6;
    if (has_should_clear_root_render_pass()) {
      total_size += 1 + 1;
    }

    // optional bool disable_display_vsync = 7;
    if (has_disable_display_vsync()) {
      total_size += 1 + 1;
    }

    // optional bool release_overlay_resources_after_gpu_query = 8;
    if (has_release_overlay_resources_after_gpu_query()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & 7936u) {
    // optional double refresh_rate = 9;
    if (has_refresh_rate()) {
      total_size += 1 + 8;
    }

    // optional uint32 highp_threshold_min = 10;
    if (has_highp_threshold_min()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->highp_threshold_min());
    }

    // optional uint32 texture_id_allocation_chunk_size = 11;
    if (has_texture_id_allocation_chunk_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->texture_id_allocation_chunk_size());
    }

    // optional bool use_gpu_memory_buffer_resources = 12;
    if (has_use_gpu_memory_buffer_resources()) {
      total_size += 1 + 1;
    }

    // optional uint32 preferred_tile_format = 13;
    if (has_preferred_tile_format()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->preferred_tile_format());
    }

  }
  // repeated .cc.proto.BufferToTextureTarget buffer_to_texture_target = 14;
  total_size += 1 * this->buffer_to_texture_target_size();
  for (int i = 0; i < this->buffer_to_texture_target_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->buffer_to_texture_target(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RendererSettings::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RendererSettings*>(&from));
}

void RendererSettings::MergeFrom(const RendererSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.RendererSettings)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  buffer_to_texture_target_.MergeFrom(from.buffer_to_texture_target_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_allow_antialiasing()) {
      set_allow_antialiasing(from.allow_antialiasing());
    }
    if (from.has_force_antialiasing()) {
      set_force_antialiasing(from.force_antialiasing());
    }
    if (from.has_force_blending_with_shaders()) {
      set_force_blending_with_shaders(from.force_blending_with_shaders());
    }
    if (from.has_partial_swap_enabled()) {
      set_partial_swap_enabled(from.partial_swap_enabled());
    }
    if (from.has_finish_rendering_on_resize()) {
      set_finish_rendering_on_resize(from.finish_rendering_on_resize());
    }
    if (from.has_should_clear_root_render_pass()) {
      set_should_clear_root_render_pass(from.should_clear_root_render_pass());
    }
    if (from.has_disable_display_vsync()) {
      set_disable_display_vsync(from.disable_display_vsync());
    }
    if (from.has_release_overlay_resources_after_gpu_query()) {
      set_release_overlay_resources_after_gpu_query(from.release_overlay_resources_after_gpu_query());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_refresh_rate()) {
      set_refresh_rate(from.refresh_rate());
    }
    if (from.has_highp_threshold_min()) {
      set_highp_threshold_min(from.highp_threshold_min());
    }
    if (from.has_texture_id_allocation_chunk_size()) {
      set_texture_id_allocation_chunk_size(from.texture_id_allocation_chunk_size());
    }
    if (from.has_use_gpu_memory_buffer_resources()) {
      set_use_gpu_memory_buffer_resources(from.use_gpu_memory_buffer_resources());
    }
    if (from.has_preferred_tile_format()) {
      set_preferred_tile_format(from.preferred_tile_format());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void RendererSettings::CopyFrom(const RendererSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.RendererSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RendererSettings::IsInitialized() const {

  return true;
}

void RendererSettings::Swap(RendererSettings* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RendererSettings::InternalSwap(RendererSettings* other) {
  std::swap(allow_antialiasing_, other->allow_antialiasing_);
  std::swap(force_antialiasing_, other->force_antialiasing_);
  std::swap(force_blending_with_shaders_, other->force_blending_with_shaders_);
  std::swap(partial_swap_enabled_, other->partial_swap_enabled_);
  std::swap(finish_rendering_on_resize_, other->finish_rendering_on_resize_);
  std::swap(should_clear_root_render_pass_, other->should_clear_root_render_pass_);
  std::swap(disable_display_vsync_, other->disable_display_vsync_);
  std::swap(release_overlay_resources_after_gpu_query_, other->release_overlay_resources_after_gpu_query_);
  std::swap(refresh_rate_, other->refresh_rate_);
  std::swap(highp_threshold_min_, other->highp_threshold_min_);
  std::swap(texture_id_allocation_chunk_size_, other->texture_id_allocation_chunk_size_);
  std::swap(use_gpu_memory_buffer_resources_, other->use_gpu_memory_buffer_resources_);
  std::swap(preferred_tile_format_, other->preferred_tile_format_);
  buffer_to_texture_target_.UnsafeArenaSwap(&other->buffer_to_texture_target_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RendererSettings::GetTypeName() const {
  return "cc.proto.RendererSettings";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RendererSettings

// optional bool allow_antialiasing = 1;
bool RendererSettings::has_allow_antialiasing() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RendererSettings::set_has_allow_antialiasing() {
  _has_bits_[0] |= 0x00000001u;
}
void RendererSettings::clear_has_allow_antialiasing() {
  _has_bits_[0] &= ~0x00000001u;
}
void RendererSettings::clear_allow_antialiasing() {
  allow_antialiasing_ = false;
  clear_has_allow_antialiasing();
}
 bool RendererSettings::allow_antialiasing() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.allow_antialiasing)
  return allow_antialiasing_;
}
 void RendererSettings::set_allow_antialiasing(bool value) {
  set_has_allow_antialiasing();
  allow_antialiasing_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.allow_antialiasing)
}

// optional bool force_antialiasing = 2;
bool RendererSettings::has_force_antialiasing() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RendererSettings::set_has_force_antialiasing() {
  _has_bits_[0] |= 0x00000002u;
}
void RendererSettings::clear_has_force_antialiasing() {
  _has_bits_[0] &= ~0x00000002u;
}
void RendererSettings::clear_force_antialiasing() {
  force_antialiasing_ = false;
  clear_has_force_antialiasing();
}
 bool RendererSettings::force_antialiasing() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.force_antialiasing)
  return force_antialiasing_;
}
 void RendererSettings::set_force_antialiasing(bool value) {
  set_has_force_antialiasing();
  force_antialiasing_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.force_antialiasing)
}

// optional bool force_blending_with_shaders = 3;
bool RendererSettings::has_force_blending_with_shaders() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RendererSettings::set_has_force_blending_with_shaders() {
  _has_bits_[0] |= 0x00000004u;
}
void RendererSettings::clear_has_force_blending_with_shaders() {
  _has_bits_[0] &= ~0x00000004u;
}
void RendererSettings::clear_force_blending_with_shaders() {
  force_blending_with_shaders_ = false;
  clear_has_force_blending_with_shaders();
}
 bool RendererSettings::force_blending_with_shaders() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.force_blending_with_shaders)
  return force_blending_with_shaders_;
}
 void RendererSettings::set_force_blending_with_shaders(bool value) {
  set_has_force_blending_with_shaders();
  force_blending_with_shaders_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.force_blending_with_shaders)
}

// optional bool partial_swap_enabled = 4;
bool RendererSettings::has_partial_swap_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RendererSettings::set_has_partial_swap_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
void RendererSettings::clear_has_partial_swap_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
void RendererSettings::clear_partial_swap_enabled() {
  partial_swap_enabled_ = false;
  clear_has_partial_swap_enabled();
}
 bool RendererSettings::partial_swap_enabled() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.partial_swap_enabled)
  return partial_swap_enabled_;
}
 void RendererSettings::set_partial_swap_enabled(bool value) {
  set_has_partial_swap_enabled();
  partial_swap_enabled_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.partial_swap_enabled)
}

// optional bool finish_rendering_on_resize = 5;
bool RendererSettings::has_finish_rendering_on_resize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RendererSettings::set_has_finish_rendering_on_resize() {
  _has_bits_[0] |= 0x00000010u;
}
void RendererSettings::clear_has_finish_rendering_on_resize() {
  _has_bits_[0] &= ~0x00000010u;
}
void RendererSettings::clear_finish_rendering_on_resize() {
  finish_rendering_on_resize_ = false;
  clear_has_finish_rendering_on_resize();
}
 bool RendererSettings::finish_rendering_on_resize() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.finish_rendering_on_resize)
  return finish_rendering_on_resize_;
}
 void RendererSettings::set_finish_rendering_on_resize(bool value) {
  set_has_finish_rendering_on_resize();
  finish_rendering_on_resize_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.finish_rendering_on_resize)
}

// optional bool should_clear_root_render_pass = 6;
bool RendererSettings::has_should_clear_root_render_pass() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RendererSettings::set_has_should_clear_root_render_pass() {
  _has_bits_[0] |= 0x00000020u;
}
void RendererSettings::clear_has_should_clear_root_render_pass() {
  _has_bits_[0] &= ~0x00000020u;
}
void RendererSettings::clear_should_clear_root_render_pass() {
  should_clear_root_render_pass_ = false;
  clear_has_should_clear_root_render_pass();
}
 bool RendererSettings::should_clear_root_render_pass() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.should_clear_root_render_pass)
  return should_clear_root_render_pass_;
}
 void RendererSettings::set_should_clear_root_render_pass(bool value) {
  set_has_should_clear_root_render_pass();
  should_clear_root_render_pass_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.should_clear_root_render_pass)
}

// optional bool disable_display_vsync = 7;
bool RendererSettings::has_disable_display_vsync() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void RendererSettings::set_has_disable_display_vsync() {
  _has_bits_[0] |= 0x00000040u;
}
void RendererSettings::clear_has_disable_display_vsync() {
  _has_bits_[0] &= ~0x00000040u;
}
void RendererSettings::clear_disable_display_vsync() {
  disable_display_vsync_ = false;
  clear_has_disable_display_vsync();
}
 bool RendererSettings::disable_display_vsync() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.disable_display_vsync)
  return disable_display_vsync_;
}
 void RendererSettings::set_disable_display_vsync(bool value) {
  set_has_disable_display_vsync();
  disable_display_vsync_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.disable_display_vsync)
}

// optional bool release_overlay_resources_after_gpu_query = 8;
bool RendererSettings::has_release_overlay_resources_after_gpu_query() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void RendererSettings::set_has_release_overlay_resources_after_gpu_query() {
  _has_bits_[0] |= 0x00000080u;
}
void RendererSettings::clear_has_release_overlay_resources_after_gpu_query() {
  _has_bits_[0] &= ~0x00000080u;
}
void RendererSettings::clear_release_overlay_resources_after_gpu_query() {
  release_overlay_resources_after_gpu_query_ = false;
  clear_has_release_overlay_resources_after_gpu_query();
}
 bool RendererSettings::release_overlay_resources_after_gpu_query() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.release_overlay_resources_after_gpu_query)
  return release_overlay_resources_after_gpu_query_;
}
 void RendererSettings::set_release_overlay_resources_after_gpu_query(bool value) {
  set_has_release_overlay_resources_after_gpu_query();
  release_overlay_resources_after_gpu_query_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.release_overlay_resources_after_gpu_query)
}

// optional double refresh_rate = 9;
bool RendererSettings::has_refresh_rate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void RendererSettings::set_has_refresh_rate() {
  _has_bits_[0] |= 0x00000100u;
}
void RendererSettings::clear_has_refresh_rate() {
  _has_bits_[0] &= ~0x00000100u;
}
void RendererSettings::clear_refresh_rate() {
  refresh_rate_ = 0;
  clear_has_refresh_rate();
}
 double RendererSettings::refresh_rate() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.refresh_rate)
  return refresh_rate_;
}
 void RendererSettings::set_refresh_rate(double value) {
  set_has_refresh_rate();
  refresh_rate_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.refresh_rate)
}

// optional uint32 highp_threshold_min = 10;
bool RendererSettings::has_highp_threshold_min() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void RendererSettings::set_has_highp_threshold_min() {
  _has_bits_[0] |= 0x00000200u;
}
void RendererSettings::clear_has_highp_threshold_min() {
  _has_bits_[0] &= ~0x00000200u;
}
void RendererSettings::clear_highp_threshold_min() {
  highp_threshold_min_ = 0u;
  clear_has_highp_threshold_min();
}
 ::google::protobuf::uint32 RendererSettings::highp_threshold_min() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.highp_threshold_min)
  return highp_threshold_min_;
}
 void RendererSettings::set_highp_threshold_min(::google::protobuf::uint32 value) {
  set_has_highp_threshold_min();
  highp_threshold_min_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.highp_threshold_min)
}

// optional uint32 texture_id_allocation_chunk_size = 11;
bool RendererSettings::has_texture_id_allocation_chunk_size() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void RendererSettings::set_has_texture_id_allocation_chunk_size() {
  _has_bits_[0] |= 0x00000400u;
}
void RendererSettings::clear_has_texture_id_allocation_chunk_size() {
  _has_bits_[0] &= ~0x00000400u;
}
void RendererSettings::clear_texture_id_allocation_chunk_size() {
  texture_id_allocation_chunk_size_ = 0u;
  clear_has_texture_id_allocation_chunk_size();
}
 ::google::protobuf::uint32 RendererSettings::texture_id_allocation_chunk_size() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.texture_id_allocation_chunk_size)
  return texture_id_allocation_chunk_size_;
}
 void RendererSettings::set_texture_id_allocation_chunk_size(::google::protobuf::uint32 value) {
  set_has_texture_id_allocation_chunk_size();
  texture_id_allocation_chunk_size_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.texture_id_allocation_chunk_size)
}

// optional bool use_gpu_memory_buffer_resources = 12;
bool RendererSettings::has_use_gpu_memory_buffer_resources() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void RendererSettings::set_has_use_gpu_memory_buffer_resources() {
  _has_bits_[0] |= 0x00000800u;
}
void RendererSettings::clear_has_use_gpu_memory_buffer_resources() {
  _has_bits_[0] &= ~0x00000800u;
}
void RendererSettings::clear_use_gpu_memory_buffer_resources() {
  use_gpu_memory_buffer_resources_ = false;
  clear_has_use_gpu_memory_buffer_resources();
}
 bool RendererSettings::use_gpu_memory_buffer_resources() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.use_gpu_memory_buffer_resources)
  return use_gpu_memory_buffer_resources_;
}
 void RendererSettings::set_use_gpu_memory_buffer_resources(bool value) {
  set_has_use_gpu_memory_buffer_resources();
  use_gpu_memory_buffer_resources_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.use_gpu_memory_buffer_resources)
}

// optional uint32 preferred_tile_format = 13;
bool RendererSettings::has_preferred_tile_format() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void RendererSettings::set_has_preferred_tile_format() {
  _has_bits_[0] |= 0x00001000u;
}
void RendererSettings::clear_has_preferred_tile_format() {
  _has_bits_[0] &= ~0x00001000u;
}
void RendererSettings::clear_preferred_tile_format() {
  preferred_tile_format_ = 0u;
  clear_has_preferred_tile_format();
}
 ::google::protobuf::uint32 RendererSettings::preferred_tile_format() const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.preferred_tile_format)
  return preferred_tile_format_;
}
 void RendererSettings::set_preferred_tile_format(::google::protobuf::uint32 value) {
  set_has_preferred_tile_format();
  preferred_tile_format_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.RendererSettings.preferred_tile_format)
}

// repeated .cc.proto.BufferToTextureTarget buffer_to_texture_target = 14;
int RendererSettings::buffer_to_texture_target_size() const {
  return buffer_to_texture_target_.size();
}
void RendererSettings::clear_buffer_to_texture_target() {
  buffer_to_texture_target_.Clear();
}
const ::cc::proto::BufferToTextureTarget& RendererSettings::buffer_to_texture_target(int index) const {
  // @@protoc_insertion_point(field_get:cc.proto.RendererSettings.buffer_to_texture_target)
  return buffer_to_texture_target_.Get(index);
}
::cc::proto::BufferToTextureTarget* RendererSettings::mutable_buffer_to_texture_target(int index) {
  // @@protoc_insertion_point(field_mutable:cc.proto.RendererSettings.buffer_to_texture_target)
  return buffer_to_texture_target_.Mutable(index);
}
::cc::proto::BufferToTextureTarget* RendererSettings::add_buffer_to_texture_target() {
  // @@protoc_insertion_point(field_add:cc.proto.RendererSettings.buffer_to_texture_target)
  return buffer_to_texture_target_.Add();
}
::google::protobuf::RepeatedPtrField< ::cc::proto::BufferToTextureTarget >*
RendererSettings::mutable_buffer_to_texture_target() {
  // @@protoc_insertion_point(field_mutable_list:cc.proto.RendererSettings.buffer_to_texture_target)
  return &buffer_to_texture_target_;
}
const ::google::protobuf::RepeatedPtrField< ::cc::proto::BufferToTextureTarget >&
RendererSettings::buffer_to_texture_target() const {
  // @@protoc_insertion_point(field_list:cc.proto.RendererSettings.buffer_to_texture_target)
  return buffer_to_texture_target_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)
