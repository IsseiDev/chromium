// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: layer_tree_host.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "layer_tree_host.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace cc {
namespace proto {

void protobuf_ShutdownFile_layer_5ftree_5fhost_2eproto() {
  delete SkPictureData::default_instance_;
  delete SkPictures::default_instance_;
  delete LayerTreeHost::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_layer_5ftree_5fhost_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_layer_5ftree_5fhost_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::cc::proto::protobuf_AddDesc_display_5fitem_2eproto();
  ::cc::proto::protobuf_AddDesc_layer_2eproto();
  ::cc::proto::protobuf_AddDesc_layer_5ftree_2eproto();
  ::cc::proto::protobuf_AddDesc_layer_5ftree_5fdebug_5fstate_2eproto();
  SkPictureData::default_instance_ = new SkPictureData();
  SkPictures::default_instance_ = new SkPictures();
  LayerTreeHost::default_instance_ = new LayerTreeHost();
  SkPictureData::default_instance_->InitAsDefaultInstance();
  SkPictures::default_instance_->InitAsDefaultInstance();
  LayerTreeHost::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_layer_5ftree_5fhost_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_layer_5ftree_5fhost_2eproto_once_);
void protobuf_AddDesc_layer_5ftree_5fhost_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_layer_5ftree_5fhost_2eproto_once_,
                 &protobuf_AddDesc_layer_5ftree_5fhost_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_layer_5ftree_5fhost_2eproto {
  StaticDescriptorInitializer_layer_5ftree_5fhost_2eproto() {
    protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
  }
} static_descriptor_initializer_layer_5ftree_5fhost_2eproto_;
#endif

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForSkPictureData(
    SkPictureData* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SkPictureData::kIdFieldNumber;
const int SkPictureData::kPayloadFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SkPictureData::SkPictureData()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cc.proto.SkPictureData)
}

void SkPictureData::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  id_ = const_cast< ::cc::proto::SkPictureID*>(
      ::cc::proto::SkPictureID::internal_default_instance());
#else
  id_ = const_cast< ::cc::proto::SkPictureID*>(&::cc::proto::SkPictureID::default_instance());
#endif
}

SkPictureData::SkPictureData(const SkPictureData& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cc.proto.SkPictureData)
}

void SkPictureData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = NULL;
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SkPictureData::~SkPictureData() {
  // @@protoc_insertion_point(destructor:cc.proto.SkPictureData)
  SharedDtor();
}

void SkPictureData::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete id_;
  }
}

void SkPictureData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SkPictureData& SkPictureData::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
#endif
  return *default_instance_;
}

SkPictureData* SkPictureData::default_instance_ = NULL;

SkPictureData* SkPictureData::New(::google::protobuf::Arena* arena) const {
  SkPictureData* n = new SkPictureData;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SkPictureData::Clear() {
// @@protoc_insertion_point(message_clear_start:cc.proto.SkPictureData)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_id()) {
      if (id_ != NULL) id_->::cc::proto::SkPictureID::Clear();
    }
    if (has_payload()) {
      payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SkPictureData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSkPictureData, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cc.proto.SkPictureData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cc.proto.SkPictureID id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_payload;
        break;
      }

      // optional bytes payload = 2;
      case 2: {
        if (tag == 18) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cc.proto.SkPictureData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cc.proto.SkPictureData)
  return false;
#undef DO_
}

void SkPictureData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cc.proto.SkPictureData)
  // optional .cc.proto.SkPictureID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->id_, output);
  }

  // optional bytes payload = 2;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->payload(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cc.proto.SkPictureData)
}

int SkPictureData::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cc.proto.SkPictureData)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cc.proto.SkPictureID id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->id_);
    }

    // optional bytes payload = 2;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SkPictureData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SkPictureData*>(&from));
}

void SkPictureData::MergeFrom(const SkPictureData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.SkPictureData)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::cc::proto::SkPictureID::MergeFrom(from.id());
    }
    if (from.has_payload()) {
      set_has_payload();
      payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SkPictureData::CopyFrom(const SkPictureData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.SkPictureData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SkPictureData::IsInitialized() const {

  return true;
}

void SkPictureData::Swap(SkPictureData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SkPictureData::InternalSwap(SkPictureData* other) {
  std::swap(id_, other->id_);
  payload_.Swap(&other->payload_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SkPictureData::GetTypeName() const {
  return "cc.proto.SkPictureData";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SkPictureData

// optional .cc.proto.SkPictureID id = 1;
bool SkPictureData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SkPictureData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void SkPictureData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void SkPictureData::clear_id() {
  if (id_ != NULL) id_->::cc::proto::SkPictureID::Clear();
  clear_has_id();
}
const ::cc::proto::SkPictureID& SkPictureData::id() const {
  // @@protoc_insertion_point(field_get:cc.proto.SkPictureData.id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
::cc::proto::SkPictureID* SkPictureData::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::cc::proto::SkPictureID;
  }
  // @@protoc_insertion_point(field_mutable:cc.proto.SkPictureData.id)
  return id_;
}
::cc::proto::SkPictureID* SkPictureData::release_id() {
  // @@protoc_insertion_point(field_release:cc.proto.SkPictureData.id)
  clear_has_id();
  ::cc::proto::SkPictureID* temp = id_;
  id_ = NULL;
  return temp;
}
void SkPictureData::set_allocated_id(::cc::proto::SkPictureID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:cc.proto.SkPictureData.id)
}

// optional bytes payload = 2;
bool SkPictureData::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SkPictureData::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
void SkPictureData::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
void SkPictureData::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
 const ::std::string& SkPictureData::payload() const {
  // @@protoc_insertion_point(field_get:cc.proto.SkPictureData.payload)
  return payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SkPictureData::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cc.proto.SkPictureData.payload)
}
 void SkPictureData::set_payload(const char* value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cc.proto.SkPictureData.payload)
}
 void SkPictureData::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cc.proto.SkPictureData.payload)
}
 ::std::string* SkPictureData::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:cc.proto.SkPictureData.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SkPictureData::release_payload() {
  // @@protoc_insertion_point(field_release:cc.proto.SkPictureData.payload)
  clear_has_payload();
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SkPictureData::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:cc.proto.SkPictureData.payload)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForSkPictures(
    SkPictures* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SkPictures::kPicturesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SkPictures::SkPictures()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cc.proto.SkPictures)
}

void SkPictures::InitAsDefaultInstance() {
}

SkPictures::SkPictures(const SkPictures& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cc.proto.SkPictures)
}

void SkPictures::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SkPictures::~SkPictures() {
  // @@protoc_insertion_point(destructor:cc.proto.SkPictures)
  SharedDtor();
}

void SkPictures::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SkPictures::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SkPictures& SkPictures::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
#endif
  return *default_instance_;
}

SkPictures* SkPictures::default_instance_ = NULL;

SkPictures* SkPictures::New(::google::protobuf::Arena* arena) const {
  SkPictures* n = new SkPictures;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SkPictures::Clear() {
// @@protoc_insertion_point(message_clear_start:cc.proto.SkPictures)
  pictures_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SkPictures::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSkPictures, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cc.proto.SkPictures)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .cc.proto.SkPictureData pictures = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_pictures:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_pictures()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_pictures;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cc.proto.SkPictures)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cc.proto.SkPictures)
  return false;
#undef DO_
}

void SkPictures::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cc.proto.SkPictures)
  // repeated .cc.proto.SkPictureData pictures = 1;
  for (unsigned int i = 0, n = this->pictures_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->pictures(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cc.proto.SkPictures)
}

int SkPictures::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cc.proto.SkPictures)
  int total_size = 0;

  // repeated .cc.proto.SkPictureData pictures = 1;
  total_size += 1 * this->pictures_size();
  for (int i = 0; i < this->pictures_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pictures(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SkPictures::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SkPictures*>(&from));
}

void SkPictures::MergeFrom(const SkPictures& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.SkPictures)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  pictures_.MergeFrom(from.pictures_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SkPictures::CopyFrom(const SkPictures& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.SkPictures)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SkPictures::IsInitialized() const {

  return true;
}

void SkPictures::Swap(SkPictures* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SkPictures::InternalSwap(SkPictures* other) {
  pictures_.UnsafeArenaSwap(&other->pictures_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SkPictures::GetTypeName() const {
  return "cc.proto.SkPictures";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SkPictures

// repeated .cc.proto.SkPictureData pictures = 1;
int SkPictures::pictures_size() const {
  return pictures_.size();
}
void SkPictures::clear_pictures() {
  pictures_.Clear();
}
const ::cc::proto::SkPictureData& SkPictures::pictures(int index) const {
  // @@protoc_insertion_point(field_get:cc.proto.SkPictures.pictures)
  return pictures_.Get(index);
}
::cc::proto::SkPictureData* SkPictures::mutable_pictures(int index) {
  // @@protoc_insertion_point(field_mutable:cc.proto.SkPictures.pictures)
  return pictures_.Mutable(index);
}
::cc::proto::SkPictureData* SkPictures::add_pictures() {
  // @@protoc_insertion_point(field_add:cc.proto.SkPictures.pictures)
  return pictures_.Add();
}
::google::protobuf::RepeatedPtrField< ::cc::proto::SkPictureData >*
SkPictures::mutable_pictures() {
  // @@protoc_insertion_point(field_mutable_list:cc.proto.SkPictures.pictures)
  return &pictures_;
}
const ::google::protobuf::RepeatedPtrField< ::cc::proto::SkPictureData >&
SkPictures::pictures() const {
  // @@protoc_insertion_point(field_list:cc.proto.SkPictures.pictures)
  return pictures_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForLayerTreeHost(
    LayerTreeHost* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LayerTreeHost::kSourceFrameNumberFieldNumber;
const int LayerTreeHost::kMetaInformationSequenceNumberFieldNumber;
const int LayerTreeHost::kDebugStateFieldNumber;
const int LayerTreeHost::kHasGpuRasterizationTriggerFieldNumber;
const int LayerTreeHost::kContentIsSuitableForGpuRasterizationFieldNumber;
const int LayerTreeHost::kIdFieldNumber;
const int LayerTreeHost::kNextCommitForcesRedrawFieldNumber;
const int LayerTreeHost::kSurfaceClientIdFieldNumber;
const int LayerTreeHost::kNextSurfaceSequenceFieldNumber;
const int LayerTreeHost::kLayerTreeFieldNumber;
const int LayerTreeHost::kLayerUpdatesFieldNumber;
const int LayerTreeHost::kPicturesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LayerTreeHost::LayerTreeHost()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cc.proto.LayerTreeHost)
}

void LayerTreeHost::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  debug_state_ = const_cast< ::cc::proto::LayerTreeDebugState*>(
      ::cc::proto::LayerTreeDebugState::internal_default_instance());
#else
  debug_state_ = const_cast< ::cc::proto::LayerTreeDebugState*>(&::cc::proto::LayerTreeDebugState::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  layer_tree_ = const_cast< ::cc::proto::LayerTree*>(
      ::cc::proto::LayerTree::internal_default_instance());
#else
  layer_tree_ = const_cast< ::cc::proto::LayerTree*>(&::cc::proto::LayerTree::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  layer_updates_ = const_cast< ::cc::proto::LayerUpdate*>(
      ::cc::proto::LayerUpdate::internal_default_instance());
#else
  layer_updates_ = const_cast< ::cc::proto::LayerUpdate*>(&::cc::proto::LayerUpdate::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  pictures_ = const_cast< ::cc::proto::SkPictures*>(
      ::cc::proto::SkPictures::internal_default_instance());
#else
  pictures_ = const_cast< ::cc::proto::SkPictures*>(&::cc::proto::SkPictures::default_instance());
#endif
}

LayerTreeHost::LayerTreeHost(const LayerTreeHost& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cc.proto.LayerTreeHost)
}

void LayerTreeHost::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_frame_number_ = 0;
  meta_information_sequence_number_ = 0;
  debug_state_ = NULL;
  has_gpu_rasterization_trigger_ = false;
  content_is_suitable_for_gpu_rasterization_ = false;
  id_ = 0;
  next_commit_forces_redraw_ = false;
  surface_client_id_ = 0u;
  next_surface_sequence_ = 0u;
  layer_tree_ = NULL;
  layer_updates_ = NULL;
  pictures_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LayerTreeHost::~LayerTreeHost() {
  // @@protoc_insertion_point(destructor:cc.proto.LayerTreeHost)
  SharedDtor();
}

void LayerTreeHost::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete debug_state_;
    delete layer_tree_;
    delete layer_updates_;
    delete pictures_;
  }
}

void LayerTreeHost::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const LayerTreeHost& LayerTreeHost::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
#endif
  return *default_instance_;
}

LayerTreeHost* LayerTreeHost::default_instance_ = NULL;

LayerTreeHost* LayerTreeHost::New(::google::protobuf::Arena* arena) const {
  LayerTreeHost* n = new LayerTreeHost;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LayerTreeHost::Clear() {
// @@protoc_insertion_point(message_clear_start:cc.proto.LayerTreeHost)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(LayerTreeHost, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<LayerTreeHost*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(source_frame_number_, meta_information_sequence_number_);
    ZR_(has_gpu_rasterization_trigger_, surface_client_id_);
    if (has_debug_state()) {
      if (debug_state_ != NULL) debug_state_->::cc::proto::LayerTreeDebugState::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 3840u) {
    next_surface_sequence_ = 0u;
    if (has_layer_tree()) {
      if (layer_tree_ != NULL) layer_tree_->::cc::proto::LayerTree::Clear();
    }
    if (has_layer_updates()) {
      if (layer_updates_ != NULL) layer_updates_->::cc::proto::LayerUpdate::Clear();
    }
    if (has_pictures()) {
      if (pictures_ != NULL) pictures_->::cc::proto::SkPictures::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool LayerTreeHost::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForLayerTreeHost, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cc.proto.LayerTreeHost)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 source_frame_number = 3;
      case 3: {
        if (tag == 24) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &source_frame_number_)));
          set_has_source_frame_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_meta_information_sequence_number;
        break;
      }

      // optional int32 meta_information_sequence_number = 4;
      case 4: {
        if (tag == 32) {
         parse_meta_information_sequence_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &meta_information_sequence_number_)));
          set_has_meta_information_sequence_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_debug_state;
        break;
      }

      // optional .cc.proto.LayerTreeDebugState debug_state = 8;
      case 8: {
        if (tag == 66) {
         parse_debug_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_debug_state()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_has_gpu_rasterization_trigger;
        break;
      }

      // optional bool has_gpu_rasterization_trigger = 19;
      case 19: {
        if (tag == 152) {
         parse_has_gpu_rasterization_trigger:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_gpu_rasterization_trigger_)));
          set_has_has_gpu_rasterization_trigger();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_content_is_suitable_for_gpu_rasterization;
        break;
      }

      // optional bool content_is_suitable_for_gpu_rasterization = 20;
      case 20: {
        if (tag == 160) {
         parse_content_is_suitable_for_gpu_rasterization:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &content_is_suitable_for_gpu_rasterization_)));
          set_has_content_is_suitable_for_gpu_rasterization();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_id;
        break;
      }

      // optional int32 id = 23;
      case 23: {
        if (tag == 184) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_next_commit_forces_redraw;
        break;
      }

      // optional bool next_commit_forces_redraw = 24;
      case 24: {
        if (tag == 192) {
         parse_next_commit_forces_redraw:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &next_commit_forces_redraw_)));
          set_has_next_commit_forces_redraw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(226)) goto parse_layer_updates;
        break;
      }

      // optional .cc.proto.LayerUpdate layer_updates = 28;
      case 28: {
        if (tag == 226) {
         parse_layer_updates:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_layer_updates()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_surface_client_id;
        break;
      }

      // optional uint32 surface_client_id = 31;
      case 31: {
        if (tag == 248) {
         parse_surface_client_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &surface_client_id_)));
          set_has_surface_client_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(256)) goto parse_next_surface_sequence;
        break;
      }

      // optional uint32 next_surface_sequence = 32;
      case 32: {
        if (tag == 256) {
         parse_next_surface_sequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &next_surface_sequence_)));
          set_has_next_surface_sequence();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(290)) goto parse_layer_tree;
        break;
      }

      // optional .cc.proto.LayerTree layer_tree = 36;
      case 36: {
        if (tag == 290) {
         parse_layer_tree:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_layer_tree()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(306)) goto parse_pictures;
        break;
      }

      // optional .cc.proto.SkPictures pictures = 38;
      case 38: {
        if (tag == 306) {
         parse_pictures:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pictures()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cc.proto.LayerTreeHost)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cc.proto.LayerTreeHost)
  return false;
#undef DO_
}

void LayerTreeHost::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cc.proto.LayerTreeHost)
  // optional int32 source_frame_number = 3;
  if (has_source_frame_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->source_frame_number(), output);
  }

  // optional int32 meta_information_sequence_number = 4;
  if (has_meta_information_sequence_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->meta_information_sequence_number(), output);
  }

  // optional .cc.proto.LayerTreeDebugState debug_state = 8;
  if (has_debug_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, *this->debug_state_, output);
  }

  // optional bool has_gpu_rasterization_trigger = 19;
  if (has_has_gpu_rasterization_trigger()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(19, this->has_gpu_rasterization_trigger(), output);
  }

  // optional bool content_is_suitable_for_gpu_rasterization = 20;
  if (has_content_is_suitable_for_gpu_rasterization()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(20, this->content_is_suitable_for_gpu_rasterization(), output);
  }

  // optional int32 id = 23;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(23, this->id(), output);
  }

  // optional bool next_commit_forces_redraw = 24;
  if (has_next_commit_forces_redraw()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(24, this->next_commit_forces_redraw(), output);
  }

  // optional .cc.proto.LayerUpdate layer_updates = 28;
  if (has_layer_updates()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      28, *this->layer_updates_, output);
  }

  // optional uint32 surface_client_id = 31;
  if (has_surface_client_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(31, this->surface_client_id(), output);
  }

  // optional uint32 next_surface_sequence = 32;
  if (has_next_surface_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(32, this->next_surface_sequence(), output);
  }

  // optional .cc.proto.LayerTree layer_tree = 36;
  if (has_layer_tree()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      36, *this->layer_tree_, output);
  }

  // optional .cc.proto.SkPictures pictures = 38;
  if (has_pictures()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      38, *this->pictures_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cc.proto.LayerTreeHost)
}

int LayerTreeHost::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cc.proto.LayerTreeHost)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional int32 source_frame_number = 3;
    if (has_source_frame_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->source_frame_number());
    }

    // optional int32 meta_information_sequence_number = 4;
    if (has_meta_information_sequence_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->meta_information_sequence_number());
    }

    // optional .cc.proto.LayerTreeDebugState debug_state = 8;
    if (has_debug_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->debug_state_);
    }

    // optional bool has_gpu_rasterization_trigger = 19;
    if (has_has_gpu_rasterization_trigger()) {
      total_size += 2 + 1;
    }

    // optional bool content_is_suitable_for_gpu_rasterization = 20;
    if (has_content_is_suitable_for_gpu_rasterization()) {
      total_size += 2 + 1;
    }

    // optional int32 id = 23;
    if (has_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional bool next_commit_forces_redraw = 24;
    if (has_next_commit_forces_redraw()) {
      total_size += 2 + 1;
    }

    // optional uint32 surface_client_id = 31;
    if (has_surface_client_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->surface_client_id());
    }

  }
  if (_has_bits_[8 / 32] & 3840u) {
    // optional uint32 next_surface_sequence = 32;
    if (has_next_surface_sequence()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->next_surface_sequence());
    }

    // optional .cc.proto.LayerTree layer_tree = 36;
    if (has_layer_tree()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->layer_tree_);
    }

    // optional .cc.proto.LayerUpdate layer_updates = 28;
    if (has_layer_updates()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->layer_updates_);
    }

    // optional .cc.proto.SkPictures pictures = 38;
    if (has_pictures()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pictures_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LayerTreeHost::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const LayerTreeHost*>(&from));
}

void LayerTreeHost::MergeFrom(const LayerTreeHost& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.LayerTreeHost)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_source_frame_number()) {
      set_source_frame_number(from.source_frame_number());
    }
    if (from.has_meta_information_sequence_number()) {
      set_meta_information_sequence_number(from.meta_information_sequence_number());
    }
    if (from.has_debug_state()) {
      mutable_debug_state()->::cc::proto::LayerTreeDebugState::MergeFrom(from.debug_state());
    }
    if (from.has_has_gpu_rasterization_trigger()) {
      set_has_gpu_rasterization_trigger(from.has_gpu_rasterization_trigger());
    }
    if (from.has_content_is_suitable_for_gpu_rasterization()) {
      set_content_is_suitable_for_gpu_rasterization(from.content_is_suitable_for_gpu_rasterization());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_next_commit_forces_redraw()) {
      set_next_commit_forces_redraw(from.next_commit_forces_redraw());
    }
    if (from.has_surface_client_id()) {
      set_surface_client_id(from.surface_client_id());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_next_surface_sequence()) {
      set_next_surface_sequence(from.next_surface_sequence());
    }
    if (from.has_layer_tree()) {
      mutable_layer_tree()->::cc::proto::LayerTree::MergeFrom(from.layer_tree());
    }
    if (from.has_layer_updates()) {
      mutable_layer_updates()->::cc::proto::LayerUpdate::MergeFrom(from.layer_updates());
    }
    if (from.has_pictures()) {
      mutable_pictures()->::cc::proto::SkPictures::MergeFrom(from.pictures());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void LayerTreeHost::CopyFrom(const LayerTreeHost& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.LayerTreeHost)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LayerTreeHost::IsInitialized() const {

  if (has_layer_tree()) {
    if (!this->layer_tree_->IsInitialized()) return false;
  }
  return true;
}

void LayerTreeHost::Swap(LayerTreeHost* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LayerTreeHost::InternalSwap(LayerTreeHost* other) {
  std::swap(source_frame_number_, other->source_frame_number_);
  std::swap(meta_information_sequence_number_, other->meta_information_sequence_number_);
  std::swap(debug_state_, other->debug_state_);
  std::swap(has_gpu_rasterization_trigger_, other->has_gpu_rasterization_trigger_);
  std::swap(content_is_suitable_for_gpu_rasterization_, other->content_is_suitable_for_gpu_rasterization_);
  std::swap(id_, other->id_);
  std::swap(next_commit_forces_redraw_, other->next_commit_forces_redraw_);
  std::swap(surface_client_id_, other->surface_client_id_);
  std::swap(next_surface_sequence_, other->next_surface_sequence_);
  std::swap(layer_tree_, other->layer_tree_);
  std::swap(layer_updates_, other->layer_updates_);
  std::swap(pictures_, other->pictures_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string LayerTreeHost::GetTypeName() const {
  return "cc.proto.LayerTreeHost";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LayerTreeHost

// optional int32 source_frame_number = 3;
bool LayerTreeHost::has_source_frame_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LayerTreeHost::set_has_source_frame_number() {
  _has_bits_[0] |= 0x00000001u;
}
void LayerTreeHost::clear_has_source_frame_number() {
  _has_bits_[0] &= ~0x00000001u;
}
void LayerTreeHost::clear_source_frame_number() {
  source_frame_number_ = 0;
  clear_has_source_frame_number();
}
 ::google::protobuf::int32 LayerTreeHost::source_frame_number() const {
  // @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.source_frame_number)
  return source_frame_number_;
}
 void LayerTreeHost::set_source_frame_number(::google::protobuf::int32 value) {
  set_has_source_frame_number();
  source_frame_number_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.source_frame_number)
}

// optional int32 meta_information_sequence_number = 4;
bool LayerTreeHost::has_meta_information_sequence_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void LayerTreeHost::set_has_meta_information_sequence_number() {
  _has_bits_[0] |= 0x00000002u;
}
void LayerTreeHost::clear_has_meta_information_sequence_number() {
  _has_bits_[0] &= ~0x00000002u;
}
void LayerTreeHost::clear_meta_information_sequence_number() {
  meta_information_sequence_number_ = 0;
  clear_has_meta_information_sequence_number();
}
 ::google::protobuf::int32 LayerTreeHost::meta_information_sequence_number() const {
  // @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.meta_information_sequence_number)
  return meta_information_sequence_number_;
}
 void LayerTreeHost::set_meta_information_sequence_number(::google::protobuf::int32 value) {
  set_has_meta_information_sequence_number();
  meta_information_sequence_number_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.meta_information_sequence_number)
}

// optional .cc.proto.LayerTreeDebugState debug_state = 8;
bool LayerTreeHost::has_debug_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void LayerTreeHost::set_has_debug_state() {
  _has_bits_[0] |= 0x00000004u;
}
void LayerTreeHost::clear_has_debug_state() {
  _has_bits_[0] &= ~0x00000004u;
}
void LayerTreeHost::clear_debug_state() {
  if (debug_state_ != NULL) debug_state_->::cc::proto::LayerTreeDebugState::Clear();
  clear_has_debug_state();
}
const ::cc::proto::LayerTreeDebugState& LayerTreeHost::debug_state() const {
  // @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.debug_state)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return debug_state_ != NULL ? *debug_state_ : *default_instance().debug_state_;
#else
  return debug_state_ != NULL ? *debug_state_ : *default_instance_->debug_state_;
#endif
}
::cc::proto::LayerTreeDebugState* LayerTreeHost::mutable_debug_state() {
  set_has_debug_state();
  if (debug_state_ == NULL) {
    debug_state_ = new ::cc::proto::LayerTreeDebugState;
  }
  // @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeHost.debug_state)
  return debug_state_;
}
::cc::proto::LayerTreeDebugState* LayerTreeHost::release_debug_state() {
  // @@protoc_insertion_point(field_release:cc.proto.LayerTreeHost.debug_state)
  clear_has_debug_state();
  ::cc::proto::LayerTreeDebugState* temp = debug_state_;
  debug_state_ = NULL;
  return temp;
}
void LayerTreeHost::set_allocated_debug_state(::cc::proto::LayerTreeDebugState* debug_state) {
  delete debug_state_;
  debug_state_ = debug_state;
  if (debug_state) {
    set_has_debug_state();
  } else {
    clear_has_debug_state();
  }
  // @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeHost.debug_state)
}

// optional bool has_gpu_rasterization_trigger = 19;
bool LayerTreeHost::has_has_gpu_rasterization_trigger() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void LayerTreeHost::set_has_has_gpu_rasterization_trigger() {
  _has_bits_[0] |= 0x00000008u;
}
void LayerTreeHost::clear_has_has_gpu_rasterization_trigger() {
  _has_bits_[0] &= ~0x00000008u;
}
void LayerTreeHost::clear_has_gpu_rasterization_trigger() {
  has_gpu_rasterization_trigger_ = false;
  clear_has_has_gpu_rasterization_trigger();
}
 bool LayerTreeHost::has_gpu_rasterization_trigger() const {
  // @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.has_gpu_rasterization_trigger)
  return has_gpu_rasterization_trigger_;
}
 void LayerTreeHost::set_has_gpu_rasterization_trigger(bool value) {
  set_has_has_gpu_rasterization_trigger();
  has_gpu_rasterization_trigger_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.has_gpu_rasterization_trigger)
}

// optional bool content_is_suitable_for_gpu_rasterization = 20;
bool LayerTreeHost::has_content_is_suitable_for_gpu_rasterization() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void LayerTreeHost::set_has_content_is_suitable_for_gpu_rasterization() {
  _has_bits_[0] |= 0x00000010u;
}
void LayerTreeHost::clear_has_content_is_suitable_for_gpu_rasterization() {
  _has_bits_[0] &= ~0x00000010u;
}
void LayerTreeHost::clear_content_is_suitable_for_gpu_rasterization() {
  content_is_suitable_for_gpu_rasterization_ = false;
  clear_has_content_is_suitable_for_gpu_rasterization();
}
 bool LayerTreeHost::content_is_suitable_for_gpu_rasterization() const {
  // @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.content_is_suitable_for_gpu_rasterization)
  return content_is_suitable_for_gpu_rasterization_;
}
 void LayerTreeHost::set_content_is_suitable_for_gpu_rasterization(bool value) {
  set_has_content_is_suitable_for_gpu_rasterization();
  content_is_suitable_for_gpu_rasterization_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.content_is_suitable_for_gpu_rasterization)
}

// optional int32 id = 23;
bool LayerTreeHost::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void LayerTreeHost::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
void LayerTreeHost::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
void LayerTreeHost::clear_id() {
  id_ = 0;
  clear_has_id();
}
 ::google::protobuf::int32 LayerTreeHost::id() const {
  // @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.id)
  return id_;
}
 void LayerTreeHost::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.id)
}

// optional bool next_commit_forces_redraw = 24;
bool LayerTreeHost::has_next_commit_forces_redraw() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void LayerTreeHost::set_has_next_commit_forces_redraw() {
  _has_bits_[0] |= 0x00000040u;
}
void LayerTreeHost::clear_has_next_commit_forces_redraw() {
  _has_bits_[0] &= ~0x00000040u;
}
void LayerTreeHost::clear_next_commit_forces_redraw() {
  next_commit_forces_redraw_ = false;
  clear_has_next_commit_forces_redraw();
}
 bool LayerTreeHost::next_commit_forces_redraw() const {
  // @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.next_commit_forces_redraw)
  return next_commit_forces_redraw_;
}
 void LayerTreeHost::set_next_commit_forces_redraw(bool value) {
  set_has_next_commit_forces_redraw();
  next_commit_forces_redraw_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.next_commit_forces_redraw)
}

// optional uint32 surface_client_id = 31;
bool LayerTreeHost::has_surface_client_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void LayerTreeHost::set_has_surface_client_id() {
  _has_bits_[0] |= 0x00000080u;
}
void LayerTreeHost::clear_has_surface_client_id() {
  _has_bits_[0] &= ~0x00000080u;
}
void LayerTreeHost::clear_surface_client_id() {
  surface_client_id_ = 0u;
  clear_has_surface_client_id();
}
 ::google::protobuf::uint32 LayerTreeHost::surface_client_id() const {
  // @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.surface_client_id)
  return surface_client_id_;
}
 void LayerTreeHost::set_surface_client_id(::google::protobuf::uint32 value) {
  set_has_surface_client_id();
  surface_client_id_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.surface_client_id)
}

// optional uint32 next_surface_sequence = 32;
bool LayerTreeHost::has_next_surface_sequence() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void LayerTreeHost::set_has_next_surface_sequence() {
  _has_bits_[0] |= 0x00000100u;
}
void LayerTreeHost::clear_has_next_surface_sequence() {
  _has_bits_[0] &= ~0x00000100u;
}
void LayerTreeHost::clear_next_surface_sequence() {
  next_surface_sequence_ = 0u;
  clear_has_next_surface_sequence();
}
 ::google::protobuf::uint32 LayerTreeHost::next_surface_sequence() const {
  // @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.next_surface_sequence)
  return next_surface_sequence_;
}
 void LayerTreeHost::set_next_surface_sequence(::google::protobuf::uint32 value) {
  set_has_next_surface_sequence();
  next_surface_sequence_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.next_surface_sequence)
}

// optional .cc.proto.LayerTree layer_tree = 36;
bool LayerTreeHost::has_layer_tree() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void LayerTreeHost::set_has_layer_tree() {
  _has_bits_[0] |= 0x00000200u;
}
void LayerTreeHost::clear_has_layer_tree() {
  _has_bits_[0] &= ~0x00000200u;
}
void LayerTreeHost::clear_layer_tree() {
  if (layer_tree_ != NULL) layer_tree_->::cc::proto::LayerTree::Clear();
  clear_has_layer_tree();
}
const ::cc::proto::LayerTree& LayerTreeHost::layer_tree() const {
  // @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.layer_tree)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return layer_tree_ != NULL ? *layer_tree_ : *default_instance().layer_tree_;
#else
  return layer_tree_ != NULL ? *layer_tree_ : *default_instance_->layer_tree_;
#endif
}
::cc::proto::LayerTree* LayerTreeHost::mutable_layer_tree() {
  set_has_layer_tree();
  if (layer_tree_ == NULL) {
    layer_tree_ = new ::cc::proto::LayerTree;
  }
  // @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeHost.layer_tree)
  return layer_tree_;
}
::cc::proto::LayerTree* LayerTreeHost::release_layer_tree() {
  // @@protoc_insertion_point(field_release:cc.proto.LayerTreeHost.layer_tree)
  clear_has_layer_tree();
  ::cc::proto::LayerTree* temp = layer_tree_;
  layer_tree_ = NULL;
  return temp;
}
void LayerTreeHost::set_allocated_layer_tree(::cc::proto::LayerTree* layer_tree) {
  delete layer_tree_;
  layer_tree_ = layer_tree;
  if (layer_tree) {
    set_has_layer_tree();
  } else {
    clear_has_layer_tree();
  }
  // @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeHost.layer_tree)
}

// optional .cc.proto.LayerUpdate layer_updates = 28;
bool LayerTreeHost::has_layer_updates() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void LayerTreeHost::set_has_layer_updates() {
  _has_bits_[0] |= 0x00000400u;
}
void LayerTreeHost::clear_has_layer_updates() {
  _has_bits_[0] &= ~0x00000400u;
}
void LayerTreeHost::clear_layer_updates() {
  if (layer_updates_ != NULL) layer_updates_->::cc::proto::LayerUpdate::Clear();
  clear_has_layer_updates();
}
const ::cc::proto::LayerUpdate& LayerTreeHost::layer_updates() const {
  // @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.layer_updates)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return layer_updates_ != NULL ? *layer_updates_ : *default_instance().layer_updates_;
#else
  return layer_updates_ != NULL ? *layer_updates_ : *default_instance_->layer_updates_;
#endif
}
::cc::proto::LayerUpdate* LayerTreeHost::mutable_layer_updates() {
  set_has_layer_updates();
  if (layer_updates_ == NULL) {
    layer_updates_ = new ::cc::proto::LayerUpdate;
  }
  // @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeHost.layer_updates)
  return layer_updates_;
}
::cc::proto::LayerUpdate* LayerTreeHost::release_layer_updates() {
  // @@protoc_insertion_point(field_release:cc.proto.LayerTreeHost.layer_updates)
  clear_has_layer_updates();
  ::cc::proto::LayerUpdate* temp = layer_updates_;
  layer_updates_ = NULL;
  return temp;
}
void LayerTreeHost::set_allocated_layer_updates(::cc::proto::LayerUpdate* layer_updates) {
  delete layer_updates_;
  layer_updates_ = layer_updates;
  if (layer_updates) {
    set_has_layer_updates();
  } else {
    clear_has_layer_updates();
  }
  // @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeHost.layer_updates)
}

// optional .cc.proto.SkPictures pictures = 38;
bool LayerTreeHost::has_pictures() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void LayerTreeHost::set_has_pictures() {
  _has_bits_[0] |= 0x00000800u;
}
void LayerTreeHost::clear_has_pictures() {
  _has_bits_[0] &= ~0x00000800u;
}
void LayerTreeHost::clear_pictures() {
  if (pictures_ != NULL) pictures_->::cc::proto::SkPictures::Clear();
  clear_has_pictures();
}
const ::cc::proto::SkPictures& LayerTreeHost::pictures() const {
  // @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.pictures)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pictures_ != NULL ? *pictures_ : *default_instance().pictures_;
#else
  return pictures_ != NULL ? *pictures_ : *default_instance_->pictures_;
#endif
}
::cc::proto::SkPictures* LayerTreeHost::mutable_pictures() {
  set_has_pictures();
  if (pictures_ == NULL) {
    pictures_ = new ::cc::proto::SkPictures;
  }
  // @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeHost.pictures)
  return pictures_;
}
::cc::proto::SkPictures* LayerTreeHost::release_pictures() {
  // @@protoc_insertion_point(field_release:cc.proto.LayerTreeHost.pictures)
  clear_has_pictures();
  ::cc::proto::SkPictures* temp = pictures_;
  pictures_ = NULL;
  return temp;
}
void LayerTreeHost::set_allocated_pictures(::cc::proto::SkPictures* pictures) {
  delete pictures_;
  pictures_ = pictures;
  if (pictures) {
    set_has_pictures();
  } else {
    clear_has_pictures();
  }
  // @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeHost.pictures)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)
