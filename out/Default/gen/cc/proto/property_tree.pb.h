// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: property_tree.proto

#ifndef PROTOBUF_property_5ftree_2eproto__INCLUDED
#define PROTOBUF_property_5ftree_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include "element_id.pb.h"
#include "rectf.pb.h"
#include "scroll_offset.pb.h"
#include "size.pb.h"
#include "skxfermode.pb.h"
#include "synced_property.pb.h"
#include "transform.pb.h"
#include "vector2df.pb.h"
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

// Internal implementation detail -- do not call these.
void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
void protobuf_AssignDesc_property_5ftree_2eproto();
void protobuf_ShutdownFile_property_5ftree_2eproto();

class ClipNodeData;
class EffectNodeData;
class EffectTreeData;
class PropertyTree;
class PropertyTrees;
class ScrollNodeData;
class ScrollOffsetMapEntry;
class ScrollTreeData;
class TranformNodeData;
class TransformCachedNodeData;
class TransformTreeData;
class TreeNode;

enum PropertyTree_PropertyType {
PropertyTree_PropertyType_Transform = 1,
PropertyTree_PropertyType_Clip = 2,
PropertyTree_PropertyType_Effect = 3,
PropertyTree_PropertyType_Scroll = 4
};
CC_PROTO_EXPORT bool PropertyTree_PropertyType_IsValid(int value);
const PropertyTree_PropertyType PropertyTree_PropertyType_PropertyType_MIN = PropertyTree_PropertyType_Transform;
const PropertyTree_PropertyType PropertyTree_PropertyType_PropertyType_MAX = PropertyTree_PropertyType_Scroll;
const int PropertyTree_PropertyType_PropertyType_ARRAYSIZE = PropertyTree_PropertyType_PropertyType_MAX + 1;

// ===================================================================

class CC_PROTO_EXPORT TranformNodeData : public ::google::protobuf::MessageLite {
public:
TranformNodeData();
virtual ~TranformNodeData();

TranformNodeData(const TranformNodeData& from);

inline TranformNodeData& operator=(const TranformNodeData& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const TranformNodeData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const TranformNodeData* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(TranformNodeData* other);

// implements Message ----------------------------------------------

inline TranformNodeData* New() const { return New(NULL); }

TranformNodeData* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const TranformNodeData& from);
void MergeFrom(const TranformNodeData& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(TranformNodeData* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional .cc.proto.Transform pre_local = 1;
bool has_pre_local() const;
void clear_pre_local();
static const int kPreLocalFieldNumber = 1;
const ::cc::proto::Transform& pre_local() const;
::cc::proto::Transform* mutable_pre_local();
::cc::proto::Transform* release_pre_local();
void set_allocated_pre_local(::cc::proto::Transform* pre_local);

// optional .cc.proto.Transform local = 2;
bool has_local() const;
void clear_local();
static const int kLocalFieldNumber = 2;
const ::cc::proto::Transform& local() const;
::cc::proto::Transform* mutable_local();
::cc::proto::Transform* release_local();
void set_allocated_local(::cc::proto::Transform* local);

// optional .cc.proto.Transform post_local = 3;
bool has_post_local() const;
void clear_post_local();
static const int kPostLocalFieldNumber = 3;
const ::cc::proto::Transform& post_local() const;
::cc::proto::Transform* mutable_post_local();
::cc::proto::Transform* release_post_local();
void set_allocated_post_local(::cc::proto::Transform* post_local);

// optional .cc.proto.Transform to_parent = 4;
bool has_to_parent() const;
void clear_to_parent();
static const int kToParentFieldNumber = 4;
const ::cc::proto::Transform& to_parent() const;
::cc::proto::Transform* mutable_to_parent();
::cc::proto::Transform* release_to_parent();
void set_allocated_to_parent(::cc::proto::Transform* to_parent);

// optional int64 source_node_id = 11;
bool has_source_node_id() const;
void clear_source_node_id();
static const int kSourceNodeIdFieldNumber = 11;
::google::protobuf::int64 source_node_id() const;
void set_source_node_id(::google::protobuf::int64 value);

// optional bool needs_local_transform_update = 12;
bool has_needs_local_transform_update() const;
void clear_needs_local_transform_update();
static const int kNeedsLocalTransformUpdateFieldNumber = 12;
bool needs_local_transform_update() const;
void set_needs_local_transform_update(bool value);

// optional bool node_and_ancestors_are_animated_or_invertible = 41;
bool has_node_and_ancestors_are_animated_or_invertible() const;
void clear_node_and_ancestors_are_animated_or_invertible();
static const int kNodeAndAncestorsAreAnimatedOrInvertibleFieldNumber = 41;
bool node_and_ancestors_are_animated_or_invertible() const;
void set_node_and_ancestors_are_animated_or_invertible(bool value);

// optional bool is_invertible = 13;
bool has_is_invertible() const;
void clear_is_invertible();
static const int kIsInvertibleFieldNumber = 13;
bool is_invertible() const;
void set_is_invertible(bool value);

// optional bool ancestors_are_invertible = 14;
bool has_ancestors_are_invertible() const;
void clear_ancestors_are_invertible();
static const int kAncestorsAreInvertibleFieldNumber = 14;
bool ancestors_are_invertible() const;
void set_ancestors_are_invertible(bool value);

// optional bool has_potential_animation = 15;
bool has_has_potential_animation() const;
void clear_has_potential_animation();
static const int kHasPotentialAnimationFieldNumber = 15;
bool has_potential_animation() const;
void set_has_potential_animation(bool value);

// optional bool is_currently_animating = 42;
bool has_is_currently_animating() const;
void clear_is_currently_animating();
static const int kIsCurrentlyAnimatingFieldNumber = 42;
bool is_currently_animating() const;
void set_is_currently_animating(bool value);

// optional bool to_screen_is_potentially_animated = 16;
bool has_to_screen_is_potentially_animated() const;
void clear_to_screen_is_potentially_animated();
static const int kToScreenIsPotentiallyAnimatedFieldNumber = 16;
bool to_screen_is_potentially_animated() const;
void set_to_screen_is_potentially_animated(bool value);

// optional bool has_only_translation_animations = 17;
bool has_has_only_translation_animations() const;
void clear_has_only_translation_animations();
static const int kHasOnlyTranslationAnimationsFieldNumber = 17;
bool has_only_translation_animations() const;
void set_has_only_translation_animations(bool value);

// optional bool flattens_inherited_transform = 19;
bool has_flattens_inherited_transform() const;
void clear_flattens_inherited_transform();
static const int kFlattensInheritedTransformFieldNumber = 19;
bool flattens_inherited_transform() const;
void set_flattens_inherited_transform(bool value);

// optional bool node_and_ancestors_are_flat = 20;
bool has_node_and_ancestors_are_flat() const;
void clear_node_and_ancestors_are_flat();
static const int kNodeAndAncestorsAreFlatFieldNumber = 20;
bool node_and_ancestors_are_flat() const;
void set_node_and_ancestors_are_flat(bool value);

// optional bool node_and_ancestors_have_only_integer_translation = 21;
bool has_node_and_ancestors_have_only_integer_translation() const;
void clear_node_and_ancestors_have_only_integer_translation();
static const int kNodeAndAncestorsHaveOnlyIntegerTranslationFieldNumber = 21;
bool node_and_ancestors_have_only_integer_translation() const;
void set_node_and_ancestors_have_only_integer_translation(bool value);

// optional bool scrolls = 22;
bool has_scrolls() const;
void clear_scrolls();
static const int kScrollsFieldNumber = 22;
bool scrolls() const;
void set_scrolls(bool value);

// optional bool needs_surface_contents_scale = 23;
bool has_needs_surface_contents_scale() const;
void clear_needs_surface_contents_scale();
static const int kNeedsSurfaceContentsScaleFieldNumber = 23;
bool needs_surface_contents_scale() const;
void set_needs_surface_contents_scale(bool value);

// optional bool affected_by_inner_viewport_bounds_delta_x = 24;
bool has_affected_by_inner_viewport_bounds_delta_x() const;
void clear_affected_by_inner_viewport_bounds_delta_x();
static const int kAffectedByInnerViewportBoundsDeltaXFieldNumber = 24;
bool affected_by_inner_viewport_bounds_delta_x() const;
void set_affected_by_inner_viewport_bounds_delta_x(bool value);

// optional bool affected_by_inner_viewport_bounds_delta_y = 25;
bool has_affected_by_inner_viewport_bounds_delta_y() const;
void clear_affected_by_inner_viewport_bounds_delta_y();
static const int kAffectedByInnerViewportBoundsDeltaYFieldNumber = 25;
bool affected_by_inner_viewport_bounds_delta_y() const;
void set_affected_by_inner_viewport_bounds_delta_y(bool value);

// optional bool affected_by_outer_viewport_bounds_delta_x = 26;
bool has_affected_by_outer_viewport_bounds_delta_x() const;
void clear_affected_by_outer_viewport_bounds_delta_x();
static const int kAffectedByOuterViewportBoundsDeltaXFieldNumber = 26;
bool affected_by_outer_viewport_bounds_delta_x() const;
void set_affected_by_outer_viewport_bounds_delta_x(bool value);

// optional bool affected_by_outer_viewport_bounds_delta_y = 27;
bool has_affected_by_outer_viewport_bounds_delta_y() const;
void clear_affected_by_outer_viewport_bounds_delta_y();
static const int kAffectedByOuterViewportBoundsDeltaYFieldNumber = 27;
bool affected_by_outer_viewport_bounds_delta_y() const;
void set_affected_by_outer_viewport_bounds_delta_y(bool value);

// optional bool in_subtree_of_page_scale_layer = 28;
bool has_in_subtree_of_page_scale_layer() const;
void clear_in_subtree_of_page_scale_layer();
static const int kInSubtreeOfPageScaleLayerFieldNumber = 28;
bool in_subtree_of_page_scale_layer() const;
void set_in_subtree_of_page_scale_layer(bool value);

// optional bool transform_changed = 40;
bool has_transform_changed() const;
void clear_transform_changed();
static const int kTransformChangedFieldNumber = 40;
bool transform_changed() const;
void set_transform_changed(bool value);

// optional float post_local_scale_factor = 29;
bool has_post_local_scale_factor() const;
void clear_post_local_scale_factor();
static const int kPostLocalScaleFactorFieldNumber = 29;
float post_local_scale_factor() const;
void set_post_local_scale_factor(float value);

// optional .cc.proto.Vector2dF surface_contents_scale = 34;
bool has_surface_contents_scale() const;
void clear_surface_contents_scale();
static const int kSurfaceContentsScaleFieldNumber = 34;
const ::cc::proto::Vector2dF& surface_contents_scale() const;
::cc::proto::Vector2dF* mutable_surface_contents_scale();
::cc::proto::Vector2dF* release_surface_contents_scale();
void set_allocated_surface_contents_scale(::cc::proto::Vector2dF* surface_contents_scale);

// optional .cc.proto.ScrollOffset scroll_offset = 35;
bool has_scroll_offset() const;
void clear_scroll_offset();
static const int kScrollOffsetFieldNumber = 35;
const ::cc::proto::ScrollOffset& scroll_offset() const;
::cc::proto::ScrollOffset* mutable_scroll_offset();
::cc::proto::ScrollOffset* release_scroll_offset();
void set_allocated_scroll_offset(::cc::proto::ScrollOffset* scroll_offset);

// optional .cc.proto.Vector2dF scroll_snap = 36;
bool has_scroll_snap() const;
void clear_scroll_snap();
static const int kScrollSnapFieldNumber = 36;
const ::cc::proto::Vector2dF& scroll_snap() const;
::cc::proto::Vector2dF* mutable_scroll_snap();
::cc::proto::Vector2dF* release_scroll_snap();
void set_allocated_scroll_snap(::cc::proto::Vector2dF* scroll_snap);

// optional .cc.proto.Vector2dF source_offset = 37;
bool has_source_offset() const;
void clear_source_offset();
static const int kSourceOffsetFieldNumber = 37;
const ::cc::proto::Vector2dF& source_offset() const;
::cc::proto::Vector2dF* mutable_source_offset();
::cc::proto::Vector2dF* release_source_offset();
void set_allocated_source_offset(::cc::proto::Vector2dF* source_offset);

// optional .cc.proto.Vector2dF source_to_parent = 38;
bool has_source_to_parent() const;
void clear_source_to_parent();
static const int kSourceToParentFieldNumber = 38;
const ::cc::proto::Vector2dF& source_to_parent() const;
::cc::proto::Vector2dF* mutable_source_to_parent();
::cc::proto::Vector2dF* release_source_to_parent();
void set_allocated_source_to_parent(::cc::proto::Vector2dF* source_to_parent);

// optional int64 sorting_context_id = 39;
bool has_sorting_context_id() const;
void clear_sorting_context_id();
static const int kSortingContextIdFieldNumber = 39;
::google::protobuf::int64 sorting_context_id() const;
void set_sorting_context_id(::google::protobuf::int64 value);

// @@protoc_insertion_point(class_scope:cc.proto.TranformNodeData)
private:
inline void set_has_pre_local();
inline void clear_has_pre_local();
inline void set_has_local();
inline void clear_has_local();
inline void set_has_post_local();
inline void clear_has_post_local();
inline void set_has_to_parent();
inline void clear_has_to_parent();
inline void set_has_source_node_id();
inline void clear_has_source_node_id();
inline void set_has_needs_local_transform_update();
inline void clear_has_needs_local_transform_update();
inline void set_has_node_and_ancestors_are_animated_or_invertible();
inline void clear_has_node_and_ancestors_are_animated_or_invertible();
inline void set_has_is_invertible();
inline void clear_has_is_invertible();
inline void set_has_ancestors_are_invertible();
inline void clear_has_ancestors_are_invertible();
inline void set_has_has_potential_animation();
inline void clear_has_has_potential_animation();
inline void set_has_is_currently_animating();
inline void clear_has_is_currently_animating();
inline void set_has_to_screen_is_potentially_animated();
inline void clear_has_to_screen_is_potentially_animated();
inline void set_has_has_only_translation_animations();
inline void clear_has_has_only_translation_animations();
inline void set_has_flattens_inherited_transform();
inline void clear_has_flattens_inherited_transform();
inline void set_has_node_and_ancestors_are_flat();
inline void clear_has_node_and_ancestors_are_flat();
inline void set_has_node_and_ancestors_have_only_integer_translation();
inline void clear_has_node_and_ancestors_have_only_integer_translation();
inline void set_has_scrolls();
inline void clear_has_scrolls();
inline void set_has_needs_surface_contents_scale();
inline void clear_has_needs_surface_contents_scale();
inline void set_has_affected_by_inner_viewport_bounds_delta_x();
inline void clear_has_affected_by_inner_viewport_bounds_delta_x();
inline void set_has_affected_by_inner_viewport_bounds_delta_y();
inline void clear_has_affected_by_inner_viewport_bounds_delta_y();
inline void set_has_affected_by_outer_viewport_bounds_delta_x();
inline void clear_has_affected_by_outer_viewport_bounds_delta_x();
inline void set_has_affected_by_outer_viewport_bounds_delta_y();
inline void clear_has_affected_by_outer_viewport_bounds_delta_y();
inline void set_has_in_subtree_of_page_scale_layer();
inline void clear_has_in_subtree_of_page_scale_layer();
inline void set_has_transform_changed();
inline void clear_has_transform_changed();
inline void set_has_post_local_scale_factor();
inline void clear_has_post_local_scale_factor();
inline void set_has_surface_contents_scale();
inline void clear_has_surface_contents_scale();
inline void set_has_scroll_offset();
inline void clear_has_scroll_offset();
inline void set_has_scroll_snap();
inline void clear_has_scroll_snap();
inline void set_has_source_offset();
inline void clear_has_source_offset();
inline void set_has_source_to_parent();
inline void clear_has_source_to_parent();
inline void set_has_sorting_context_id();
inline void clear_has_sorting_context_id();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::cc::proto::Transform* pre_local_;
::cc::proto::Transform* local_;
::cc::proto::Transform* post_local_;
::cc::proto::Transform* to_parent_;
::google::protobuf::int64 source_node_id_;
bool needs_local_transform_update_;
bool node_and_ancestors_are_animated_or_invertible_;
bool is_invertible_;
bool ancestors_are_invertible_;
bool has_potential_animation_;
bool is_currently_animating_;
bool to_screen_is_potentially_animated_;
bool has_only_translation_animations_;
bool flattens_inherited_transform_;
bool node_and_ancestors_are_flat_;
bool node_and_ancestors_have_only_integer_translation_;
bool scrolls_;
bool needs_surface_contents_scale_;
bool affected_by_inner_viewport_bounds_delta_x_;
bool affected_by_inner_viewport_bounds_delta_y_;
bool affected_by_outer_viewport_bounds_delta_x_;
bool affected_by_outer_viewport_bounds_delta_y_;
bool in_subtree_of_page_scale_layer_;
bool transform_changed_;
float post_local_scale_factor_;
::cc::proto::Vector2dF* surface_contents_scale_;
::cc::proto::ScrollOffset* scroll_offset_;
::cc::proto::Vector2dF* scroll_snap_;
::cc::proto::Vector2dF* source_offset_;
::cc::proto::Vector2dF* source_to_parent_;
::google::protobuf::int64 sorting_context_id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
#endif
friend void protobuf_AssignDesc_property_5ftree_2eproto();
friend void protobuf_ShutdownFile_property_5ftree_2eproto();

void InitAsDefaultInstance();
static TranformNodeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT TransformCachedNodeData : public ::google::protobuf::MessageLite {
public:
TransformCachedNodeData();
virtual ~TransformCachedNodeData();

TransformCachedNodeData(const TransformCachedNodeData& from);

inline TransformCachedNodeData& operator=(const TransformCachedNodeData& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const TransformCachedNodeData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const TransformCachedNodeData* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(TransformCachedNodeData* other);

// implements Message ----------------------------------------------

inline TransformCachedNodeData* New() const { return New(NULL); }

TransformCachedNodeData* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const TransformCachedNodeData& from);
void MergeFrom(const TransformCachedNodeData& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(TransformCachedNodeData* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional .cc.proto.Transform from_target = 1;
bool has_from_target() const;
void clear_from_target();
static const int kFromTargetFieldNumber = 1;
const ::cc::proto::Transform& from_target() const;
::cc::proto::Transform* mutable_from_target();
::cc::proto::Transform* release_from_target();
void set_allocated_from_target(::cc::proto::Transform* from_target);

// optional .cc.proto.Transform to_target = 2;
bool has_to_target() const;
void clear_to_target();
static const int kToTargetFieldNumber = 2;
const ::cc::proto::Transform& to_target() const;
::cc::proto::Transform* mutable_to_target();
::cc::proto::Transform* release_to_target();
void set_allocated_to_target(::cc::proto::Transform* to_target);

// optional .cc.proto.Transform from_screen = 3;
bool has_from_screen() const;
void clear_from_screen();
static const int kFromScreenFieldNumber = 3;
const ::cc::proto::Transform& from_screen() const;
::cc::proto::Transform* mutable_from_screen();
::cc::proto::Transform* release_from_screen();
void set_allocated_from_screen(::cc::proto::Transform* from_screen);

// optional .cc.proto.Transform to_screen = 4;
bool has_to_screen() const;
void clear_to_screen();
static const int kToScreenFieldNumber = 4;
const ::cc::proto::Transform& to_screen() const;
::cc::proto::Transform* mutable_to_screen();
::cc::proto::Transform* release_to_screen();
void set_allocated_to_screen(::cc::proto::Transform* to_screen);

// optional int64 target_id = 5;
bool has_target_id() const;
void clear_target_id();
static const int kTargetIdFieldNumber = 5;
::google::protobuf::int64 target_id() const;
void set_target_id(::google::protobuf::int64 value);

// optional int64 content_target_id = 6;
bool has_content_target_id() const;
void clear_content_target_id();
static const int kContentTargetIdFieldNumber = 6;
::google::protobuf::int64 content_target_id() const;
void set_content_target_id(::google::protobuf::int64 value);

// @@protoc_insertion_point(class_scope:cc.proto.TransformCachedNodeData)
private:
inline void set_has_from_target();
inline void clear_has_from_target();
inline void set_has_to_target();
inline void clear_has_to_target();
inline void set_has_from_screen();
inline void clear_has_from_screen();
inline void set_has_to_screen();
inline void clear_has_to_screen();
inline void set_has_target_id();
inline void clear_has_target_id();
inline void set_has_content_target_id();
inline void clear_has_content_target_id();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::cc::proto::Transform* from_target_;
::cc::proto::Transform* to_target_;
::cc::proto::Transform* from_screen_;
::cc::proto::Transform* to_screen_;
::google::protobuf::int64 target_id_;
::google::protobuf::int64 content_target_id_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
#endif
friend void protobuf_AssignDesc_property_5ftree_2eproto();
friend void protobuf_ShutdownFile_property_5ftree_2eproto();

void InitAsDefaultInstance();
static TransformCachedNodeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT ClipNodeData : public ::google::protobuf::MessageLite {
public:
ClipNodeData();
virtual ~ClipNodeData();

ClipNodeData(const ClipNodeData& from);

inline ClipNodeData& operator=(const ClipNodeData& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const ClipNodeData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const ClipNodeData* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(ClipNodeData* other);

// implements Message ----------------------------------------------

inline ClipNodeData* New() const { return New(NULL); }

ClipNodeData* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const ClipNodeData& from);
void MergeFrom(const ClipNodeData& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ClipNodeData* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional .cc.proto.RectF clip = 1;
bool has_clip() const;
void clear_clip();
static const int kClipFieldNumber = 1;
const ::cc::proto::RectF& clip() const;
::cc::proto::RectF* mutable_clip();
::cc::proto::RectF* release_clip();
void set_allocated_clip(::cc::proto::RectF* clip);

// optional .cc.proto.RectF combined_clip_in_target_space = 2;
bool has_combined_clip_in_target_space() const;
void clear_combined_clip_in_target_space();
static const int kCombinedClipInTargetSpaceFieldNumber = 2;
const ::cc::proto::RectF& combined_clip_in_target_space() const;
::cc::proto::RectF* mutable_combined_clip_in_target_space();
::cc::proto::RectF* release_combined_clip_in_target_space();
void set_allocated_combined_clip_in_target_space(::cc::proto::RectF* combined_clip_in_target_space);

// optional .cc.proto.RectF clip_in_target_space = 3;
bool has_clip_in_target_space() const;
void clear_clip_in_target_space();
static const int kClipInTargetSpaceFieldNumber = 3;
const ::cc::proto::RectF& clip_in_target_space() const;
::cc::proto::RectF* mutable_clip_in_target_space();
::cc::proto::RectF* release_clip_in_target_space();
void set_allocated_clip_in_target_space(::cc::proto::RectF* clip_in_target_space);

// optional int64 transform_id = 4;
bool has_transform_id() const;
void clear_transform_id();
static const int kTransformIdFieldNumber = 4;
::google::protobuf::int64 transform_id() const;
void set_transform_id(::google::protobuf::int64 value);

// optional int64 target_transform_id = 5;
bool has_target_transform_id() const;
void clear_target_transform_id();
static const int kTargetTransformIdFieldNumber = 5;
::google::protobuf::int64 target_transform_id() const;
void set_target_transform_id(::google::protobuf::int64 value);

// optional int64 target_effect_id = 12;
bool has_target_effect_id() const;
void clear_target_effect_id();
static const int kTargetEffectIdFieldNumber = 12;
::google::protobuf::int64 target_effect_id() const;
void set_target_effect_id(::google::protobuf::int64 value);

// optional bool applies_local_clip = 6;
bool has_applies_local_clip() const;
void clear_applies_local_clip();
static const int kAppliesLocalClipFieldNumber = 6;
bool applies_local_clip() const;
void set_applies_local_clip(bool value);

// optional bool layer_clipping_uses_only_local_clip = 7;
bool has_layer_clipping_uses_only_local_clip() const;
void clear_layer_clipping_uses_only_local_clip();
static const int kLayerClippingUsesOnlyLocalClipFieldNumber = 7;
bool layer_clipping_uses_only_local_clip() const;
void set_layer_clipping_uses_only_local_clip(bool value);

// optional bool target_is_clipped = 8;
bool has_target_is_clipped() const;
void clear_target_is_clipped();
static const int kTargetIsClippedFieldNumber = 8;
bool target_is_clipped() const;
void set_target_is_clipped(bool value);

// optional bool layers_are_clipped = 9;
bool has_layers_are_clipped() const;
void clear_layers_are_clipped();
static const int kLayersAreClippedFieldNumber = 9;
bool layers_are_clipped() const;
void set_layers_are_clipped(bool value);

// optional bool layers_are_clipped_when_surfaces_disabled = 10;
bool has_layers_are_clipped_when_surfaces_disabled() const;
void clear_layers_are_clipped_when_surfaces_disabled();
static const int kLayersAreClippedWhenSurfacesDisabledFieldNumber = 10;
bool layers_are_clipped_when_surfaces_disabled() const;
void set_layers_are_clipped_when_surfaces_disabled(bool value);

// optional bool resets_clip = 11;
bool has_resets_clip() const;
void clear_resets_clip();
static const int kResetsClipFieldNumber = 11;
bool resets_clip() const;
void set_resets_clip(bool value);

// @@protoc_insertion_point(class_scope:cc.proto.ClipNodeData)
private:
inline void set_has_clip();
inline void clear_has_clip();
inline void set_has_combined_clip_in_target_space();
inline void clear_has_combined_clip_in_target_space();
inline void set_has_clip_in_target_space();
inline void clear_has_clip_in_target_space();
inline void set_has_transform_id();
inline void clear_has_transform_id();
inline void set_has_target_transform_id();
inline void clear_has_target_transform_id();
inline void set_has_target_effect_id();
inline void clear_has_target_effect_id();
inline void set_has_applies_local_clip();
inline void clear_has_applies_local_clip();
inline void set_has_layer_clipping_uses_only_local_clip();
inline void clear_has_layer_clipping_uses_only_local_clip();
inline void set_has_target_is_clipped();
inline void clear_has_target_is_clipped();
inline void set_has_layers_are_clipped();
inline void clear_has_layers_are_clipped();
inline void set_has_layers_are_clipped_when_surfaces_disabled();
inline void clear_has_layers_are_clipped_when_surfaces_disabled();
inline void set_has_resets_clip();
inline void clear_has_resets_clip();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::cc::proto::RectF* clip_;
::cc::proto::RectF* combined_clip_in_target_space_;
::cc::proto::RectF* clip_in_target_space_;
::google::protobuf::int64 transform_id_;
::google::protobuf::int64 target_transform_id_;
::google::protobuf::int64 target_effect_id_;
bool applies_local_clip_;
bool layer_clipping_uses_only_local_clip_;
bool target_is_clipped_;
bool layers_are_clipped_;
bool layers_are_clipped_when_surfaces_disabled_;
bool resets_clip_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
#endif
friend void protobuf_AssignDesc_property_5ftree_2eproto();
friend void protobuf_ShutdownFile_property_5ftree_2eproto();

void InitAsDefaultInstance();
static ClipNodeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT EffectNodeData : public ::google::protobuf::MessageLite {
public:
EffectNodeData();
virtual ~EffectNodeData();

EffectNodeData(const EffectNodeData& from);

inline EffectNodeData& operator=(const EffectNodeData& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const EffectNodeData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const EffectNodeData* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(EffectNodeData* other);

// implements Message ----------------------------------------------

inline EffectNodeData* New() const { return New(NULL); }

EffectNodeData* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const EffectNodeData& from);
void MergeFrom(const EffectNodeData& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(EffectNodeData* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional float opacity = 1;
bool has_opacity() const;
void clear_opacity();
static const int kOpacityFieldNumber = 1;
float opacity() const;
void set_opacity(float value);

// optional float screen_space_opacity = 2;
bool has_screen_space_opacity() const;
void clear_screen_space_opacity();
static const int kScreenSpaceOpacityFieldNumber = 2;
float screen_space_opacity() const;
void set_screen_space_opacity(float value);

// optional .cc.proto.SkXfermode.Mode blend_mode = 25;
bool has_blend_mode() const;
void clear_blend_mode();
static const int kBlendModeFieldNumber = 25;
::cc::proto::SkXfermode_Mode blend_mode() const;
void set_blend_mode(::cc::proto::SkXfermode_Mode value);

// optional .cc.proto.Size unscaled_mask_target_size = 26;
bool has_unscaled_mask_target_size() const;
void clear_unscaled_mask_target_size();
static const int kUnscaledMaskTargetSizeFieldNumber = 26;
const ::cc::proto::Size& unscaled_mask_target_size() const;
::cc::proto::Size* mutable_unscaled_mask_target_size();
::cc::proto::Size* release_unscaled_mask_target_size();
void set_allocated_unscaled_mask_target_size(::cc::proto::Size* unscaled_mask_target_size);

// optional bool has_render_surface = 3;
bool has_has_render_surface() const;
void clear_has_render_surface();
static const int kHasRenderSurfaceFieldNumber = 3;
bool has_render_surface() const;
void set_has_render_surface(bool value);

// optional bool has_copy_request = 4;
bool has_has_copy_request() const;
void clear_has_copy_request();
static const int kHasCopyRequestFieldNumber = 4;
bool has_copy_request() const;
void set_has_copy_request(bool value);

// optional bool hidden_by_backface_visibility = 14;
bool has_hidden_by_backface_visibility() const;
void clear_hidden_by_backface_visibility();
static const int kHiddenByBackfaceVisibilityFieldNumber = 14;
bool hidden_by_backface_visibility() const;
void set_hidden_by_backface_visibility(bool value);

// optional bool double_sided = 13;
bool has_double_sided() const;
void clear_double_sided();
static const int kDoubleSidedFieldNumber = 13;
bool double_sided() const;
void set_double_sided(bool value);

// optional bool is_drawn = 6;
bool has_is_drawn() const;
void clear_is_drawn();
static const int kIsDrawnFieldNumber = 6;
bool is_drawn() const;
void set_is_drawn(bool value);

// optional bool subtree_hidden = 15;
bool has_subtree_hidden() const;
void clear_subtree_hidden();
static const int kSubtreeHiddenFieldNumber = 15;
bool subtree_hidden() const;
void set_subtree_hidden(bool value);

// optional bool has_potential_filter_animation = 21;
bool has_has_potential_filter_animation() const;
void clear_has_potential_filter_animation();
static const int kHasPotentialFilterAnimationFieldNumber = 21;
bool has_potential_filter_animation() const;
void set_has_potential_filter_animation(bool value);

// optional bool has_potential_opacity_animation = 7;
bool has_has_potential_opacity_animation() const;
void clear_has_potential_opacity_animation();
static const int kHasPotentialOpacityAnimationFieldNumber = 7;
bool has_potential_opacity_animation() const;
void set_has_potential_opacity_animation(bool value);

// optional bool is_currently_animating_filter = 22;
bool has_is_currently_animating_filter() const;
void clear_is_currently_animating_filter();
static const int kIsCurrentlyAnimatingFilterFieldNumber = 22;
bool is_currently_animating_filter() const;
void set_is_currently_animating_filter(bool value);

// optional bool is_currently_animating_opacity = 16;
bool has_is_currently_animating_opacity() const;
void clear_is_currently_animating_opacity();
static const int kIsCurrentlyAnimatingOpacityFieldNumber = 16;
bool is_currently_animating_opacity() const;
void set_is_currently_animating_opacity(bool value);

// optional bool effect_changed = 11;
bool has_effect_changed() const;
void clear_effect_changed();
static const int kEffectChangedFieldNumber = 11;
bool effect_changed() const;
void set_effect_changed(bool value);

// optional int64 num_copy_requests_in_subtree = 8;
bool has_num_copy_requests_in_subtree() const;
void clear_num_copy_requests_in_subtree();
static const int kNumCopyRequestsInSubtreeFieldNumber = 8;
::google::protobuf::int64 num_copy_requests_in_subtree() const;
void set_num_copy_requests_in_subtree(::google::protobuf::int64 value);

// optional int64 transform_id = 9;
bool has_transform_id() const;
void clear_transform_id();
static const int kTransformIdFieldNumber = 9;
::google::protobuf::int64 transform_id() const;
void set_transform_id(::google::protobuf::int64 value);

// optional int64 clip_id = 10;
bool has_clip_id() const;
void clear_clip_id();
static const int kClipIdFieldNumber = 10;
::google::protobuf::int64 clip_id() const;
void set_clip_id(::google::protobuf::int64 value);

// optional int64 target_id = 12;
bool has_target_id() const;
void clear_target_id();
static const int kTargetIdFieldNumber = 12;
::google::protobuf::int64 target_id() const;
void set_target_id(::google::protobuf::int64 value);

// optional int64 mask_layer_id = 17;
bool has_mask_layer_id() const;
void clear_mask_layer_id();
static const int kMaskLayerIdFieldNumber = 17;
::google::protobuf::int64 mask_layer_id() const;
void set_mask_layer_id(::google::protobuf::int64 value);

// optional int64 replica_layer_id = 18;
bool has_replica_layer_id() const;
void clear_replica_layer_id();
static const int kReplicaLayerIdFieldNumber = 18;
::google::protobuf::int64 replica_layer_id() const;
void set_replica_layer_id(::google::protobuf::int64 value);

// optional int64 replica_mask_layer_id = 19;
bool has_replica_mask_layer_id() const;
void clear_replica_mask_layer_id();
static const int kReplicaMaskLayerIdFieldNumber = 19;
::google::protobuf::int64 replica_mask_layer_id() const;
void set_replica_mask_layer_id(::google::protobuf::int64 value);

// optional .cc.proto.Vector2dF surface_contents_scale = 20;
bool has_surface_contents_scale() const;
void clear_surface_contents_scale();
static const int kSurfaceContentsScaleFieldNumber = 20;
const ::cc::proto::Vector2dF& surface_contents_scale() const;
::cc::proto::Vector2dF* mutable_surface_contents_scale();
::cc::proto::Vector2dF* release_surface_contents_scale();
void set_allocated_surface_contents_scale(::cc::proto::Vector2dF* surface_contents_scale);

// @@protoc_insertion_point(class_scope:cc.proto.EffectNodeData)
private:
inline void set_has_opacity();
inline void clear_has_opacity();
inline void set_has_screen_space_opacity();
inline void clear_has_screen_space_opacity();
inline void set_has_blend_mode();
inline void clear_has_blend_mode();
inline void set_has_unscaled_mask_target_size();
inline void clear_has_unscaled_mask_target_size();
inline void set_has_has_render_surface();
inline void clear_has_has_render_surface();
inline void set_has_has_copy_request();
inline void clear_has_has_copy_request();
inline void set_has_hidden_by_backface_visibility();
inline void clear_has_hidden_by_backface_visibility();
inline void set_has_double_sided();
inline void clear_has_double_sided();
inline void set_has_is_drawn();
inline void clear_has_is_drawn();
inline void set_has_subtree_hidden();
inline void clear_has_subtree_hidden();
inline void set_has_has_potential_filter_animation();
inline void clear_has_has_potential_filter_animation();
inline void set_has_has_potential_opacity_animation();
inline void clear_has_has_potential_opacity_animation();
inline void set_has_is_currently_animating_filter();
inline void clear_has_is_currently_animating_filter();
inline void set_has_is_currently_animating_opacity();
inline void clear_has_is_currently_animating_opacity();
inline void set_has_effect_changed();
inline void clear_has_effect_changed();
inline void set_has_num_copy_requests_in_subtree();
inline void clear_has_num_copy_requests_in_subtree();
inline void set_has_transform_id();
inline void clear_has_transform_id();
inline void set_has_clip_id();
inline void clear_has_clip_id();
inline void set_has_target_id();
inline void clear_has_target_id();
inline void set_has_mask_layer_id();
inline void clear_has_mask_layer_id();
inline void set_has_replica_layer_id();
inline void clear_has_replica_layer_id();
inline void set_has_replica_mask_layer_id();
inline void clear_has_replica_mask_layer_id();
inline void set_has_surface_contents_scale();
inline void clear_has_surface_contents_scale();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
float opacity_;
float screen_space_opacity_;
::cc::proto::Size* unscaled_mask_target_size_;
int blend_mode_;
bool has_render_surface_;
bool has_copy_request_;
bool hidden_by_backface_visibility_;
bool double_sided_;
bool is_drawn_;
bool subtree_hidden_;
bool has_potential_filter_animation_;
bool has_potential_opacity_animation_;
bool is_currently_animating_filter_;
bool is_currently_animating_opacity_;
bool effect_changed_;
::google::protobuf::int64 num_copy_requests_in_subtree_;
::google::protobuf::int64 transform_id_;
::google::protobuf::int64 clip_id_;
::google::protobuf::int64 target_id_;
::google::protobuf::int64 mask_layer_id_;
::google::protobuf::int64 replica_layer_id_;
::google::protobuf::int64 replica_mask_layer_id_;
::cc::proto::Vector2dF* surface_contents_scale_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
#endif
friend void protobuf_AssignDesc_property_5ftree_2eproto();
friend void protobuf_ShutdownFile_property_5ftree_2eproto();

void InitAsDefaultInstance();
static EffectNodeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT ScrollNodeData : public ::google::protobuf::MessageLite {
public:
ScrollNodeData();
virtual ~ScrollNodeData();

ScrollNodeData(const ScrollNodeData& from);

inline ScrollNodeData& operator=(const ScrollNodeData& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const ScrollNodeData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const ScrollNodeData* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(ScrollNodeData* other);

// implements Message ----------------------------------------------

inline ScrollNodeData* New() const { return New(NULL); }

ScrollNodeData* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const ScrollNodeData& from);
void MergeFrom(const ScrollNodeData& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ScrollNodeData* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional bool scrollable = 1;
bool has_scrollable() const;
void clear_scrollable();
static const int kScrollableFieldNumber = 1;
bool scrollable() const;
void set_scrollable(bool value);

// optional int32 main_thread_scrolling_reasons = 2;
bool has_main_thread_scrolling_reasons() const;
void clear_main_thread_scrolling_reasons();
static const int kMainThreadScrollingReasonsFieldNumber = 2;
::google::protobuf::int32 main_thread_scrolling_reasons() const;
void set_main_thread_scrolling_reasons(::google::protobuf::int32 value);

// optional bool contains_non_fast_scrollable_region = 3;
bool has_contains_non_fast_scrollable_region() const;
void clear_contains_non_fast_scrollable_region();
static const int kContainsNonFastScrollableRegionFieldNumber = 3;
bool contains_non_fast_scrollable_region() const;
void set_contains_non_fast_scrollable_region(bool value);

// optional .cc.proto.Size scroll_clip_layer_bounds = 4;
bool has_scroll_clip_layer_bounds() const;
void clear_scroll_clip_layer_bounds();
static const int kScrollClipLayerBoundsFieldNumber = 4;
const ::cc::proto::Size& scroll_clip_layer_bounds() const;
::cc::proto::Size* mutable_scroll_clip_layer_bounds();
::cc::proto::Size* release_scroll_clip_layer_bounds();
void set_allocated_scroll_clip_layer_bounds(::cc::proto::Size* scroll_clip_layer_bounds);

// optional .cc.proto.Size bounds = 5;
bool has_bounds() const;
void clear_bounds();
static const int kBoundsFieldNumber = 5;
const ::cc::proto::Size& bounds() const;
::cc::proto::Size* mutable_bounds();
::cc::proto::Size* release_bounds();
void set_allocated_bounds(::cc::proto::Size* bounds);

// optional bool max_scroll_offset_affected_by_page_scale = 6;
bool has_max_scroll_offset_affected_by_page_scale() const;
void clear_max_scroll_offset_affected_by_page_scale();
static const int kMaxScrollOffsetAffectedByPageScaleFieldNumber = 6;
bool max_scroll_offset_affected_by_page_scale() const;
void set_max_scroll_offset_affected_by_page_scale(bool value);

// optional bool is_inner_viewport_scroll_layer = 7;
bool has_is_inner_viewport_scroll_layer() const;
void clear_is_inner_viewport_scroll_layer();
static const int kIsInnerViewportScrollLayerFieldNumber = 7;
bool is_inner_viewport_scroll_layer() const;
void set_is_inner_viewport_scroll_layer(bool value);

// optional bool is_outer_viewport_scroll_layer = 8;
bool has_is_outer_viewport_scroll_layer() const;
void clear_is_outer_viewport_scroll_layer();
static const int kIsOuterViewportScrollLayerFieldNumber = 8;
bool is_outer_viewport_scroll_layer() const;
void set_is_outer_viewport_scroll_layer(bool value);

// optional .cc.proto.Vector2dF offset_to_transform_parent = 9;
bool has_offset_to_transform_parent() const;
void clear_offset_to_transform_parent();
static const int kOffsetToTransformParentFieldNumber = 9;
const ::cc::proto::Vector2dF& offset_to_transform_parent() const;
::cc::proto::Vector2dF* mutable_offset_to_transform_parent();
::cc::proto::Vector2dF* release_offset_to_transform_parent();
void set_allocated_offset_to_transform_parent(::cc::proto::Vector2dF* offset_to_transform_parent);

// optional bool should_flatten = 10;
bool has_should_flatten() const;
void clear_should_flatten();
static const int kShouldFlattenFieldNumber = 10;
bool should_flatten() const;
void set_should_flatten(bool value);

// optional bool user_scrollable_horizontal = 13;
bool has_user_scrollable_horizontal() const;
void clear_user_scrollable_horizontal();
static const int kUserScrollableHorizontalFieldNumber = 13;
bool user_scrollable_horizontal() const;
void set_user_scrollable_horizontal(bool value);

// optional bool user_scrollable_vertical = 14;
bool has_user_scrollable_vertical() const;
void clear_user_scrollable_vertical();
static const int kUserScrollableVerticalFieldNumber = 14;
bool user_scrollable_vertical() const;
void set_user_scrollable_vertical(bool value);

// optional .cc.proto.ElementId element_id = 15;
bool has_element_id() const;
void clear_element_id();
static const int kElementIdFieldNumber = 15;
const ::cc::proto::ElementId& element_id() const;
::cc::proto::ElementId* mutable_element_id();
::cc::proto::ElementId* release_element_id();
void set_allocated_element_id(::cc::proto::ElementId* element_id);

// optional int64 transform_id = 11;
bool has_transform_id() const;
void clear_transform_id();
static const int kTransformIdFieldNumber = 11;
::google::protobuf::int64 transform_id() const;
void set_transform_id(::google::protobuf::int64 value);

// @@protoc_insertion_point(class_scope:cc.proto.ScrollNodeData)
private:
inline void set_has_scrollable();
inline void clear_has_scrollable();
inline void set_has_main_thread_scrolling_reasons();
inline void clear_has_main_thread_scrolling_reasons();
inline void set_has_contains_non_fast_scrollable_region();
inline void clear_has_contains_non_fast_scrollable_region();
inline void set_has_scroll_clip_layer_bounds();
inline void clear_has_scroll_clip_layer_bounds();
inline void set_has_bounds();
inline void clear_has_bounds();
inline void set_has_max_scroll_offset_affected_by_page_scale();
inline void clear_has_max_scroll_offset_affected_by_page_scale();
inline void set_has_is_inner_viewport_scroll_layer();
inline void clear_has_is_inner_viewport_scroll_layer();
inline void set_has_is_outer_viewport_scroll_layer();
inline void clear_has_is_outer_viewport_scroll_layer();
inline void set_has_offset_to_transform_parent();
inline void clear_has_offset_to_transform_parent();
inline void set_has_should_flatten();
inline void clear_has_should_flatten();
inline void set_has_user_scrollable_horizontal();
inline void clear_has_user_scrollable_horizontal();
inline void set_has_user_scrollable_vertical();
inline void clear_has_user_scrollable_vertical();
inline void set_has_element_id();
inline void clear_has_element_id();
inline void set_has_transform_id();
inline void clear_has_transform_id();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::google::protobuf::int32 main_thread_scrolling_reasons_;
bool scrollable_;
bool contains_non_fast_scrollable_region_;
bool max_scroll_offset_affected_by_page_scale_;
bool is_inner_viewport_scroll_layer_;
::cc::proto::Size* scroll_clip_layer_bounds_;
::cc::proto::Size* bounds_;
::cc::proto::Vector2dF* offset_to_transform_parent_;
::cc::proto::ElementId* element_id_;
::google::protobuf::int64 transform_id_;
bool is_outer_viewport_scroll_layer_;
bool should_flatten_;
bool user_scrollable_horizontal_;
bool user_scrollable_vertical_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
#endif
friend void protobuf_AssignDesc_property_5ftree_2eproto();
friend void protobuf_ShutdownFile_property_5ftree_2eproto();

void InitAsDefaultInstance();
static ScrollNodeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT TreeNode : public ::google::protobuf::MessageLite {
public:
TreeNode();
virtual ~TreeNode();

TreeNode(const TreeNode& from);

inline TreeNode& operator=(const TreeNode& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const TreeNode& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const TreeNode* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(TreeNode* other);

// implements Message ----------------------------------------------

inline TreeNode* New() const { return New(NULL); }

TreeNode* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const TreeNode& from);
void MergeFrom(const TreeNode& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(TreeNode* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional int64 id = 1;
bool has_id() const;
void clear_id();
static const int kIdFieldNumber = 1;
::google::protobuf::int64 id() const;
void set_id(::google::protobuf::int64 value);

// optional int64 parent_id = 2;
bool has_parent_id() const;
void clear_parent_id();
static const int kParentIdFieldNumber = 2;
::google::protobuf::int64 parent_id() const;
void set_parent_id(::google::protobuf::int64 value);

// optional int64 owner_id = 3;
bool has_owner_id() const;
void clear_owner_id();
static const int kOwnerIdFieldNumber = 3;
::google::protobuf::int64 owner_id() const;
void set_owner_id(::google::protobuf::int64 value);

// optional .cc.proto.TranformNodeData transform_node_data = 1000;
bool has_transform_node_data() const;
void clear_transform_node_data();
static const int kTransformNodeDataFieldNumber = 1000;
const ::cc::proto::TranformNodeData& transform_node_data() const;
::cc::proto::TranformNodeData* mutable_transform_node_data();
::cc::proto::TranformNodeData* release_transform_node_data();
void set_allocated_transform_node_data(::cc::proto::TranformNodeData* transform_node_data);

// optional .cc.proto.ClipNodeData clip_node_data = 1001;
bool has_clip_node_data() const;
void clear_clip_node_data();
static const int kClipNodeDataFieldNumber = 1001;
const ::cc::proto::ClipNodeData& clip_node_data() const;
::cc::proto::ClipNodeData* mutable_clip_node_data();
::cc::proto::ClipNodeData* release_clip_node_data();
void set_allocated_clip_node_data(::cc::proto::ClipNodeData* clip_node_data);

// optional .cc.proto.EffectNodeData effect_node_data = 1002;
bool has_effect_node_data() const;
void clear_effect_node_data();
static const int kEffectNodeDataFieldNumber = 1002;
const ::cc::proto::EffectNodeData& effect_node_data() const;
::cc::proto::EffectNodeData* mutable_effect_node_data();
::cc::proto::EffectNodeData* release_effect_node_data();
void set_allocated_effect_node_data(::cc::proto::EffectNodeData* effect_node_data);

// optional .cc.proto.ScrollNodeData scroll_node_data = 1003;
bool has_scroll_node_data() const;
void clear_scroll_node_data();
static const int kScrollNodeDataFieldNumber = 1003;
const ::cc::proto::ScrollNodeData& scroll_node_data() const;
::cc::proto::ScrollNodeData* mutable_scroll_node_data();
::cc::proto::ScrollNodeData* release_scroll_node_data();
void set_allocated_scroll_node_data(::cc::proto::ScrollNodeData* scroll_node_data);

// @@protoc_insertion_point(class_scope:cc.proto.TreeNode)
private:
inline void set_has_id();
inline void clear_has_id();
inline void set_has_parent_id();
inline void clear_has_parent_id();
inline void set_has_owner_id();
inline void clear_has_owner_id();
inline void set_has_transform_node_data();
inline void clear_has_transform_node_data();
inline void set_has_clip_node_data();
inline void clear_has_clip_node_data();
inline void set_has_effect_node_data();
inline void clear_has_effect_node_data();
inline void set_has_scroll_node_data();
inline void clear_has_scroll_node_data();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::google::protobuf::int64 id_;
::google::protobuf::int64 parent_id_;
::google::protobuf::int64 owner_id_;
::cc::proto::TranformNodeData* transform_node_data_;
::cc::proto::ClipNodeData* clip_node_data_;
::cc::proto::EffectNodeData* effect_node_data_;
::cc::proto::ScrollNodeData* scroll_node_data_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
#endif
friend void protobuf_AssignDesc_property_5ftree_2eproto();
friend void protobuf_ShutdownFile_property_5ftree_2eproto();

void InitAsDefaultInstance();
static TreeNode* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT PropertyTree : public ::google::protobuf::MessageLite {
public:
PropertyTree();
virtual ~PropertyTree();

PropertyTree(const PropertyTree& from);

inline PropertyTree& operator=(const PropertyTree& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const PropertyTree& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const PropertyTree* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(PropertyTree* other);

// implements Message ----------------------------------------------

inline PropertyTree* New() const { return New(NULL); }

PropertyTree* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const PropertyTree& from);
void MergeFrom(const PropertyTree& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PropertyTree* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

typedef PropertyTree_PropertyType PropertyType;
static const PropertyType Transform =
PropertyTree_PropertyType_Transform;
static const PropertyType Clip =
PropertyTree_PropertyType_Clip;
static const PropertyType Effect =
PropertyTree_PropertyType_Effect;
static const PropertyType Scroll =
PropertyTree_PropertyType_Scroll;
static inline bool PropertyType_IsValid(int value) {
return PropertyTree_PropertyType_IsValid(value);
}
static const PropertyType PropertyType_MIN =
PropertyTree_PropertyType_PropertyType_MIN;
static const PropertyType PropertyType_MAX =
PropertyTree_PropertyType_PropertyType_MAX;
static const int PropertyType_ARRAYSIZE =
PropertyTree_PropertyType_PropertyType_ARRAYSIZE;

// accessors -------------------------------------------------------

// optional .cc.proto.PropertyTree.PropertyType property_type = 1;
bool has_property_type() const;
void clear_property_type();
static const int kPropertyTypeFieldNumber = 1;
::cc::proto::PropertyTree_PropertyType property_type() const;
void set_property_type(::cc::proto::PropertyTree_PropertyType value);

// repeated .cc.proto.TreeNode nodes = 2;
int nodes_size() const;
void clear_nodes();
static const int kNodesFieldNumber = 2;
const ::cc::proto::TreeNode& nodes(int index) const;
::cc::proto::TreeNode* mutable_nodes(int index);
::cc::proto::TreeNode* add_nodes();
::google::protobuf::RepeatedPtrField< ::cc::proto::TreeNode >*
mutable_nodes();
const ::google::protobuf::RepeatedPtrField< ::cc::proto::TreeNode >&
nodes() const;

// optional bool needs_update = 3;
bool has_needs_update() const;
void clear_needs_update();
static const int kNeedsUpdateFieldNumber = 3;
bool needs_update() const;
void set_needs_update(bool value);

// optional .cc.proto.TransformTreeData transform_tree_data = 1000;
bool has_transform_tree_data() const;
void clear_transform_tree_data();
static const int kTransformTreeDataFieldNumber = 1000;
const ::cc::proto::TransformTreeData& transform_tree_data() const;
::cc::proto::TransformTreeData* mutable_transform_tree_data();
::cc::proto::TransformTreeData* release_transform_tree_data();
void set_allocated_transform_tree_data(::cc::proto::TransformTreeData* transform_tree_data);

// optional .cc.proto.ScrollTreeData scroll_tree_data = 1001;
bool has_scroll_tree_data() const;
void clear_scroll_tree_data();
static const int kScrollTreeDataFieldNumber = 1001;
const ::cc::proto::ScrollTreeData& scroll_tree_data() const;
::cc::proto::ScrollTreeData* mutable_scroll_tree_data();
::cc::proto::ScrollTreeData* release_scroll_tree_data();
void set_allocated_scroll_tree_data(::cc::proto::ScrollTreeData* scroll_tree_data);

// optional .cc.proto.EffectTreeData effect_tree_data = 1002;
bool has_effect_tree_data() const;
void clear_effect_tree_data();
static const int kEffectTreeDataFieldNumber = 1002;
const ::cc::proto::EffectTreeData& effect_tree_data() const;
::cc::proto::EffectTreeData* mutable_effect_tree_data();
::cc::proto::EffectTreeData* release_effect_tree_data();
void set_allocated_effect_tree_data(::cc::proto::EffectTreeData* effect_tree_data);

// @@protoc_insertion_point(class_scope:cc.proto.PropertyTree)
private:
inline void set_has_property_type();
inline void clear_has_property_type();
inline void set_has_needs_update();
inline void clear_has_needs_update();
inline void set_has_transform_tree_data();
inline void clear_has_transform_tree_data();
inline void set_has_scroll_tree_data();
inline void clear_has_scroll_tree_data();
inline void set_has_effect_tree_data();
inline void clear_has_effect_tree_data();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::google::protobuf::RepeatedPtrField< ::cc::proto::TreeNode > nodes_;
int property_type_;
bool needs_update_;
::cc::proto::TransformTreeData* transform_tree_data_;
::cc::proto::ScrollTreeData* scroll_tree_data_;
::cc::proto::EffectTreeData* effect_tree_data_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
#endif
friend void protobuf_AssignDesc_property_5ftree_2eproto();
friend void protobuf_ShutdownFile_property_5ftree_2eproto();

void InitAsDefaultInstance();
static PropertyTree* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT ScrollOffsetMapEntry : public ::google::protobuf::MessageLite {
public:
ScrollOffsetMapEntry();
virtual ~ScrollOffsetMapEntry();

ScrollOffsetMapEntry(const ScrollOffsetMapEntry& from);

inline ScrollOffsetMapEntry& operator=(const ScrollOffsetMapEntry& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const ScrollOffsetMapEntry& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const ScrollOffsetMapEntry* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(ScrollOffsetMapEntry* other);

// implements Message ----------------------------------------------

inline ScrollOffsetMapEntry* New() const { return New(NULL); }

ScrollOffsetMapEntry* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const ScrollOffsetMapEntry& from);
void MergeFrom(const ScrollOffsetMapEntry& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ScrollOffsetMapEntry* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// required int64 layer_id = 1;
bool has_layer_id() const;
void clear_layer_id();
static const int kLayerIdFieldNumber = 1;
::google::protobuf::int64 layer_id() const;
void set_layer_id(::google::protobuf::int64 value);

// optional .cc.proto.SyncedProperty scroll_offset = 2;
bool has_scroll_offset() const;
void clear_scroll_offset();
static const int kScrollOffsetFieldNumber = 2;
const ::cc::proto::SyncedProperty& scroll_offset() const;
::cc::proto::SyncedProperty* mutable_scroll_offset();
::cc::proto::SyncedProperty* release_scroll_offset();
void set_allocated_scroll_offset(::cc::proto::SyncedProperty* scroll_offset);

// @@protoc_insertion_point(class_scope:cc.proto.ScrollOffsetMapEntry)
private:
inline void set_has_layer_id();
inline void clear_has_layer_id();
inline void set_has_scroll_offset();
inline void clear_has_scroll_offset();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::google::protobuf::int64 layer_id_;
::cc::proto::SyncedProperty* scroll_offset_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
#endif
friend void protobuf_AssignDesc_property_5ftree_2eproto();
friend void protobuf_ShutdownFile_property_5ftree_2eproto();

void InitAsDefaultInstance();
static ScrollOffsetMapEntry* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT ScrollTreeData : public ::google::protobuf::MessageLite {
public:
ScrollTreeData();
virtual ~ScrollTreeData();

ScrollTreeData(const ScrollTreeData& from);

inline ScrollTreeData& operator=(const ScrollTreeData& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const ScrollTreeData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const ScrollTreeData* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(ScrollTreeData* other);

// implements Message ----------------------------------------------

inline ScrollTreeData* New() const { return New(NULL); }

ScrollTreeData* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const ScrollTreeData& from);
void MergeFrom(const ScrollTreeData& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ScrollTreeData* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional int64 currently_scrolling_node_id = 1;
bool has_currently_scrolling_node_id() const;
void clear_currently_scrolling_node_id();
static const int kCurrentlyScrollingNodeIdFieldNumber = 1;
::google::protobuf::int64 currently_scrolling_node_id() const;
void set_currently_scrolling_node_id(::google::protobuf::int64 value);

// repeated .cc.proto.ScrollOffsetMapEntry layer_id_to_scroll_offset_map = 2;
int layer_id_to_scroll_offset_map_size() const;
void clear_layer_id_to_scroll_offset_map();
static const int kLayerIdToScrollOffsetMapFieldNumber = 2;
const ::cc::proto::ScrollOffsetMapEntry& layer_id_to_scroll_offset_map(int index) const;
::cc::proto::ScrollOffsetMapEntry* mutable_layer_id_to_scroll_offset_map(int index);
::cc::proto::ScrollOffsetMapEntry* add_layer_id_to_scroll_offset_map();
::google::protobuf::RepeatedPtrField< ::cc::proto::ScrollOffsetMapEntry >*
mutable_layer_id_to_scroll_offset_map();
const ::google::protobuf::RepeatedPtrField< ::cc::proto::ScrollOffsetMapEntry >&
layer_id_to_scroll_offset_map() const;

// @@protoc_insertion_point(class_scope:cc.proto.ScrollTreeData)
private:
inline void set_has_currently_scrolling_node_id();
inline void clear_has_currently_scrolling_node_id();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::google::protobuf::int64 currently_scrolling_node_id_;
::google::protobuf::RepeatedPtrField< ::cc::proto::ScrollOffsetMapEntry > layer_id_to_scroll_offset_map_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
#endif
friend void protobuf_AssignDesc_property_5ftree_2eproto();
friend void protobuf_ShutdownFile_property_5ftree_2eproto();

void InitAsDefaultInstance();
static ScrollTreeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT TransformTreeData : public ::google::protobuf::MessageLite {
public:
TransformTreeData();
virtual ~TransformTreeData();

TransformTreeData(const TransformTreeData& from);

inline TransformTreeData& operator=(const TransformTreeData& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const TransformTreeData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const TransformTreeData* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(TransformTreeData* other);

// implements Message ----------------------------------------------

inline TransformTreeData* New() const { return New(NULL); }

TransformTreeData* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const TransformTreeData& from);
void MergeFrom(const TransformTreeData& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(TransformTreeData* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional bool source_to_parent_updates_allowed = 1;
bool has_source_to_parent_updates_allowed() const;
void clear_source_to_parent_updates_allowed();
static const int kSourceToParentUpdatesAllowedFieldNumber = 1;
bool source_to_parent_updates_allowed() const;
void set_source_to_parent_updates_allowed(bool value);

// optional float page_scale_factor = 2;
bool has_page_scale_factor() const;
void clear_page_scale_factor();
static const int kPageScaleFactorFieldNumber = 2;
float page_scale_factor() const;
void set_page_scale_factor(float value);

// optional float device_scale_factor = 3;
bool has_device_scale_factor() const;
void clear_device_scale_factor();
static const int kDeviceScaleFactorFieldNumber = 3;
float device_scale_factor() const;
void set_device_scale_factor(float value);

// optional float device_transform_scale_factor = 4;
bool has_device_transform_scale_factor() const;
void clear_device_transform_scale_factor();
static const int kDeviceTransformScaleFactorFieldNumber = 4;
float device_transform_scale_factor() const;
void set_device_transform_scale_factor(float value);

// repeated int64 nodes_affected_by_inner_viewport_bounds_delta = 7 [packed = true];
int nodes_affected_by_inner_viewport_bounds_delta_size() const;
void clear_nodes_affected_by_inner_viewport_bounds_delta();
static const int kNodesAffectedByInnerViewportBoundsDeltaFieldNumber = 7;
::google::protobuf::int64 nodes_affected_by_inner_viewport_bounds_delta(int index) const;
void set_nodes_affected_by_inner_viewport_bounds_delta(int index, ::google::protobuf::int64 value);
void add_nodes_affected_by_inner_viewport_bounds_delta(::google::protobuf::int64 value);
const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
nodes_affected_by_inner_viewport_bounds_delta() const;
::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
mutable_nodes_affected_by_inner_viewport_bounds_delta();

// repeated int64 nodes_affected_by_outer_viewport_bounds_delta = 8 [packed = true];
int nodes_affected_by_outer_viewport_bounds_delta_size() const;
void clear_nodes_affected_by_outer_viewport_bounds_delta();
static const int kNodesAffectedByOuterViewportBoundsDeltaFieldNumber = 8;
::google::protobuf::int64 nodes_affected_by_outer_viewport_bounds_delta(int index) const;
void set_nodes_affected_by_outer_viewport_bounds_delta(int index, ::google::protobuf::int64 value);
void add_nodes_affected_by_outer_viewport_bounds_delta(::google::protobuf::int64 value);
const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
nodes_affected_by_outer_viewport_bounds_delta() const;
::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
mutable_nodes_affected_by_outer_viewport_bounds_delta();

// repeated .cc.proto.TransformCachedNodeData cached_data = 9;
int cached_data_size() const;
void clear_cached_data();
static const int kCachedDataFieldNumber = 9;
const ::cc::proto::TransformCachedNodeData& cached_data(int index) const;
::cc::proto::TransformCachedNodeData* mutable_cached_data(int index);
::cc::proto::TransformCachedNodeData* add_cached_data();
::google::protobuf::RepeatedPtrField< ::cc::proto::TransformCachedNodeData >*
mutable_cached_data();
const ::google::protobuf::RepeatedPtrField< ::cc::proto::TransformCachedNodeData >&
cached_data() const;

// @@protoc_insertion_point(class_scope:cc.proto.TransformTreeData)
private:
inline void set_has_source_to_parent_updates_allowed();
inline void clear_has_source_to_parent_updates_allowed();
inline void set_has_page_scale_factor();
inline void clear_has_page_scale_factor();
inline void set_has_device_scale_factor();
inline void clear_has_device_scale_factor();
inline void set_has_device_transform_scale_factor();
inline void clear_has_device_transform_scale_factor();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
bool source_to_parent_updates_allowed_;
float page_scale_factor_;
float device_scale_factor_;
float device_transform_scale_factor_;
::google::protobuf::RepeatedField< ::google::protobuf::int64 > nodes_affected_by_inner_viewport_bounds_delta_;
mutable int _nodes_affected_by_inner_viewport_bounds_delta_cached_byte_size_;
::google::protobuf::RepeatedField< ::google::protobuf::int64 > nodes_affected_by_outer_viewport_bounds_delta_;
mutable int _nodes_affected_by_outer_viewport_bounds_delta_cached_byte_size_;
::google::protobuf::RepeatedPtrField< ::cc::proto::TransformCachedNodeData > cached_data_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
#endif
friend void protobuf_AssignDesc_property_5ftree_2eproto();
friend void protobuf_ShutdownFile_property_5ftree_2eproto();

void InitAsDefaultInstance();
static TransformTreeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT EffectTreeData : public ::google::protobuf::MessageLite {
public:
EffectTreeData();
virtual ~EffectTreeData();

EffectTreeData(const EffectTreeData& from);

inline EffectTreeData& operator=(const EffectTreeData& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const EffectTreeData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const EffectTreeData* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(EffectTreeData* other);

// implements Message ----------------------------------------------

inline EffectTreeData* New() const { return New(NULL); }

EffectTreeData* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const EffectTreeData& from);
void MergeFrom(const EffectTreeData& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(EffectTreeData* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// repeated int64 mask_replica_layer_ids = 1 [packed = true];
int mask_replica_layer_ids_size() const;
void clear_mask_replica_layer_ids();
static const int kMaskReplicaLayerIdsFieldNumber = 1;
::google::protobuf::int64 mask_replica_layer_ids(int index) const;
void set_mask_replica_layer_ids(int index, ::google::protobuf::int64 value);
void add_mask_replica_layer_ids(::google::protobuf::int64 value);
const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
mask_replica_layer_ids() const;
::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
mutable_mask_replica_layer_ids();

// @@protoc_insertion_point(class_scope:cc.proto.EffectTreeData)
private:

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::google::protobuf::RepeatedField< ::google::protobuf::int64 > mask_replica_layer_ids_;
mutable int _mask_replica_layer_ids_cached_byte_size_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
#endif
friend void protobuf_AssignDesc_property_5ftree_2eproto();
friend void protobuf_ShutdownFile_property_5ftree_2eproto();

void InitAsDefaultInstance();
static EffectTreeData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT PropertyTrees : public ::google::protobuf::MessageLite {
public:
PropertyTrees();
virtual ~PropertyTrees();

PropertyTrees(const PropertyTrees& from);

inline PropertyTrees& operator=(const PropertyTrees& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const PropertyTrees& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const PropertyTrees* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(PropertyTrees* other);

// implements Message ----------------------------------------------

inline PropertyTrees* New() const { return New(NULL); }

PropertyTrees* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const PropertyTrees& from);
void MergeFrom(const PropertyTrees& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(PropertyTrees* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional .cc.proto.PropertyTree transform_tree = 1;
bool has_transform_tree() const;
void clear_transform_tree();
static const int kTransformTreeFieldNumber = 1;
const ::cc::proto::PropertyTree& transform_tree() const;
::cc::proto::PropertyTree* mutable_transform_tree();
::cc::proto::PropertyTree* release_transform_tree();
void set_allocated_transform_tree(::cc::proto::PropertyTree* transform_tree);

// optional .cc.proto.PropertyTree effect_tree = 2;
bool has_effect_tree() const;
void clear_effect_tree();
static const int kEffectTreeFieldNumber = 2;
const ::cc::proto::PropertyTree& effect_tree() const;
::cc::proto::PropertyTree* mutable_effect_tree();
::cc::proto::PropertyTree* release_effect_tree();
void set_allocated_effect_tree(::cc::proto::PropertyTree* effect_tree);

// optional .cc.proto.PropertyTree clip_tree = 3;
bool has_clip_tree() const;
void clear_clip_tree();
static const int kClipTreeFieldNumber = 3;
const ::cc::proto::PropertyTree& clip_tree() const;
::cc::proto::PropertyTree* mutable_clip_tree();
::cc::proto::PropertyTree* release_clip_tree();
void set_allocated_clip_tree(::cc::proto::PropertyTree* clip_tree);

// optional .cc.proto.PropertyTree scroll_tree = 7;
bool has_scroll_tree() const;
void clear_scroll_tree();
static const int kScrollTreeFieldNumber = 7;
const ::cc::proto::PropertyTree& scroll_tree() const;
::cc::proto::PropertyTree* mutable_scroll_tree();
::cc::proto::PropertyTree* release_scroll_tree();
void set_allocated_scroll_tree(::cc::proto::PropertyTree* scroll_tree);

// optional bool needs_rebuild = 4;
bool has_needs_rebuild() const;
void clear_needs_rebuild();
static const int kNeedsRebuildFieldNumber = 4;
bool needs_rebuild() const;
void set_needs_rebuild(bool value);

// optional bool non_root_surfaces_enabled = 5;
bool has_non_root_surfaces_enabled() const;
void clear_non_root_surfaces_enabled();
static const int kNonRootSurfacesEnabledFieldNumber = 5;
bool non_root_surfaces_enabled() const;
void set_non_root_surfaces_enabled(bool value);

// optional bool changed = 11;
bool has_changed() const;
void clear_changed();
static const int kChangedFieldNumber = 11;
bool changed() const;
void set_changed(bool value);

// optional bool full_tree_damaged = 12;
bool has_full_tree_damaged() const;
void clear_full_tree_damaged();
static const int kFullTreeDamagedFieldNumber = 12;
bool full_tree_damaged() const;
void set_full_tree_damaged(bool value);

// optional int64 sequence_number = 6;
bool has_sequence_number() const;
void clear_sequence_number();
static const int kSequenceNumberFieldNumber = 6;
::google::protobuf::int64 sequence_number() const;
void set_sequence_number(::google::protobuf::int64 value);

// optional bool is_main_thread = 13;
bool has_is_main_thread() const;
void clear_is_main_thread();
static const int kIsMainThreadFieldNumber = 13;
bool is_main_thread() const;
void set_is_main_thread(bool value);

// optional bool is_active = 14;
bool has_is_active() const;
void clear_is_active();
static const int kIsActiveFieldNumber = 14;
bool is_active() const;
void set_is_active(bool value);

// optional bool verify_transform_tree_calculations = 16;
bool has_verify_transform_tree_calculations() const;
void clear_verify_transform_tree_calculations();
static const int kVerifyTransformTreeCalculationsFieldNumber = 16;
bool verify_transform_tree_calculations() const;
void set_verify_transform_tree_calculations(bool value);

// optional .cc.proto.Vector2dF inner_viewport_container_bounds_delta = 8;
bool has_inner_viewport_container_bounds_delta() const;
void clear_inner_viewport_container_bounds_delta();
static const int kInnerViewportContainerBoundsDeltaFieldNumber = 8;
const ::cc::proto::Vector2dF& inner_viewport_container_bounds_delta() const;
::cc::proto::Vector2dF* mutable_inner_viewport_container_bounds_delta();
::cc::proto::Vector2dF* release_inner_viewport_container_bounds_delta();
void set_allocated_inner_viewport_container_bounds_delta(::cc::proto::Vector2dF* inner_viewport_container_bounds_delta);

// optional .cc.proto.Vector2dF outer_viewport_container_bounds_delta = 9;
bool has_outer_viewport_container_bounds_delta() const;
void clear_outer_viewport_container_bounds_delta();
static const int kOuterViewportContainerBoundsDeltaFieldNumber = 9;
const ::cc::proto::Vector2dF& outer_viewport_container_bounds_delta() const;
::cc::proto::Vector2dF* mutable_outer_viewport_container_bounds_delta();
::cc::proto::Vector2dF* release_outer_viewport_container_bounds_delta();
void set_allocated_outer_viewport_container_bounds_delta(::cc::proto::Vector2dF* outer_viewport_container_bounds_delta);

// optional .cc.proto.Vector2dF inner_viewport_scroll_bounds_delta = 10;
bool has_inner_viewport_scroll_bounds_delta() const;
void clear_inner_viewport_scroll_bounds_delta();
static const int kInnerViewportScrollBoundsDeltaFieldNumber = 10;
const ::cc::proto::Vector2dF& inner_viewport_scroll_bounds_delta() const;
::cc::proto::Vector2dF* mutable_inner_viewport_scroll_bounds_delta();
::cc::proto::Vector2dF* release_inner_viewport_scroll_bounds_delta();
void set_allocated_inner_viewport_scroll_bounds_delta(::cc::proto::Vector2dF* inner_viewport_scroll_bounds_delta);

// repeated int64 always_use_active_tree_opacity_effect_ids = 15 [packed = true];
int always_use_active_tree_opacity_effect_ids_size() const;
void clear_always_use_active_tree_opacity_effect_ids();
static const int kAlwaysUseActiveTreeOpacityEffectIdsFieldNumber = 15;
::google::protobuf::int64 always_use_active_tree_opacity_effect_ids(int index) const;
void set_always_use_active_tree_opacity_effect_ids(int index, ::google::protobuf::int64 value);
void add_always_use_active_tree_opacity_effect_ids(::google::protobuf::int64 value);
const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
always_use_active_tree_opacity_effect_ids() const;
::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
mutable_always_use_active_tree_opacity_effect_ids();

// @@protoc_insertion_point(class_scope:cc.proto.PropertyTrees)
private:
inline void set_has_transform_tree();
inline void clear_has_transform_tree();
inline void set_has_effect_tree();
inline void clear_has_effect_tree();
inline void set_has_clip_tree();
inline void clear_has_clip_tree();
inline void set_has_scroll_tree();
inline void clear_has_scroll_tree();
inline void set_has_needs_rebuild();
inline void clear_has_needs_rebuild();
inline void set_has_non_root_surfaces_enabled();
inline void clear_has_non_root_surfaces_enabled();
inline void set_has_changed();
inline void clear_has_changed();
inline void set_has_full_tree_damaged();
inline void clear_has_full_tree_damaged();
inline void set_has_sequence_number();
inline void clear_has_sequence_number();
inline void set_has_is_main_thread();
inline void clear_has_is_main_thread();
inline void set_has_is_active();
inline void clear_has_is_active();
inline void set_has_verify_transform_tree_calculations();
inline void clear_has_verify_transform_tree_calculations();
inline void set_has_inner_viewport_container_bounds_delta();
inline void clear_has_inner_viewport_container_bounds_delta();
inline void set_has_outer_viewport_container_bounds_delta();
inline void clear_has_outer_viewport_container_bounds_delta();
inline void set_has_inner_viewport_scroll_bounds_delta();
inline void clear_has_inner_viewport_scroll_bounds_delta();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::cc::proto::PropertyTree* transform_tree_;
::cc::proto::PropertyTree* effect_tree_;
::cc::proto::PropertyTree* clip_tree_;
::cc::proto::PropertyTree* scroll_tree_;
bool needs_rebuild_;
bool non_root_surfaces_enabled_;
bool changed_;
bool full_tree_damaged_;
bool is_main_thread_;
bool is_active_;
bool verify_transform_tree_calculations_;
::google::protobuf::int64 sequence_number_;
::cc::proto::Vector2dF* inner_viewport_container_bounds_delta_;
::cc::proto::Vector2dF* outer_viewport_container_bounds_delta_;
::cc::proto::Vector2dF* inner_viewport_scroll_bounds_delta_;
::google::protobuf::RepeatedField< ::google::protobuf::int64 > always_use_active_tree_opacity_effect_ids_;
mutable int _always_use_active_tree_opacity_effect_ids_cached_byte_size_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_property_5ftree_2eproto();
#endif
friend void protobuf_AssignDesc_property_5ftree_2eproto();
friend void protobuf_ShutdownFile_property_5ftree_2eproto();

void InitAsDefaultInstance();
static PropertyTrees* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TranformNodeData

// optional .cc.proto.Transform pre_local = 1;
inline bool TranformNodeData::has_pre_local() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TranformNodeData::set_has_pre_local() {
_has_bits_[0] |= 0x00000001u;
}
inline void TranformNodeData::clear_has_pre_local() {
_has_bits_[0] &= ~0x00000001u;
}
inline void TranformNodeData::clear_pre_local() {
if (pre_local_ != NULL) pre_local_->::cc::proto::Transform::Clear();
clear_has_pre_local();
}
inline const ::cc::proto::Transform& TranformNodeData::pre_local() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.pre_local)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return pre_local_ != NULL ? *pre_local_ : *default_instance().pre_local_;
#else
return pre_local_ != NULL ? *pre_local_ : *default_instance_->pre_local_;
#endif
}
inline ::cc::proto::Transform* TranformNodeData::mutable_pre_local() {
set_has_pre_local();
if (pre_local_ == NULL) {
pre_local_ = new ::cc::proto::Transform;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TranformNodeData.pre_local)
return pre_local_;
}
inline ::cc::proto::Transform* TranformNodeData::release_pre_local() {
// @@protoc_insertion_point(field_release:cc.proto.TranformNodeData.pre_local)
clear_has_pre_local();
::cc::proto::Transform* temp = pre_local_;
pre_local_ = NULL;
return temp;
}
inline void TranformNodeData::set_allocated_pre_local(::cc::proto::Transform* pre_local) {
delete pre_local_;
pre_local_ = pre_local;
if (pre_local) {
set_has_pre_local();
} else {
clear_has_pre_local();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TranformNodeData.pre_local)
}

// optional .cc.proto.Transform local = 2;
inline bool TranformNodeData::has_local() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TranformNodeData::set_has_local() {
_has_bits_[0] |= 0x00000002u;
}
inline void TranformNodeData::clear_has_local() {
_has_bits_[0] &= ~0x00000002u;
}
inline void TranformNodeData::clear_local() {
if (local_ != NULL) local_->::cc::proto::Transform::Clear();
clear_has_local();
}
inline const ::cc::proto::Transform& TranformNodeData::local() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.local)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return local_ != NULL ? *local_ : *default_instance().local_;
#else
return local_ != NULL ? *local_ : *default_instance_->local_;
#endif
}
inline ::cc::proto::Transform* TranformNodeData::mutable_local() {
set_has_local();
if (local_ == NULL) {
local_ = new ::cc::proto::Transform;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TranformNodeData.local)
return local_;
}
inline ::cc::proto::Transform* TranformNodeData::release_local() {
// @@protoc_insertion_point(field_release:cc.proto.TranformNodeData.local)
clear_has_local();
::cc::proto::Transform* temp = local_;
local_ = NULL;
return temp;
}
inline void TranformNodeData::set_allocated_local(::cc::proto::Transform* local) {
delete local_;
local_ = local;
if (local) {
set_has_local();
} else {
clear_has_local();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TranformNodeData.local)
}

// optional .cc.proto.Transform post_local = 3;
inline bool TranformNodeData::has_post_local() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TranformNodeData::set_has_post_local() {
_has_bits_[0] |= 0x00000004u;
}
inline void TranformNodeData::clear_has_post_local() {
_has_bits_[0] &= ~0x00000004u;
}
inline void TranformNodeData::clear_post_local() {
if (post_local_ != NULL) post_local_->::cc::proto::Transform::Clear();
clear_has_post_local();
}
inline const ::cc::proto::Transform& TranformNodeData::post_local() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.post_local)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return post_local_ != NULL ? *post_local_ : *default_instance().post_local_;
#else
return post_local_ != NULL ? *post_local_ : *default_instance_->post_local_;
#endif
}
inline ::cc::proto::Transform* TranformNodeData::mutable_post_local() {
set_has_post_local();
if (post_local_ == NULL) {
post_local_ = new ::cc::proto::Transform;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TranformNodeData.post_local)
return post_local_;
}
inline ::cc::proto::Transform* TranformNodeData::release_post_local() {
// @@protoc_insertion_point(field_release:cc.proto.TranformNodeData.post_local)
clear_has_post_local();
::cc::proto::Transform* temp = post_local_;
post_local_ = NULL;
return temp;
}
inline void TranformNodeData::set_allocated_post_local(::cc::proto::Transform* post_local) {
delete post_local_;
post_local_ = post_local;
if (post_local) {
set_has_post_local();
} else {
clear_has_post_local();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TranformNodeData.post_local)
}

// optional .cc.proto.Transform to_parent = 4;
inline bool TranformNodeData::has_to_parent() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TranformNodeData::set_has_to_parent() {
_has_bits_[0] |= 0x00000008u;
}
inline void TranformNodeData::clear_has_to_parent() {
_has_bits_[0] &= ~0x00000008u;
}
inline void TranformNodeData::clear_to_parent() {
if (to_parent_ != NULL) to_parent_->::cc::proto::Transform::Clear();
clear_has_to_parent();
}
inline const ::cc::proto::Transform& TranformNodeData::to_parent() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.to_parent)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return to_parent_ != NULL ? *to_parent_ : *default_instance().to_parent_;
#else
return to_parent_ != NULL ? *to_parent_ : *default_instance_->to_parent_;
#endif
}
inline ::cc::proto::Transform* TranformNodeData::mutable_to_parent() {
set_has_to_parent();
if (to_parent_ == NULL) {
to_parent_ = new ::cc::proto::Transform;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TranformNodeData.to_parent)
return to_parent_;
}
inline ::cc::proto::Transform* TranformNodeData::release_to_parent() {
// @@protoc_insertion_point(field_release:cc.proto.TranformNodeData.to_parent)
clear_has_to_parent();
::cc::proto::Transform* temp = to_parent_;
to_parent_ = NULL;
return temp;
}
inline void TranformNodeData::set_allocated_to_parent(::cc::proto::Transform* to_parent) {
delete to_parent_;
to_parent_ = to_parent;
if (to_parent) {
set_has_to_parent();
} else {
clear_has_to_parent();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TranformNodeData.to_parent)
}

// optional int64 source_node_id = 11;
inline bool TranformNodeData::has_source_node_id() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TranformNodeData::set_has_source_node_id() {
_has_bits_[0] |= 0x00000010u;
}
inline void TranformNodeData::clear_has_source_node_id() {
_has_bits_[0] &= ~0x00000010u;
}
inline void TranformNodeData::clear_source_node_id() {
source_node_id_ = GOOGLE_LONGLONG(0);
clear_has_source_node_id();
}
inline ::google::protobuf::int64 TranformNodeData::source_node_id() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.source_node_id)
return source_node_id_;
}
inline void TranformNodeData::set_source_node_id(::google::protobuf::int64 value) {
set_has_source_node_id();
source_node_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.source_node_id)
}

// optional bool needs_local_transform_update = 12;
inline bool TranformNodeData::has_needs_local_transform_update() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TranformNodeData::set_has_needs_local_transform_update() {
_has_bits_[0] |= 0x00000020u;
}
inline void TranformNodeData::clear_has_needs_local_transform_update() {
_has_bits_[0] &= ~0x00000020u;
}
inline void TranformNodeData::clear_needs_local_transform_update() {
needs_local_transform_update_ = false;
clear_has_needs_local_transform_update();
}
inline bool TranformNodeData::needs_local_transform_update() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.needs_local_transform_update)
return needs_local_transform_update_;
}
inline void TranformNodeData::set_needs_local_transform_update(bool value) {
set_has_needs_local_transform_update();
needs_local_transform_update_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.needs_local_transform_update)
}

// optional bool node_and_ancestors_are_animated_or_invertible = 41;
inline bool TranformNodeData::has_node_and_ancestors_are_animated_or_invertible() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TranformNodeData::set_has_node_and_ancestors_are_animated_or_invertible() {
_has_bits_[0] |= 0x00000040u;
}
inline void TranformNodeData::clear_has_node_and_ancestors_are_animated_or_invertible() {
_has_bits_[0] &= ~0x00000040u;
}
inline void TranformNodeData::clear_node_and_ancestors_are_animated_or_invertible() {
node_and_ancestors_are_animated_or_invertible_ = false;
clear_has_node_and_ancestors_are_animated_or_invertible();
}
inline bool TranformNodeData::node_and_ancestors_are_animated_or_invertible() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.node_and_ancestors_are_animated_or_invertible)
return node_and_ancestors_are_animated_or_invertible_;
}
inline void TranformNodeData::set_node_and_ancestors_are_animated_or_invertible(bool value) {
set_has_node_and_ancestors_are_animated_or_invertible();
node_and_ancestors_are_animated_or_invertible_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.node_and_ancestors_are_animated_or_invertible)
}

// optional bool is_invertible = 13;
inline bool TranformNodeData::has_is_invertible() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TranformNodeData::set_has_is_invertible() {
_has_bits_[0] |= 0x00000080u;
}
inline void TranformNodeData::clear_has_is_invertible() {
_has_bits_[0] &= ~0x00000080u;
}
inline void TranformNodeData::clear_is_invertible() {
is_invertible_ = false;
clear_has_is_invertible();
}
inline bool TranformNodeData::is_invertible() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.is_invertible)
return is_invertible_;
}
inline void TranformNodeData::set_is_invertible(bool value) {
set_has_is_invertible();
is_invertible_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.is_invertible)
}

// optional bool ancestors_are_invertible = 14;
inline bool TranformNodeData::has_ancestors_are_invertible() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TranformNodeData::set_has_ancestors_are_invertible() {
_has_bits_[0] |= 0x00000100u;
}
inline void TranformNodeData::clear_has_ancestors_are_invertible() {
_has_bits_[0] &= ~0x00000100u;
}
inline void TranformNodeData::clear_ancestors_are_invertible() {
ancestors_are_invertible_ = false;
clear_has_ancestors_are_invertible();
}
inline bool TranformNodeData::ancestors_are_invertible() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.ancestors_are_invertible)
return ancestors_are_invertible_;
}
inline void TranformNodeData::set_ancestors_are_invertible(bool value) {
set_has_ancestors_are_invertible();
ancestors_are_invertible_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.ancestors_are_invertible)
}

// optional bool has_potential_animation = 15;
inline bool TranformNodeData::has_has_potential_animation() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TranformNodeData::set_has_has_potential_animation() {
_has_bits_[0] |= 0x00000200u;
}
inline void TranformNodeData::clear_has_has_potential_animation() {
_has_bits_[0] &= ~0x00000200u;
}
inline void TranformNodeData::clear_has_potential_animation() {
has_potential_animation_ = false;
clear_has_has_potential_animation();
}
inline bool TranformNodeData::has_potential_animation() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.has_potential_animation)
return has_potential_animation_;
}
inline void TranformNodeData::set_has_potential_animation(bool value) {
set_has_has_potential_animation();
has_potential_animation_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.has_potential_animation)
}

// optional bool is_currently_animating = 42;
inline bool TranformNodeData::has_is_currently_animating() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TranformNodeData::set_has_is_currently_animating() {
_has_bits_[0] |= 0x00000400u;
}
inline void TranformNodeData::clear_has_is_currently_animating() {
_has_bits_[0] &= ~0x00000400u;
}
inline void TranformNodeData::clear_is_currently_animating() {
is_currently_animating_ = false;
clear_has_is_currently_animating();
}
inline bool TranformNodeData::is_currently_animating() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.is_currently_animating)
return is_currently_animating_;
}
inline void TranformNodeData::set_is_currently_animating(bool value) {
set_has_is_currently_animating();
is_currently_animating_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.is_currently_animating)
}

// optional bool to_screen_is_potentially_animated = 16;
inline bool TranformNodeData::has_to_screen_is_potentially_animated() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TranformNodeData::set_has_to_screen_is_potentially_animated() {
_has_bits_[0] |= 0x00000800u;
}
inline void TranformNodeData::clear_has_to_screen_is_potentially_animated() {
_has_bits_[0] &= ~0x00000800u;
}
inline void TranformNodeData::clear_to_screen_is_potentially_animated() {
to_screen_is_potentially_animated_ = false;
clear_has_to_screen_is_potentially_animated();
}
inline bool TranformNodeData::to_screen_is_potentially_animated() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.to_screen_is_potentially_animated)
return to_screen_is_potentially_animated_;
}
inline void TranformNodeData::set_to_screen_is_potentially_animated(bool value) {
set_has_to_screen_is_potentially_animated();
to_screen_is_potentially_animated_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.to_screen_is_potentially_animated)
}

// optional bool has_only_translation_animations = 17;
inline bool TranformNodeData::has_has_only_translation_animations() const {
return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TranformNodeData::set_has_has_only_translation_animations() {
_has_bits_[0] |= 0x00001000u;
}
inline void TranformNodeData::clear_has_has_only_translation_animations() {
_has_bits_[0] &= ~0x00001000u;
}
inline void TranformNodeData::clear_has_only_translation_animations() {
has_only_translation_animations_ = false;
clear_has_has_only_translation_animations();
}
inline bool TranformNodeData::has_only_translation_animations() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.has_only_translation_animations)
return has_only_translation_animations_;
}
inline void TranformNodeData::set_has_only_translation_animations(bool value) {
set_has_has_only_translation_animations();
has_only_translation_animations_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.has_only_translation_animations)
}

// optional bool flattens_inherited_transform = 19;
inline bool TranformNodeData::has_flattens_inherited_transform() const {
return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TranformNodeData::set_has_flattens_inherited_transform() {
_has_bits_[0] |= 0x00002000u;
}
inline void TranformNodeData::clear_has_flattens_inherited_transform() {
_has_bits_[0] &= ~0x00002000u;
}
inline void TranformNodeData::clear_flattens_inherited_transform() {
flattens_inherited_transform_ = false;
clear_has_flattens_inherited_transform();
}
inline bool TranformNodeData::flattens_inherited_transform() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.flattens_inherited_transform)
return flattens_inherited_transform_;
}
inline void TranformNodeData::set_flattens_inherited_transform(bool value) {
set_has_flattens_inherited_transform();
flattens_inherited_transform_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.flattens_inherited_transform)
}

// optional bool node_and_ancestors_are_flat = 20;
inline bool TranformNodeData::has_node_and_ancestors_are_flat() const {
return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TranformNodeData::set_has_node_and_ancestors_are_flat() {
_has_bits_[0] |= 0x00004000u;
}
inline void TranformNodeData::clear_has_node_and_ancestors_are_flat() {
_has_bits_[0] &= ~0x00004000u;
}
inline void TranformNodeData::clear_node_and_ancestors_are_flat() {
node_and_ancestors_are_flat_ = false;
clear_has_node_and_ancestors_are_flat();
}
inline bool TranformNodeData::node_and_ancestors_are_flat() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.node_and_ancestors_are_flat)
return node_and_ancestors_are_flat_;
}
inline void TranformNodeData::set_node_and_ancestors_are_flat(bool value) {
set_has_node_and_ancestors_are_flat();
node_and_ancestors_are_flat_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.node_and_ancestors_are_flat)
}

// optional bool node_and_ancestors_have_only_integer_translation = 21;
inline bool TranformNodeData::has_node_and_ancestors_have_only_integer_translation() const {
return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TranformNodeData::set_has_node_and_ancestors_have_only_integer_translation() {
_has_bits_[0] |= 0x00008000u;
}
inline void TranformNodeData::clear_has_node_and_ancestors_have_only_integer_translation() {
_has_bits_[0] &= ~0x00008000u;
}
inline void TranformNodeData::clear_node_and_ancestors_have_only_integer_translation() {
node_and_ancestors_have_only_integer_translation_ = false;
clear_has_node_and_ancestors_have_only_integer_translation();
}
inline bool TranformNodeData::node_and_ancestors_have_only_integer_translation() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.node_and_ancestors_have_only_integer_translation)
return node_and_ancestors_have_only_integer_translation_;
}
inline void TranformNodeData::set_node_and_ancestors_have_only_integer_translation(bool value) {
set_has_node_and_ancestors_have_only_integer_translation();
node_and_ancestors_have_only_integer_translation_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.node_and_ancestors_have_only_integer_translation)
}

// optional bool scrolls = 22;
inline bool TranformNodeData::has_scrolls() const {
return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TranformNodeData::set_has_scrolls() {
_has_bits_[0] |= 0x00010000u;
}
inline void TranformNodeData::clear_has_scrolls() {
_has_bits_[0] &= ~0x00010000u;
}
inline void TranformNodeData::clear_scrolls() {
scrolls_ = false;
clear_has_scrolls();
}
inline bool TranformNodeData::scrolls() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.scrolls)
return scrolls_;
}
inline void TranformNodeData::set_scrolls(bool value) {
set_has_scrolls();
scrolls_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.scrolls)
}

// optional bool needs_surface_contents_scale = 23;
inline bool TranformNodeData::has_needs_surface_contents_scale() const {
return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TranformNodeData::set_has_needs_surface_contents_scale() {
_has_bits_[0] |= 0x00020000u;
}
inline void TranformNodeData::clear_has_needs_surface_contents_scale() {
_has_bits_[0] &= ~0x00020000u;
}
inline void TranformNodeData::clear_needs_surface_contents_scale() {
needs_surface_contents_scale_ = false;
clear_has_needs_surface_contents_scale();
}
inline bool TranformNodeData::needs_surface_contents_scale() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.needs_surface_contents_scale)
return needs_surface_contents_scale_;
}
inline void TranformNodeData::set_needs_surface_contents_scale(bool value) {
set_has_needs_surface_contents_scale();
needs_surface_contents_scale_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.needs_surface_contents_scale)
}

// optional bool affected_by_inner_viewport_bounds_delta_x = 24;
inline bool TranformNodeData::has_affected_by_inner_viewport_bounds_delta_x() const {
return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TranformNodeData::set_has_affected_by_inner_viewport_bounds_delta_x() {
_has_bits_[0] |= 0x00040000u;
}
inline void TranformNodeData::clear_has_affected_by_inner_viewport_bounds_delta_x() {
_has_bits_[0] &= ~0x00040000u;
}
inline void TranformNodeData::clear_affected_by_inner_viewport_bounds_delta_x() {
affected_by_inner_viewport_bounds_delta_x_ = false;
clear_has_affected_by_inner_viewport_bounds_delta_x();
}
inline bool TranformNodeData::affected_by_inner_viewport_bounds_delta_x() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.affected_by_inner_viewport_bounds_delta_x)
return affected_by_inner_viewport_bounds_delta_x_;
}
inline void TranformNodeData::set_affected_by_inner_viewport_bounds_delta_x(bool value) {
set_has_affected_by_inner_viewport_bounds_delta_x();
affected_by_inner_viewport_bounds_delta_x_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.affected_by_inner_viewport_bounds_delta_x)
}

// optional bool affected_by_inner_viewport_bounds_delta_y = 25;
inline bool TranformNodeData::has_affected_by_inner_viewport_bounds_delta_y() const {
return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TranformNodeData::set_has_affected_by_inner_viewport_bounds_delta_y() {
_has_bits_[0] |= 0x00080000u;
}
inline void TranformNodeData::clear_has_affected_by_inner_viewport_bounds_delta_y() {
_has_bits_[0] &= ~0x00080000u;
}
inline void TranformNodeData::clear_affected_by_inner_viewport_bounds_delta_y() {
affected_by_inner_viewport_bounds_delta_y_ = false;
clear_has_affected_by_inner_viewport_bounds_delta_y();
}
inline bool TranformNodeData::affected_by_inner_viewport_bounds_delta_y() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.affected_by_inner_viewport_bounds_delta_y)
return affected_by_inner_viewport_bounds_delta_y_;
}
inline void TranformNodeData::set_affected_by_inner_viewport_bounds_delta_y(bool value) {
set_has_affected_by_inner_viewport_bounds_delta_y();
affected_by_inner_viewport_bounds_delta_y_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.affected_by_inner_viewport_bounds_delta_y)
}

// optional bool affected_by_outer_viewport_bounds_delta_x = 26;
inline bool TranformNodeData::has_affected_by_outer_viewport_bounds_delta_x() const {
return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TranformNodeData::set_has_affected_by_outer_viewport_bounds_delta_x() {
_has_bits_[0] |= 0x00100000u;
}
inline void TranformNodeData::clear_has_affected_by_outer_viewport_bounds_delta_x() {
_has_bits_[0] &= ~0x00100000u;
}
inline void TranformNodeData::clear_affected_by_outer_viewport_bounds_delta_x() {
affected_by_outer_viewport_bounds_delta_x_ = false;
clear_has_affected_by_outer_viewport_bounds_delta_x();
}
inline bool TranformNodeData::affected_by_outer_viewport_bounds_delta_x() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.affected_by_outer_viewport_bounds_delta_x)
return affected_by_outer_viewport_bounds_delta_x_;
}
inline void TranformNodeData::set_affected_by_outer_viewport_bounds_delta_x(bool value) {
set_has_affected_by_outer_viewport_bounds_delta_x();
affected_by_outer_viewport_bounds_delta_x_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.affected_by_outer_viewport_bounds_delta_x)
}

// optional bool affected_by_outer_viewport_bounds_delta_y = 27;
inline bool TranformNodeData::has_affected_by_outer_viewport_bounds_delta_y() const {
return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TranformNodeData::set_has_affected_by_outer_viewport_bounds_delta_y() {
_has_bits_[0] |= 0x00200000u;
}
inline void TranformNodeData::clear_has_affected_by_outer_viewport_bounds_delta_y() {
_has_bits_[0] &= ~0x00200000u;
}
inline void TranformNodeData::clear_affected_by_outer_viewport_bounds_delta_y() {
affected_by_outer_viewport_bounds_delta_y_ = false;
clear_has_affected_by_outer_viewport_bounds_delta_y();
}
inline bool TranformNodeData::affected_by_outer_viewport_bounds_delta_y() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.affected_by_outer_viewport_bounds_delta_y)
return affected_by_outer_viewport_bounds_delta_y_;
}
inline void TranformNodeData::set_affected_by_outer_viewport_bounds_delta_y(bool value) {
set_has_affected_by_outer_viewport_bounds_delta_y();
affected_by_outer_viewport_bounds_delta_y_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.affected_by_outer_viewport_bounds_delta_y)
}

// optional bool in_subtree_of_page_scale_layer = 28;
inline bool TranformNodeData::has_in_subtree_of_page_scale_layer() const {
return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TranformNodeData::set_has_in_subtree_of_page_scale_layer() {
_has_bits_[0] |= 0x00400000u;
}
inline void TranformNodeData::clear_has_in_subtree_of_page_scale_layer() {
_has_bits_[0] &= ~0x00400000u;
}
inline void TranformNodeData::clear_in_subtree_of_page_scale_layer() {
in_subtree_of_page_scale_layer_ = false;
clear_has_in_subtree_of_page_scale_layer();
}
inline bool TranformNodeData::in_subtree_of_page_scale_layer() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.in_subtree_of_page_scale_layer)
return in_subtree_of_page_scale_layer_;
}
inline void TranformNodeData::set_in_subtree_of_page_scale_layer(bool value) {
set_has_in_subtree_of_page_scale_layer();
in_subtree_of_page_scale_layer_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.in_subtree_of_page_scale_layer)
}

// optional bool transform_changed = 40;
inline bool TranformNodeData::has_transform_changed() const {
return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TranformNodeData::set_has_transform_changed() {
_has_bits_[0] |= 0x00800000u;
}
inline void TranformNodeData::clear_has_transform_changed() {
_has_bits_[0] &= ~0x00800000u;
}
inline void TranformNodeData::clear_transform_changed() {
transform_changed_ = false;
clear_has_transform_changed();
}
inline bool TranformNodeData::transform_changed() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.transform_changed)
return transform_changed_;
}
inline void TranformNodeData::set_transform_changed(bool value) {
set_has_transform_changed();
transform_changed_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.transform_changed)
}

// optional float post_local_scale_factor = 29;
inline bool TranformNodeData::has_post_local_scale_factor() const {
return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TranformNodeData::set_has_post_local_scale_factor() {
_has_bits_[0] |= 0x01000000u;
}
inline void TranformNodeData::clear_has_post_local_scale_factor() {
_has_bits_[0] &= ~0x01000000u;
}
inline void TranformNodeData::clear_post_local_scale_factor() {
post_local_scale_factor_ = 0;
clear_has_post_local_scale_factor();
}
inline float TranformNodeData::post_local_scale_factor() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.post_local_scale_factor)
return post_local_scale_factor_;
}
inline void TranformNodeData::set_post_local_scale_factor(float value) {
set_has_post_local_scale_factor();
post_local_scale_factor_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.post_local_scale_factor)
}

// optional .cc.proto.Vector2dF surface_contents_scale = 34;
inline bool TranformNodeData::has_surface_contents_scale() const {
return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void TranformNodeData::set_has_surface_contents_scale() {
_has_bits_[0] |= 0x02000000u;
}
inline void TranformNodeData::clear_has_surface_contents_scale() {
_has_bits_[0] &= ~0x02000000u;
}
inline void TranformNodeData::clear_surface_contents_scale() {
if (surface_contents_scale_ != NULL) surface_contents_scale_->::cc::proto::Vector2dF::Clear();
clear_has_surface_contents_scale();
}
inline const ::cc::proto::Vector2dF& TranformNodeData::surface_contents_scale() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.surface_contents_scale)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return surface_contents_scale_ != NULL ? *surface_contents_scale_ : *default_instance().surface_contents_scale_;
#else
return surface_contents_scale_ != NULL ? *surface_contents_scale_ : *default_instance_->surface_contents_scale_;
#endif
}
inline ::cc::proto::Vector2dF* TranformNodeData::mutable_surface_contents_scale() {
set_has_surface_contents_scale();
if (surface_contents_scale_ == NULL) {
surface_contents_scale_ = new ::cc::proto::Vector2dF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TranformNodeData.surface_contents_scale)
return surface_contents_scale_;
}
inline ::cc::proto::Vector2dF* TranformNodeData::release_surface_contents_scale() {
// @@protoc_insertion_point(field_release:cc.proto.TranformNodeData.surface_contents_scale)
clear_has_surface_contents_scale();
::cc::proto::Vector2dF* temp = surface_contents_scale_;
surface_contents_scale_ = NULL;
return temp;
}
inline void TranformNodeData::set_allocated_surface_contents_scale(::cc::proto::Vector2dF* surface_contents_scale) {
delete surface_contents_scale_;
surface_contents_scale_ = surface_contents_scale;
if (surface_contents_scale) {
set_has_surface_contents_scale();
} else {
clear_has_surface_contents_scale();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TranformNodeData.surface_contents_scale)
}

// optional .cc.proto.ScrollOffset scroll_offset = 35;
inline bool TranformNodeData::has_scroll_offset() const {
return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void TranformNodeData::set_has_scroll_offset() {
_has_bits_[0] |= 0x04000000u;
}
inline void TranformNodeData::clear_has_scroll_offset() {
_has_bits_[0] &= ~0x04000000u;
}
inline void TranformNodeData::clear_scroll_offset() {
if (scroll_offset_ != NULL) scroll_offset_->::cc::proto::ScrollOffset::Clear();
clear_has_scroll_offset();
}
inline const ::cc::proto::ScrollOffset& TranformNodeData::scroll_offset() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.scroll_offset)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return scroll_offset_ != NULL ? *scroll_offset_ : *default_instance().scroll_offset_;
#else
return scroll_offset_ != NULL ? *scroll_offset_ : *default_instance_->scroll_offset_;
#endif
}
inline ::cc::proto::ScrollOffset* TranformNodeData::mutable_scroll_offset() {
set_has_scroll_offset();
if (scroll_offset_ == NULL) {
scroll_offset_ = new ::cc::proto::ScrollOffset;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TranformNodeData.scroll_offset)
return scroll_offset_;
}
inline ::cc::proto::ScrollOffset* TranformNodeData::release_scroll_offset() {
// @@protoc_insertion_point(field_release:cc.proto.TranformNodeData.scroll_offset)
clear_has_scroll_offset();
::cc::proto::ScrollOffset* temp = scroll_offset_;
scroll_offset_ = NULL;
return temp;
}
inline void TranformNodeData::set_allocated_scroll_offset(::cc::proto::ScrollOffset* scroll_offset) {
delete scroll_offset_;
scroll_offset_ = scroll_offset;
if (scroll_offset) {
set_has_scroll_offset();
} else {
clear_has_scroll_offset();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TranformNodeData.scroll_offset)
}

// optional .cc.proto.Vector2dF scroll_snap = 36;
inline bool TranformNodeData::has_scroll_snap() const {
return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void TranformNodeData::set_has_scroll_snap() {
_has_bits_[0] |= 0x08000000u;
}
inline void TranformNodeData::clear_has_scroll_snap() {
_has_bits_[0] &= ~0x08000000u;
}
inline void TranformNodeData::clear_scroll_snap() {
if (scroll_snap_ != NULL) scroll_snap_->::cc::proto::Vector2dF::Clear();
clear_has_scroll_snap();
}
inline const ::cc::proto::Vector2dF& TranformNodeData::scroll_snap() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.scroll_snap)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return scroll_snap_ != NULL ? *scroll_snap_ : *default_instance().scroll_snap_;
#else
return scroll_snap_ != NULL ? *scroll_snap_ : *default_instance_->scroll_snap_;
#endif
}
inline ::cc::proto::Vector2dF* TranformNodeData::mutable_scroll_snap() {
set_has_scroll_snap();
if (scroll_snap_ == NULL) {
scroll_snap_ = new ::cc::proto::Vector2dF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TranformNodeData.scroll_snap)
return scroll_snap_;
}
inline ::cc::proto::Vector2dF* TranformNodeData::release_scroll_snap() {
// @@protoc_insertion_point(field_release:cc.proto.TranformNodeData.scroll_snap)
clear_has_scroll_snap();
::cc::proto::Vector2dF* temp = scroll_snap_;
scroll_snap_ = NULL;
return temp;
}
inline void TranformNodeData::set_allocated_scroll_snap(::cc::proto::Vector2dF* scroll_snap) {
delete scroll_snap_;
scroll_snap_ = scroll_snap;
if (scroll_snap) {
set_has_scroll_snap();
} else {
clear_has_scroll_snap();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TranformNodeData.scroll_snap)
}

// optional .cc.proto.Vector2dF source_offset = 37;
inline bool TranformNodeData::has_source_offset() const {
return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void TranformNodeData::set_has_source_offset() {
_has_bits_[0] |= 0x10000000u;
}
inline void TranformNodeData::clear_has_source_offset() {
_has_bits_[0] &= ~0x10000000u;
}
inline void TranformNodeData::clear_source_offset() {
if (source_offset_ != NULL) source_offset_->::cc::proto::Vector2dF::Clear();
clear_has_source_offset();
}
inline const ::cc::proto::Vector2dF& TranformNodeData::source_offset() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.source_offset)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return source_offset_ != NULL ? *source_offset_ : *default_instance().source_offset_;
#else
return source_offset_ != NULL ? *source_offset_ : *default_instance_->source_offset_;
#endif
}
inline ::cc::proto::Vector2dF* TranformNodeData::mutable_source_offset() {
set_has_source_offset();
if (source_offset_ == NULL) {
source_offset_ = new ::cc::proto::Vector2dF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TranformNodeData.source_offset)
return source_offset_;
}
inline ::cc::proto::Vector2dF* TranformNodeData::release_source_offset() {
// @@protoc_insertion_point(field_release:cc.proto.TranformNodeData.source_offset)
clear_has_source_offset();
::cc::proto::Vector2dF* temp = source_offset_;
source_offset_ = NULL;
return temp;
}
inline void TranformNodeData::set_allocated_source_offset(::cc::proto::Vector2dF* source_offset) {
delete source_offset_;
source_offset_ = source_offset;
if (source_offset) {
set_has_source_offset();
} else {
clear_has_source_offset();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TranformNodeData.source_offset)
}

// optional .cc.proto.Vector2dF source_to_parent = 38;
inline bool TranformNodeData::has_source_to_parent() const {
return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void TranformNodeData::set_has_source_to_parent() {
_has_bits_[0] |= 0x20000000u;
}
inline void TranformNodeData::clear_has_source_to_parent() {
_has_bits_[0] &= ~0x20000000u;
}
inline void TranformNodeData::clear_source_to_parent() {
if (source_to_parent_ != NULL) source_to_parent_->::cc::proto::Vector2dF::Clear();
clear_has_source_to_parent();
}
inline const ::cc::proto::Vector2dF& TranformNodeData::source_to_parent() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.source_to_parent)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return source_to_parent_ != NULL ? *source_to_parent_ : *default_instance().source_to_parent_;
#else
return source_to_parent_ != NULL ? *source_to_parent_ : *default_instance_->source_to_parent_;
#endif
}
inline ::cc::proto::Vector2dF* TranformNodeData::mutable_source_to_parent() {
set_has_source_to_parent();
if (source_to_parent_ == NULL) {
source_to_parent_ = new ::cc::proto::Vector2dF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TranformNodeData.source_to_parent)
return source_to_parent_;
}
inline ::cc::proto::Vector2dF* TranformNodeData::release_source_to_parent() {
// @@protoc_insertion_point(field_release:cc.proto.TranformNodeData.source_to_parent)
clear_has_source_to_parent();
::cc::proto::Vector2dF* temp = source_to_parent_;
source_to_parent_ = NULL;
return temp;
}
inline void TranformNodeData::set_allocated_source_to_parent(::cc::proto::Vector2dF* source_to_parent) {
delete source_to_parent_;
source_to_parent_ = source_to_parent;
if (source_to_parent) {
set_has_source_to_parent();
} else {
clear_has_source_to_parent();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TranformNodeData.source_to_parent)
}

// optional int64 sorting_context_id = 39;
inline bool TranformNodeData::has_sorting_context_id() const {
return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void TranformNodeData::set_has_sorting_context_id() {
_has_bits_[0] |= 0x40000000u;
}
inline void TranformNodeData::clear_has_sorting_context_id() {
_has_bits_[0] &= ~0x40000000u;
}
inline void TranformNodeData::clear_sorting_context_id() {
sorting_context_id_ = GOOGLE_LONGLONG(0);
clear_has_sorting_context_id();
}
inline ::google::protobuf::int64 TranformNodeData::sorting_context_id() const {
// @@protoc_insertion_point(field_get:cc.proto.TranformNodeData.sorting_context_id)
return sorting_context_id_;
}
inline void TranformNodeData::set_sorting_context_id(::google::protobuf::int64 value) {
set_has_sorting_context_id();
sorting_context_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TranformNodeData.sorting_context_id)
}

// -------------------------------------------------------------------

// TransformCachedNodeData

// optional .cc.proto.Transform from_target = 1;
inline bool TransformCachedNodeData::has_from_target() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransformCachedNodeData::set_has_from_target() {
_has_bits_[0] |= 0x00000001u;
}
inline void TransformCachedNodeData::clear_has_from_target() {
_has_bits_[0] &= ~0x00000001u;
}
inline void TransformCachedNodeData::clear_from_target() {
if (from_target_ != NULL) from_target_->::cc::proto::Transform::Clear();
clear_has_from_target();
}
inline const ::cc::proto::Transform& TransformCachedNodeData::from_target() const {
// @@protoc_insertion_point(field_get:cc.proto.TransformCachedNodeData.from_target)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return from_target_ != NULL ? *from_target_ : *default_instance().from_target_;
#else
return from_target_ != NULL ? *from_target_ : *default_instance_->from_target_;
#endif
}
inline ::cc::proto::Transform* TransformCachedNodeData::mutable_from_target() {
set_has_from_target();
if (from_target_ == NULL) {
from_target_ = new ::cc::proto::Transform;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TransformCachedNodeData.from_target)
return from_target_;
}
inline ::cc::proto::Transform* TransformCachedNodeData::release_from_target() {
// @@protoc_insertion_point(field_release:cc.proto.TransformCachedNodeData.from_target)
clear_has_from_target();
::cc::proto::Transform* temp = from_target_;
from_target_ = NULL;
return temp;
}
inline void TransformCachedNodeData::set_allocated_from_target(::cc::proto::Transform* from_target) {
delete from_target_;
from_target_ = from_target;
if (from_target) {
set_has_from_target();
} else {
clear_has_from_target();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TransformCachedNodeData.from_target)
}

// optional .cc.proto.Transform to_target = 2;
inline bool TransformCachedNodeData::has_to_target() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransformCachedNodeData::set_has_to_target() {
_has_bits_[0] |= 0x00000002u;
}
inline void TransformCachedNodeData::clear_has_to_target() {
_has_bits_[0] &= ~0x00000002u;
}
inline void TransformCachedNodeData::clear_to_target() {
if (to_target_ != NULL) to_target_->::cc::proto::Transform::Clear();
clear_has_to_target();
}
inline const ::cc::proto::Transform& TransformCachedNodeData::to_target() const {
// @@protoc_insertion_point(field_get:cc.proto.TransformCachedNodeData.to_target)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return to_target_ != NULL ? *to_target_ : *default_instance().to_target_;
#else
return to_target_ != NULL ? *to_target_ : *default_instance_->to_target_;
#endif
}
inline ::cc::proto::Transform* TransformCachedNodeData::mutable_to_target() {
set_has_to_target();
if (to_target_ == NULL) {
to_target_ = new ::cc::proto::Transform;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TransformCachedNodeData.to_target)
return to_target_;
}
inline ::cc::proto::Transform* TransformCachedNodeData::release_to_target() {
// @@protoc_insertion_point(field_release:cc.proto.TransformCachedNodeData.to_target)
clear_has_to_target();
::cc::proto::Transform* temp = to_target_;
to_target_ = NULL;
return temp;
}
inline void TransformCachedNodeData::set_allocated_to_target(::cc::proto::Transform* to_target) {
delete to_target_;
to_target_ = to_target;
if (to_target) {
set_has_to_target();
} else {
clear_has_to_target();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TransformCachedNodeData.to_target)
}

// optional .cc.proto.Transform from_screen = 3;
inline bool TransformCachedNodeData::has_from_screen() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransformCachedNodeData::set_has_from_screen() {
_has_bits_[0] |= 0x00000004u;
}
inline void TransformCachedNodeData::clear_has_from_screen() {
_has_bits_[0] &= ~0x00000004u;
}
inline void TransformCachedNodeData::clear_from_screen() {
if (from_screen_ != NULL) from_screen_->::cc::proto::Transform::Clear();
clear_has_from_screen();
}
inline const ::cc::proto::Transform& TransformCachedNodeData::from_screen() const {
// @@protoc_insertion_point(field_get:cc.proto.TransformCachedNodeData.from_screen)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return from_screen_ != NULL ? *from_screen_ : *default_instance().from_screen_;
#else
return from_screen_ != NULL ? *from_screen_ : *default_instance_->from_screen_;
#endif
}
inline ::cc::proto::Transform* TransformCachedNodeData::mutable_from_screen() {
set_has_from_screen();
if (from_screen_ == NULL) {
from_screen_ = new ::cc::proto::Transform;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TransformCachedNodeData.from_screen)
return from_screen_;
}
inline ::cc::proto::Transform* TransformCachedNodeData::release_from_screen() {
// @@protoc_insertion_point(field_release:cc.proto.TransformCachedNodeData.from_screen)
clear_has_from_screen();
::cc::proto::Transform* temp = from_screen_;
from_screen_ = NULL;
return temp;
}
inline void TransformCachedNodeData::set_allocated_from_screen(::cc::proto::Transform* from_screen) {
delete from_screen_;
from_screen_ = from_screen;
if (from_screen) {
set_has_from_screen();
} else {
clear_has_from_screen();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TransformCachedNodeData.from_screen)
}

// optional .cc.proto.Transform to_screen = 4;
inline bool TransformCachedNodeData::has_to_screen() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransformCachedNodeData::set_has_to_screen() {
_has_bits_[0] |= 0x00000008u;
}
inline void TransformCachedNodeData::clear_has_to_screen() {
_has_bits_[0] &= ~0x00000008u;
}
inline void TransformCachedNodeData::clear_to_screen() {
if (to_screen_ != NULL) to_screen_->::cc::proto::Transform::Clear();
clear_has_to_screen();
}
inline const ::cc::proto::Transform& TransformCachedNodeData::to_screen() const {
// @@protoc_insertion_point(field_get:cc.proto.TransformCachedNodeData.to_screen)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return to_screen_ != NULL ? *to_screen_ : *default_instance().to_screen_;
#else
return to_screen_ != NULL ? *to_screen_ : *default_instance_->to_screen_;
#endif
}
inline ::cc::proto::Transform* TransformCachedNodeData::mutable_to_screen() {
set_has_to_screen();
if (to_screen_ == NULL) {
to_screen_ = new ::cc::proto::Transform;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TransformCachedNodeData.to_screen)
return to_screen_;
}
inline ::cc::proto::Transform* TransformCachedNodeData::release_to_screen() {
// @@protoc_insertion_point(field_release:cc.proto.TransformCachedNodeData.to_screen)
clear_has_to_screen();
::cc::proto::Transform* temp = to_screen_;
to_screen_ = NULL;
return temp;
}
inline void TransformCachedNodeData::set_allocated_to_screen(::cc::proto::Transform* to_screen) {
delete to_screen_;
to_screen_ = to_screen;
if (to_screen) {
set_has_to_screen();
} else {
clear_has_to_screen();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TransformCachedNodeData.to_screen)
}

// optional int64 target_id = 5;
inline bool TransformCachedNodeData::has_target_id() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransformCachedNodeData::set_has_target_id() {
_has_bits_[0] |= 0x00000010u;
}
inline void TransformCachedNodeData::clear_has_target_id() {
_has_bits_[0] &= ~0x00000010u;
}
inline void TransformCachedNodeData::clear_target_id() {
target_id_ = GOOGLE_LONGLONG(0);
clear_has_target_id();
}
inline ::google::protobuf::int64 TransformCachedNodeData::target_id() const {
// @@protoc_insertion_point(field_get:cc.proto.TransformCachedNodeData.target_id)
return target_id_;
}
inline void TransformCachedNodeData::set_target_id(::google::protobuf::int64 value) {
set_has_target_id();
target_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TransformCachedNodeData.target_id)
}

// optional int64 content_target_id = 6;
inline bool TransformCachedNodeData::has_content_target_id() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransformCachedNodeData::set_has_content_target_id() {
_has_bits_[0] |= 0x00000020u;
}
inline void TransformCachedNodeData::clear_has_content_target_id() {
_has_bits_[0] &= ~0x00000020u;
}
inline void TransformCachedNodeData::clear_content_target_id() {
content_target_id_ = GOOGLE_LONGLONG(0);
clear_has_content_target_id();
}
inline ::google::protobuf::int64 TransformCachedNodeData::content_target_id() const {
// @@protoc_insertion_point(field_get:cc.proto.TransformCachedNodeData.content_target_id)
return content_target_id_;
}
inline void TransformCachedNodeData::set_content_target_id(::google::protobuf::int64 value) {
set_has_content_target_id();
content_target_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TransformCachedNodeData.content_target_id)
}

// -------------------------------------------------------------------

// ClipNodeData

// optional .cc.proto.RectF clip = 1;
inline bool ClipNodeData::has_clip() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClipNodeData::set_has_clip() {
_has_bits_[0] |= 0x00000001u;
}
inline void ClipNodeData::clear_has_clip() {
_has_bits_[0] &= ~0x00000001u;
}
inline void ClipNodeData::clear_clip() {
if (clip_ != NULL) clip_->::cc::proto::RectF::Clear();
clear_has_clip();
}
inline const ::cc::proto::RectF& ClipNodeData::clip() const {
// @@protoc_insertion_point(field_get:cc.proto.ClipNodeData.clip)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return clip_ != NULL ? *clip_ : *default_instance().clip_;
#else
return clip_ != NULL ? *clip_ : *default_instance_->clip_;
#endif
}
inline ::cc::proto::RectF* ClipNodeData::mutable_clip() {
set_has_clip();
if (clip_ == NULL) {
clip_ = new ::cc::proto::RectF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ClipNodeData.clip)
return clip_;
}
inline ::cc::proto::RectF* ClipNodeData::release_clip() {
// @@protoc_insertion_point(field_release:cc.proto.ClipNodeData.clip)
clear_has_clip();
::cc::proto::RectF* temp = clip_;
clip_ = NULL;
return temp;
}
inline void ClipNodeData::set_allocated_clip(::cc::proto::RectF* clip) {
delete clip_;
clip_ = clip;
if (clip) {
set_has_clip();
} else {
clear_has_clip();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ClipNodeData.clip)
}

// optional .cc.proto.RectF combined_clip_in_target_space = 2;
inline bool ClipNodeData::has_combined_clip_in_target_space() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClipNodeData::set_has_combined_clip_in_target_space() {
_has_bits_[0] |= 0x00000002u;
}
inline void ClipNodeData::clear_has_combined_clip_in_target_space() {
_has_bits_[0] &= ~0x00000002u;
}
inline void ClipNodeData::clear_combined_clip_in_target_space() {
if (combined_clip_in_target_space_ != NULL) combined_clip_in_target_space_->::cc::proto::RectF::Clear();
clear_has_combined_clip_in_target_space();
}
inline const ::cc::proto::RectF& ClipNodeData::combined_clip_in_target_space() const {
// @@protoc_insertion_point(field_get:cc.proto.ClipNodeData.combined_clip_in_target_space)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return combined_clip_in_target_space_ != NULL ? *combined_clip_in_target_space_ : *default_instance().combined_clip_in_target_space_;
#else
return combined_clip_in_target_space_ != NULL ? *combined_clip_in_target_space_ : *default_instance_->combined_clip_in_target_space_;
#endif
}
inline ::cc::proto::RectF* ClipNodeData::mutable_combined_clip_in_target_space() {
set_has_combined_clip_in_target_space();
if (combined_clip_in_target_space_ == NULL) {
combined_clip_in_target_space_ = new ::cc::proto::RectF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ClipNodeData.combined_clip_in_target_space)
return combined_clip_in_target_space_;
}
inline ::cc::proto::RectF* ClipNodeData::release_combined_clip_in_target_space() {
// @@protoc_insertion_point(field_release:cc.proto.ClipNodeData.combined_clip_in_target_space)
clear_has_combined_clip_in_target_space();
::cc::proto::RectF* temp = combined_clip_in_target_space_;
combined_clip_in_target_space_ = NULL;
return temp;
}
inline void ClipNodeData::set_allocated_combined_clip_in_target_space(::cc::proto::RectF* combined_clip_in_target_space) {
delete combined_clip_in_target_space_;
combined_clip_in_target_space_ = combined_clip_in_target_space;
if (combined_clip_in_target_space) {
set_has_combined_clip_in_target_space();
} else {
clear_has_combined_clip_in_target_space();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ClipNodeData.combined_clip_in_target_space)
}

// optional .cc.proto.RectF clip_in_target_space = 3;
inline bool ClipNodeData::has_clip_in_target_space() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClipNodeData::set_has_clip_in_target_space() {
_has_bits_[0] |= 0x00000004u;
}
inline void ClipNodeData::clear_has_clip_in_target_space() {
_has_bits_[0] &= ~0x00000004u;
}
inline void ClipNodeData::clear_clip_in_target_space() {
if (clip_in_target_space_ != NULL) clip_in_target_space_->::cc::proto::RectF::Clear();
clear_has_clip_in_target_space();
}
inline const ::cc::proto::RectF& ClipNodeData::clip_in_target_space() const {
// @@protoc_insertion_point(field_get:cc.proto.ClipNodeData.clip_in_target_space)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return clip_in_target_space_ != NULL ? *clip_in_target_space_ : *default_instance().clip_in_target_space_;
#else
return clip_in_target_space_ != NULL ? *clip_in_target_space_ : *default_instance_->clip_in_target_space_;
#endif
}
inline ::cc::proto::RectF* ClipNodeData::mutable_clip_in_target_space() {
set_has_clip_in_target_space();
if (clip_in_target_space_ == NULL) {
clip_in_target_space_ = new ::cc::proto::RectF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ClipNodeData.clip_in_target_space)
return clip_in_target_space_;
}
inline ::cc::proto::RectF* ClipNodeData::release_clip_in_target_space() {
// @@protoc_insertion_point(field_release:cc.proto.ClipNodeData.clip_in_target_space)
clear_has_clip_in_target_space();
::cc::proto::RectF* temp = clip_in_target_space_;
clip_in_target_space_ = NULL;
return temp;
}
inline void ClipNodeData::set_allocated_clip_in_target_space(::cc::proto::RectF* clip_in_target_space) {
delete clip_in_target_space_;
clip_in_target_space_ = clip_in_target_space;
if (clip_in_target_space) {
set_has_clip_in_target_space();
} else {
clear_has_clip_in_target_space();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ClipNodeData.clip_in_target_space)
}

// optional int64 transform_id = 4;
inline bool ClipNodeData::has_transform_id() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClipNodeData::set_has_transform_id() {
_has_bits_[0] |= 0x00000008u;
}
inline void ClipNodeData::clear_has_transform_id() {
_has_bits_[0] &= ~0x00000008u;
}
inline void ClipNodeData::clear_transform_id() {
transform_id_ = GOOGLE_LONGLONG(0);
clear_has_transform_id();
}
inline ::google::protobuf::int64 ClipNodeData::transform_id() const {
// @@protoc_insertion_point(field_get:cc.proto.ClipNodeData.transform_id)
return transform_id_;
}
inline void ClipNodeData::set_transform_id(::google::protobuf::int64 value) {
set_has_transform_id();
transform_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ClipNodeData.transform_id)
}

// optional int64 target_transform_id = 5;
inline bool ClipNodeData::has_target_transform_id() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClipNodeData::set_has_target_transform_id() {
_has_bits_[0] |= 0x00000010u;
}
inline void ClipNodeData::clear_has_target_transform_id() {
_has_bits_[0] &= ~0x00000010u;
}
inline void ClipNodeData::clear_target_transform_id() {
target_transform_id_ = GOOGLE_LONGLONG(0);
clear_has_target_transform_id();
}
inline ::google::protobuf::int64 ClipNodeData::target_transform_id() const {
// @@protoc_insertion_point(field_get:cc.proto.ClipNodeData.target_transform_id)
return target_transform_id_;
}
inline void ClipNodeData::set_target_transform_id(::google::protobuf::int64 value) {
set_has_target_transform_id();
target_transform_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ClipNodeData.target_transform_id)
}

// optional int64 target_effect_id = 12;
inline bool ClipNodeData::has_target_effect_id() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClipNodeData::set_has_target_effect_id() {
_has_bits_[0] |= 0x00000020u;
}
inline void ClipNodeData::clear_has_target_effect_id() {
_has_bits_[0] &= ~0x00000020u;
}
inline void ClipNodeData::clear_target_effect_id() {
target_effect_id_ = GOOGLE_LONGLONG(0);
clear_has_target_effect_id();
}
inline ::google::protobuf::int64 ClipNodeData::target_effect_id() const {
// @@protoc_insertion_point(field_get:cc.proto.ClipNodeData.target_effect_id)
return target_effect_id_;
}
inline void ClipNodeData::set_target_effect_id(::google::protobuf::int64 value) {
set_has_target_effect_id();
target_effect_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ClipNodeData.target_effect_id)
}

// optional bool applies_local_clip = 6;
inline bool ClipNodeData::has_applies_local_clip() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClipNodeData::set_has_applies_local_clip() {
_has_bits_[0] |= 0x00000040u;
}
inline void ClipNodeData::clear_has_applies_local_clip() {
_has_bits_[0] &= ~0x00000040u;
}
inline void ClipNodeData::clear_applies_local_clip() {
applies_local_clip_ = false;
clear_has_applies_local_clip();
}
inline bool ClipNodeData::applies_local_clip() const {
// @@protoc_insertion_point(field_get:cc.proto.ClipNodeData.applies_local_clip)
return applies_local_clip_;
}
inline void ClipNodeData::set_applies_local_clip(bool value) {
set_has_applies_local_clip();
applies_local_clip_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ClipNodeData.applies_local_clip)
}

// optional bool layer_clipping_uses_only_local_clip = 7;
inline bool ClipNodeData::has_layer_clipping_uses_only_local_clip() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClipNodeData::set_has_layer_clipping_uses_only_local_clip() {
_has_bits_[0] |= 0x00000080u;
}
inline void ClipNodeData::clear_has_layer_clipping_uses_only_local_clip() {
_has_bits_[0] &= ~0x00000080u;
}
inline void ClipNodeData::clear_layer_clipping_uses_only_local_clip() {
layer_clipping_uses_only_local_clip_ = false;
clear_has_layer_clipping_uses_only_local_clip();
}
inline bool ClipNodeData::layer_clipping_uses_only_local_clip() const {
// @@protoc_insertion_point(field_get:cc.proto.ClipNodeData.layer_clipping_uses_only_local_clip)
return layer_clipping_uses_only_local_clip_;
}
inline void ClipNodeData::set_layer_clipping_uses_only_local_clip(bool value) {
set_has_layer_clipping_uses_only_local_clip();
layer_clipping_uses_only_local_clip_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ClipNodeData.layer_clipping_uses_only_local_clip)
}

// optional bool target_is_clipped = 8;
inline bool ClipNodeData::has_target_is_clipped() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClipNodeData::set_has_target_is_clipped() {
_has_bits_[0] |= 0x00000100u;
}
inline void ClipNodeData::clear_has_target_is_clipped() {
_has_bits_[0] &= ~0x00000100u;
}
inline void ClipNodeData::clear_target_is_clipped() {
target_is_clipped_ = false;
clear_has_target_is_clipped();
}
inline bool ClipNodeData::target_is_clipped() const {
// @@protoc_insertion_point(field_get:cc.proto.ClipNodeData.target_is_clipped)
return target_is_clipped_;
}
inline void ClipNodeData::set_target_is_clipped(bool value) {
set_has_target_is_clipped();
target_is_clipped_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ClipNodeData.target_is_clipped)
}

// optional bool layers_are_clipped = 9;
inline bool ClipNodeData::has_layers_are_clipped() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClipNodeData::set_has_layers_are_clipped() {
_has_bits_[0] |= 0x00000200u;
}
inline void ClipNodeData::clear_has_layers_are_clipped() {
_has_bits_[0] &= ~0x00000200u;
}
inline void ClipNodeData::clear_layers_are_clipped() {
layers_are_clipped_ = false;
clear_has_layers_are_clipped();
}
inline bool ClipNodeData::layers_are_clipped() const {
// @@protoc_insertion_point(field_get:cc.proto.ClipNodeData.layers_are_clipped)
return layers_are_clipped_;
}
inline void ClipNodeData::set_layers_are_clipped(bool value) {
set_has_layers_are_clipped();
layers_are_clipped_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ClipNodeData.layers_are_clipped)
}

// optional bool layers_are_clipped_when_surfaces_disabled = 10;
inline bool ClipNodeData::has_layers_are_clipped_when_surfaces_disabled() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClipNodeData::set_has_layers_are_clipped_when_surfaces_disabled() {
_has_bits_[0] |= 0x00000400u;
}
inline void ClipNodeData::clear_has_layers_are_clipped_when_surfaces_disabled() {
_has_bits_[0] &= ~0x00000400u;
}
inline void ClipNodeData::clear_layers_are_clipped_when_surfaces_disabled() {
layers_are_clipped_when_surfaces_disabled_ = false;
clear_has_layers_are_clipped_when_surfaces_disabled();
}
inline bool ClipNodeData::layers_are_clipped_when_surfaces_disabled() const {
// @@protoc_insertion_point(field_get:cc.proto.ClipNodeData.layers_are_clipped_when_surfaces_disabled)
return layers_are_clipped_when_surfaces_disabled_;
}
inline void ClipNodeData::set_layers_are_clipped_when_surfaces_disabled(bool value) {
set_has_layers_are_clipped_when_surfaces_disabled();
layers_are_clipped_when_surfaces_disabled_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ClipNodeData.layers_are_clipped_when_surfaces_disabled)
}

// optional bool resets_clip = 11;
inline bool ClipNodeData::has_resets_clip() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClipNodeData::set_has_resets_clip() {
_has_bits_[0] |= 0x00000800u;
}
inline void ClipNodeData::clear_has_resets_clip() {
_has_bits_[0] &= ~0x00000800u;
}
inline void ClipNodeData::clear_resets_clip() {
resets_clip_ = false;
clear_has_resets_clip();
}
inline bool ClipNodeData::resets_clip() const {
// @@protoc_insertion_point(field_get:cc.proto.ClipNodeData.resets_clip)
return resets_clip_;
}
inline void ClipNodeData::set_resets_clip(bool value) {
set_has_resets_clip();
resets_clip_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ClipNodeData.resets_clip)
}

// -------------------------------------------------------------------

// EffectNodeData

// optional float opacity = 1;
inline bool EffectNodeData::has_opacity() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EffectNodeData::set_has_opacity() {
_has_bits_[0] |= 0x00000001u;
}
inline void EffectNodeData::clear_has_opacity() {
_has_bits_[0] &= ~0x00000001u;
}
inline void EffectNodeData::clear_opacity() {
opacity_ = 0;
clear_has_opacity();
}
inline float EffectNodeData::opacity() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.opacity)
return opacity_;
}
inline void EffectNodeData::set_opacity(float value) {
set_has_opacity();
opacity_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.opacity)
}

// optional float screen_space_opacity = 2;
inline bool EffectNodeData::has_screen_space_opacity() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EffectNodeData::set_has_screen_space_opacity() {
_has_bits_[0] |= 0x00000002u;
}
inline void EffectNodeData::clear_has_screen_space_opacity() {
_has_bits_[0] &= ~0x00000002u;
}
inline void EffectNodeData::clear_screen_space_opacity() {
screen_space_opacity_ = 0;
clear_has_screen_space_opacity();
}
inline float EffectNodeData::screen_space_opacity() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.screen_space_opacity)
return screen_space_opacity_;
}
inline void EffectNodeData::set_screen_space_opacity(float value) {
set_has_screen_space_opacity();
screen_space_opacity_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.screen_space_opacity)
}

// optional .cc.proto.SkXfermode.Mode blend_mode = 25;
inline bool EffectNodeData::has_blend_mode() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EffectNodeData::set_has_blend_mode() {
_has_bits_[0] |= 0x00000004u;
}
inline void EffectNodeData::clear_has_blend_mode() {
_has_bits_[0] &= ~0x00000004u;
}
inline void EffectNodeData::clear_blend_mode() {
blend_mode_ = 0;
clear_has_blend_mode();
}
inline ::cc::proto::SkXfermode_Mode EffectNodeData::blend_mode() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.blend_mode)
return static_cast< ::cc::proto::SkXfermode_Mode >(blend_mode_);
}
inline void EffectNodeData::set_blend_mode(::cc::proto::SkXfermode_Mode value) {
assert(::cc::proto::SkXfermode_Mode_IsValid(value));
set_has_blend_mode();
blend_mode_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.blend_mode)
}

// optional .cc.proto.Size unscaled_mask_target_size = 26;
inline bool EffectNodeData::has_unscaled_mask_target_size() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EffectNodeData::set_has_unscaled_mask_target_size() {
_has_bits_[0] |= 0x00000008u;
}
inline void EffectNodeData::clear_has_unscaled_mask_target_size() {
_has_bits_[0] &= ~0x00000008u;
}
inline void EffectNodeData::clear_unscaled_mask_target_size() {
if (unscaled_mask_target_size_ != NULL) unscaled_mask_target_size_->::cc::proto::Size::Clear();
clear_has_unscaled_mask_target_size();
}
inline const ::cc::proto::Size& EffectNodeData::unscaled_mask_target_size() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.unscaled_mask_target_size)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return unscaled_mask_target_size_ != NULL ? *unscaled_mask_target_size_ : *default_instance().unscaled_mask_target_size_;
#else
return unscaled_mask_target_size_ != NULL ? *unscaled_mask_target_size_ : *default_instance_->unscaled_mask_target_size_;
#endif
}
inline ::cc::proto::Size* EffectNodeData::mutable_unscaled_mask_target_size() {
set_has_unscaled_mask_target_size();
if (unscaled_mask_target_size_ == NULL) {
unscaled_mask_target_size_ = new ::cc::proto::Size;
}
// @@protoc_insertion_point(field_mutable:cc.proto.EffectNodeData.unscaled_mask_target_size)
return unscaled_mask_target_size_;
}
inline ::cc::proto::Size* EffectNodeData::release_unscaled_mask_target_size() {
// @@protoc_insertion_point(field_release:cc.proto.EffectNodeData.unscaled_mask_target_size)
clear_has_unscaled_mask_target_size();
::cc::proto::Size* temp = unscaled_mask_target_size_;
unscaled_mask_target_size_ = NULL;
return temp;
}
inline void EffectNodeData::set_allocated_unscaled_mask_target_size(::cc::proto::Size* unscaled_mask_target_size) {
delete unscaled_mask_target_size_;
unscaled_mask_target_size_ = unscaled_mask_target_size;
if (unscaled_mask_target_size) {
set_has_unscaled_mask_target_size();
} else {
clear_has_unscaled_mask_target_size();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.EffectNodeData.unscaled_mask_target_size)
}

// optional bool has_render_surface = 3;
inline bool EffectNodeData::has_has_render_surface() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EffectNodeData::set_has_has_render_surface() {
_has_bits_[0] |= 0x00000010u;
}
inline void EffectNodeData::clear_has_has_render_surface() {
_has_bits_[0] &= ~0x00000010u;
}
inline void EffectNodeData::clear_has_render_surface() {
has_render_surface_ = false;
clear_has_has_render_surface();
}
inline bool EffectNodeData::has_render_surface() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.has_render_surface)
return has_render_surface_;
}
inline void EffectNodeData::set_has_render_surface(bool value) {
set_has_has_render_surface();
has_render_surface_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.has_render_surface)
}

// optional bool has_copy_request = 4;
inline bool EffectNodeData::has_has_copy_request() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EffectNodeData::set_has_has_copy_request() {
_has_bits_[0] |= 0x00000020u;
}
inline void EffectNodeData::clear_has_has_copy_request() {
_has_bits_[0] &= ~0x00000020u;
}
inline void EffectNodeData::clear_has_copy_request() {
has_copy_request_ = false;
clear_has_has_copy_request();
}
inline bool EffectNodeData::has_copy_request() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.has_copy_request)
return has_copy_request_;
}
inline void EffectNodeData::set_has_copy_request(bool value) {
set_has_has_copy_request();
has_copy_request_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.has_copy_request)
}

// optional bool hidden_by_backface_visibility = 14;
inline bool EffectNodeData::has_hidden_by_backface_visibility() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EffectNodeData::set_has_hidden_by_backface_visibility() {
_has_bits_[0] |= 0x00000040u;
}
inline void EffectNodeData::clear_has_hidden_by_backface_visibility() {
_has_bits_[0] &= ~0x00000040u;
}
inline void EffectNodeData::clear_hidden_by_backface_visibility() {
hidden_by_backface_visibility_ = false;
clear_has_hidden_by_backface_visibility();
}
inline bool EffectNodeData::hidden_by_backface_visibility() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.hidden_by_backface_visibility)
return hidden_by_backface_visibility_;
}
inline void EffectNodeData::set_hidden_by_backface_visibility(bool value) {
set_has_hidden_by_backface_visibility();
hidden_by_backface_visibility_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.hidden_by_backface_visibility)
}

// optional bool double_sided = 13;
inline bool EffectNodeData::has_double_sided() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EffectNodeData::set_has_double_sided() {
_has_bits_[0] |= 0x00000080u;
}
inline void EffectNodeData::clear_has_double_sided() {
_has_bits_[0] &= ~0x00000080u;
}
inline void EffectNodeData::clear_double_sided() {
double_sided_ = false;
clear_has_double_sided();
}
inline bool EffectNodeData::double_sided() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.double_sided)
return double_sided_;
}
inline void EffectNodeData::set_double_sided(bool value) {
set_has_double_sided();
double_sided_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.double_sided)
}

// optional bool is_drawn = 6;
inline bool EffectNodeData::has_is_drawn() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EffectNodeData::set_has_is_drawn() {
_has_bits_[0] |= 0x00000100u;
}
inline void EffectNodeData::clear_has_is_drawn() {
_has_bits_[0] &= ~0x00000100u;
}
inline void EffectNodeData::clear_is_drawn() {
is_drawn_ = false;
clear_has_is_drawn();
}
inline bool EffectNodeData::is_drawn() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.is_drawn)
return is_drawn_;
}
inline void EffectNodeData::set_is_drawn(bool value) {
set_has_is_drawn();
is_drawn_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.is_drawn)
}

// optional bool subtree_hidden = 15;
inline bool EffectNodeData::has_subtree_hidden() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EffectNodeData::set_has_subtree_hidden() {
_has_bits_[0] |= 0x00000200u;
}
inline void EffectNodeData::clear_has_subtree_hidden() {
_has_bits_[0] &= ~0x00000200u;
}
inline void EffectNodeData::clear_subtree_hidden() {
subtree_hidden_ = false;
clear_has_subtree_hidden();
}
inline bool EffectNodeData::subtree_hidden() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.subtree_hidden)
return subtree_hidden_;
}
inline void EffectNodeData::set_subtree_hidden(bool value) {
set_has_subtree_hidden();
subtree_hidden_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.subtree_hidden)
}

// optional bool has_potential_filter_animation = 21;
inline bool EffectNodeData::has_has_potential_filter_animation() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EffectNodeData::set_has_has_potential_filter_animation() {
_has_bits_[0] |= 0x00000400u;
}
inline void EffectNodeData::clear_has_has_potential_filter_animation() {
_has_bits_[0] &= ~0x00000400u;
}
inline void EffectNodeData::clear_has_potential_filter_animation() {
has_potential_filter_animation_ = false;
clear_has_has_potential_filter_animation();
}
inline bool EffectNodeData::has_potential_filter_animation() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.has_potential_filter_animation)
return has_potential_filter_animation_;
}
inline void EffectNodeData::set_has_potential_filter_animation(bool value) {
set_has_has_potential_filter_animation();
has_potential_filter_animation_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.has_potential_filter_animation)
}

// optional bool has_potential_opacity_animation = 7;
inline bool EffectNodeData::has_has_potential_opacity_animation() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EffectNodeData::set_has_has_potential_opacity_animation() {
_has_bits_[0] |= 0x00000800u;
}
inline void EffectNodeData::clear_has_has_potential_opacity_animation() {
_has_bits_[0] &= ~0x00000800u;
}
inline void EffectNodeData::clear_has_potential_opacity_animation() {
has_potential_opacity_animation_ = false;
clear_has_has_potential_opacity_animation();
}
inline bool EffectNodeData::has_potential_opacity_animation() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.has_potential_opacity_animation)
return has_potential_opacity_animation_;
}
inline void EffectNodeData::set_has_potential_opacity_animation(bool value) {
set_has_has_potential_opacity_animation();
has_potential_opacity_animation_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.has_potential_opacity_animation)
}

// optional bool is_currently_animating_filter = 22;
inline bool EffectNodeData::has_is_currently_animating_filter() const {
return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EffectNodeData::set_has_is_currently_animating_filter() {
_has_bits_[0] |= 0x00001000u;
}
inline void EffectNodeData::clear_has_is_currently_animating_filter() {
_has_bits_[0] &= ~0x00001000u;
}
inline void EffectNodeData::clear_is_currently_animating_filter() {
is_currently_animating_filter_ = false;
clear_has_is_currently_animating_filter();
}
inline bool EffectNodeData::is_currently_animating_filter() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.is_currently_animating_filter)
return is_currently_animating_filter_;
}
inline void EffectNodeData::set_is_currently_animating_filter(bool value) {
set_has_is_currently_animating_filter();
is_currently_animating_filter_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.is_currently_animating_filter)
}

// optional bool is_currently_animating_opacity = 16;
inline bool EffectNodeData::has_is_currently_animating_opacity() const {
return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EffectNodeData::set_has_is_currently_animating_opacity() {
_has_bits_[0] |= 0x00002000u;
}
inline void EffectNodeData::clear_has_is_currently_animating_opacity() {
_has_bits_[0] &= ~0x00002000u;
}
inline void EffectNodeData::clear_is_currently_animating_opacity() {
is_currently_animating_opacity_ = false;
clear_has_is_currently_animating_opacity();
}
inline bool EffectNodeData::is_currently_animating_opacity() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.is_currently_animating_opacity)
return is_currently_animating_opacity_;
}
inline void EffectNodeData::set_is_currently_animating_opacity(bool value) {
set_has_is_currently_animating_opacity();
is_currently_animating_opacity_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.is_currently_animating_opacity)
}

// optional bool effect_changed = 11;
inline bool EffectNodeData::has_effect_changed() const {
return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EffectNodeData::set_has_effect_changed() {
_has_bits_[0] |= 0x00004000u;
}
inline void EffectNodeData::clear_has_effect_changed() {
_has_bits_[0] &= ~0x00004000u;
}
inline void EffectNodeData::clear_effect_changed() {
effect_changed_ = false;
clear_has_effect_changed();
}
inline bool EffectNodeData::effect_changed() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.effect_changed)
return effect_changed_;
}
inline void EffectNodeData::set_effect_changed(bool value) {
set_has_effect_changed();
effect_changed_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.effect_changed)
}

// optional int64 num_copy_requests_in_subtree = 8;
inline bool EffectNodeData::has_num_copy_requests_in_subtree() const {
return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void EffectNodeData::set_has_num_copy_requests_in_subtree() {
_has_bits_[0] |= 0x00008000u;
}
inline void EffectNodeData::clear_has_num_copy_requests_in_subtree() {
_has_bits_[0] &= ~0x00008000u;
}
inline void EffectNodeData::clear_num_copy_requests_in_subtree() {
num_copy_requests_in_subtree_ = GOOGLE_LONGLONG(0);
clear_has_num_copy_requests_in_subtree();
}
inline ::google::protobuf::int64 EffectNodeData::num_copy_requests_in_subtree() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.num_copy_requests_in_subtree)
return num_copy_requests_in_subtree_;
}
inline void EffectNodeData::set_num_copy_requests_in_subtree(::google::protobuf::int64 value) {
set_has_num_copy_requests_in_subtree();
num_copy_requests_in_subtree_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.num_copy_requests_in_subtree)
}

// optional int64 transform_id = 9;
inline bool EffectNodeData::has_transform_id() const {
return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void EffectNodeData::set_has_transform_id() {
_has_bits_[0] |= 0x00010000u;
}
inline void EffectNodeData::clear_has_transform_id() {
_has_bits_[0] &= ~0x00010000u;
}
inline void EffectNodeData::clear_transform_id() {
transform_id_ = GOOGLE_LONGLONG(0);
clear_has_transform_id();
}
inline ::google::protobuf::int64 EffectNodeData::transform_id() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.transform_id)
return transform_id_;
}
inline void EffectNodeData::set_transform_id(::google::protobuf::int64 value) {
set_has_transform_id();
transform_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.transform_id)
}

// optional int64 clip_id = 10;
inline bool EffectNodeData::has_clip_id() const {
return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void EffectNodeData::set_has_clip_id() {
_has_bits_[0] |= 0x00020000u;
}
inline void EffectNodeData::clear_has_clip_id() {
_has_bits_[0] &= ~0x00020000u;
}
inline void EffectNodeData::clear_clip_id() {
clip_id_ = GOOGLE_LONGLONG(0);
clear_has_clip_id();
}
inline ::google::protobuf::int64 EffectNodeData::clip_id() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.clip_id)
return clip_id_;
}
inline void EffectNodeData::set_clip_id(::google::protobuf::int64 value) {
set_has_clip_id();
clip_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.clip_id)
}

// optional int64 target_id = 12;
inline bool EffectNodeData::has_target_id() const {
return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void EffectNodeData::set_has_target_id() {
_has_bits_[0] |= 0x00040000u;
}
inline void EffectNodeData::clear_has_target_id() {
_has_bits_[0] &= ~0x00040000u;
}
inline void EffectNodeData::clear_target_id() {
target_id_ = GOOGLE_LONGLONG(0);
clear_has_target_id();
}
inline ::google::protobuf::int64 EffectNodeData::target_id() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.target_id)
return target_id_;
}
inline void EffectNodeData::set_target_id(::google::protobuf::int64 value) {
set_has_target_id();
target_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.target_id)
}

// optional int64 mask_layer_id = 17;
inline bool EffectNodeData::has_mask_layer_id() const {
return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void EffectNodeData::set_has_mask_layer_id() {
_has_bits_[0] |= 0x00080000u;
}
inline void EffectNodeData::clear_has_mask_layer_id() {
_has_bits_[0] &= ~0x00080000u;
}
inline void EffectNodeData::clear_mask_layer_id() {
mask_layer_id_ = GOOGLE_LONGLONG(0);
clear_has_mask_layer_id();
}
inline ::google::protobuf::int64 EffectNodeData::mask_layer_id() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.mask_layer_id)
return mask_layer_id_;
}
inline void EffectNodeData::set_mask_layer_id(::google::protobuf::int64 value) {
set_has_mask_layer_id();
mask_layer_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.mask_layer_id)
}

// optional int64 replica_layer_id = 18;
inline bool EffectNodeData::has_replica_layer_id() const {
return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void EffectNodeData::set_has_replica_layer_id() {
_has_bits_[0] |= 0x00100000u;
}
inline void EffectNodeData::clear_has_replica_layer_id() {
_has_bits_[0] &= ~0x00100000u;
}
inline void EffectNodeData::clear_replica_layer_id() {
replica_layer_id_ = GOOGLE_LONGLONG(0);
clear_has_replica_layer_id();
}
inline ::google::protobuf::int64 EffectNodeData::replica_layer_id() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.replica_layer_id)
return replica_layer_id_;
}
inline void EffectNodeData::set_replica_layer_id(::google::protobuf::int64 value) {
set_has_replica_layer_id();
replica_layer_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.replica_layer_id)
}

// optional int64 replica_mask_layer_id = 19;
inline bool EffectNodeData::has_replica_mask_layer_id() const {
return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void EffectNodeData::set_has_replica_mask_layer_id() {
_has_bits_[0] |= 0x00200000u;
}
inline void EffectNodeData::clear_has_replica_mask_layer_id() {
_has_bits_[0] &= ~0x00200000u;
}
inline void EffectNodeData::clear_replica_mask_layer_id() {
replica_mask_layer_id_ = GOOGLE_LONGLONG(0);
clear_has_replica_mask_layer_id();
}
inline ::google::protobuf::int64 EffectNodeData::replica_mask_layer_id() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.replica_mask_layer_id)
return replica_mask_layer_id_;
}
inline void EffectNodeData::set_replica_mask_layer_id(::google::protobuf::int64 value) {
set_has_replica_mask_layer_id();
replica_mask_layer_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.EffectNodeData.replica_mask_layer_id)
}

// optional .cc.proto.Vector2dF surface_contents_scale = 20;
inline bool EffectNodeData::has_surface_contents_scale() const {
return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void EffectNodeData::set_has_surface_contents_scale() {
_has_bits_[0] |= 0x00400000u;
}
inline void EffectNodeData::clear_has_surface_contents_scale() {
_has_bits_[0] &= ~0x00400000u;
}
inline void EffectNodeData::clear_surface_contents_scale() {
if (surface_contents_scale_ != NULL) surface_contents_scale_->::cc::proto::Vector2dF::Clear();
clear_has_surface_contents_scale();
}
inline const ::cc::proto::Vector2dF& EffectNodeData::surface_contents_scale() const {
// @@protoc_insertion_point(field_get:cc.proto.EffectNodeData.surface_contents_scale)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return surface_contents_scale_ != NULL ? *surface_contents_scale_ : *default_instance().surface_contents_scale_;
#else
return surface_contents_scale_ != NULL ? *surface_contents_scale_ : *default_instance_->surface_contents_scale_;
#endif
}
inline ::cc::proto::Vector2dF* EffectNodeData::mutable_surface_contents_scale() {
set_has_surface_contents_scale();
if (surface_contents_scale_ == NULL) {
surface_contents_scale_ = new ::cc::proto::Vector2dF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.EffectNodeData.surface_contents_scale)
return surface_contents_scale_;
}
inline ::cc::proto::Vector2dF* EffectNodeData::release_surface_contents_scale() {
// @@protoc_insertion_point(field_release:cc.proto.EffectNodeData.surface_contents_scale)
clear_has_surface_contents_scale();
::cc::proto::Vector2dF* temp = surface_contents_scale_;
surface_contents_scale_ = NULL;
return temp;
}
inline void EffectNodeData::set_allocated_surface_contents_scale(::cc::proto::Vector2dF* surface_contents_scale) {
delete surface_contents_scale_;
surface_contents_scale_ = surface_contents_scale;
if (surface_contents_scale) {
set_has_surface_contents_scale();
} else {
clear_has_surface_contents_scale();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.EffectNodeData.surface_contents_scale)
}

// -------------------------------------------------------------------

// ScrollNodeData

// optional bool scrollable = 1;
inline bool ScrollNodeData::has_scrollable() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScrollNodeData::set_has_scrollable() {
_has_bits_[0] |= 0x00000001u;
}
inline void ScrollNodeData::clear_has_scrollable() {
_has_bits_[0] &= ~0x00000001u;
}
inline void ScrollNodeData::clear_scrollable() {
scrollable_ = false;
clear_has_scrollable();
}
inline bool ScrollNodeData::scrollable() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.scrollable)
return scrollable_;
}
inline void ScrollNodeData::set_scrollable(bool value) {
set_has_scrollable();
scrollable_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollNodeData.scrollable)
}

// optional int32 main_thread_scrolling_reasons = 2;
inline bool ScrollNodeData::has_main_thread_scrolling_reasons() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScrollNodeData::set_has_main_thread_scrolling_reasons() {
_has_bits_[0] |= 0x00000002u;
}
inline void ScrollNodeData::clear_has_main_thread_scrolling_reasons() {
_has_bits_[0] &= ~0x00000002u;
}
inline void ScrollNodeData::clear_main_thread_scrolling_reasons() {
main_thread_scrolling_reasons_ = 0;
clear_has_main_thread_scrolling_reasons();
}
inline ::google::protobuf::int32 ScrollNodeData::main_thread_scrolling_reasons() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.main_thread_scrolling_reasons)
return main_thread_scrolling_reasons_;
}
inline void ScrollNodeData::set_main_thread_scrolling_reasons(::google::protobuf::int32 value) {
set_has_main_thread_scrolling_reasons();
main_thread_scrolling_reasons_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollNodeData.main_thread_scrolling_reasons)
}

// optional bool contains_non_fast_scrollable_region = 3;
inline bool ScrollNodeData::has_contains_non_fast_scrollable_region() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScrollNodeData::set_has_contains_non_fast_scrollable_region() {
_has_bits_[0] |= 0x00000004u;
}
inline void ScrollNodeData::clear_has_contains_non_fast_scrollable_region() {
_has_bits_[0] &= ~0x00000004u;
}
inline void ScrollNodeData::clear_contains_non_fast_scrollable_region() {
contains_non_fast_scrollable_region_ = false;
clear_has_contains_non_fast_scrollable_region();
}
inline bool ScrollNodeData::contains_non_fast_scrollable_region() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.contains_non_fast_scrollable_region)
return contains_non_fast_scrollable_region_;
}
inline void ScrollNodeData::set_contains_non_fast_scrollable_region(bool value) {
set_has_contains_non_fast_scrollable_region();
contains_non_fast_scrollable_region_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollNodeData.contains_non_fast_scrollable_region)
}

// optional .cc.proto.Size scroll_clip_layer_bounds = 4;
inline bool ScrollNodeData::has_scroll_clip_layer_bounds() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScrollNodeData::set_has_scroll_clip_layer_bounds() {
_has_bits_[0] |= 0x00000008u;
}
inline void ScrollNodeData::clear_has_scroll_clip_layer_bounds() {
_has_bits_[0] &= ~0x00000008u;
}
inline void ScrollNodeData::clear_scroll_clip_layer_bounds() {
if (scroll_clip_layer_bounds_ != NULL) scroll_clip_layer_bounds_->::cc::proto::Size::Clear();
clear_has_scroll_clip_layer_bounds();
}
inline const ::cc::proto::Size& ScrollNodeData::scroll_clip_layer_bounds() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.scroll_clip_layer_bounds)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return scroll_clip_layer_bounds_ != NULL ? *scroll_clip_layer_bounds_ : *default_instance().scroll_clip_layer_bounds_;
#else
return scroll_clip_layer_bounds_ != NULL ? *scroll_clip_layer_bounds_ : *default_instance_->scroll_clip_layer_bounds_;
#endif
}
inline ::cc::proto::Size* ScrollNodeData::mutable_scroll_clip_layer_bounds() {
set_has_scroll_clip_layer_bounds();
if (scroll_clip_layer_bounds_ == NULL) {
scroll_clip_layer_bounds_ = new ::cc::proto::Size;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollNodeData.scroll_clip_layer_bounds)
return scroll_clip_layer_bounds_;
}
inline ::cc::proto::Size* ScrollNodeData::release_scroll_clip_layer_bounds() {
// @@protoc_insertion_point(field_release:cc.proto.ScrollNodeData.scroll_clip_layer_bounds)
clear_has_scroll_clip_layer_bounds();
::cc::proto::Size* temp = scroll_clip_layer_bounds_;
scroll_clip_layer_bounds_ = NULL;
return temp;
}
inline void ScrollNodeData::set_allocated_scroll_clip_layer_bounds(::cc::proto::Size* scroll_clip_layer_bounds) {
delete scroll_clip_layer_bounds_;
scroll_clip_layer_bounds_ = scroll_clip_layer_bounds;
if (scroll_clip_layer_bounds) {
set_has_scroll_clip_layer_bounds();
} else {
clear_has_scroll_clip_layer_bounds();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollNodeData.scroll_clip_layer_bounds)
}

// optional .cc.proto.Size bounds = 5;
inline bool ScrollNodeData::has_bounds() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScrollNodeData::set_has_bounds() {
_has_bits_[0] |= 0x00000010u;
}
inline void ScrollNodeData::clear_has_bounds() {
_has_bits_[0] &= ~0x00000010u;
}
inline void ScrollNodeData::clear_bounds() {
if (bounds_ != NULL) bounds_->::cc::proto::Size::Clear();
clear_has_bounds();
}
inline const ::cc::proto::Size& ScrollNodeData::bounds() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.bounds)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return bounds_ != NULL ? *bounds_ : *default_instance().bounds_;
#else
return bounds_ != NULL ? *bounds_ : *default_instance_->bounds_;
#endif
}
inline ::cc::proto::Size* ScrollNodeData::mutable_bounds() {
set_has_bounds();
if (bounds_ == NULL) {
bounds_ = new ::cc::proto::Size;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollNodeData.bounds)
return bounds_;
}
inline ::cc::proto::Size* ScrollNodeData::release_bounds() {
// @@protoc_insertion_point(field_release:cc.proto.ScrollNodeData.bounds)
clear_has_bounds();
::cc::proto::Size* temp = bounds_;
bounds_ = NULL;
return temp;
}
inline void ScrollNodeData::set_allocated_bounds(::cc::proto::Size* bounds) {
delete bounds_;
bounds_ = bounds;
if (bounds) {
set_has_bounds();
} else {
clear_has_bounds();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollNodeData.bounds)
}

// optional bool max_scroll_offset_affected_by_page_scale = 6;
inline bool ScrollNodeData::has_max_scroll_offset_affected_by_page_scale() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScrollNodeData::set_has_max_scroll_offset_affected_by_page_scale() {
_has_bits_[0] |= 0x00000020u;
}
inline void ScrollNodeData::clear_has_max_scroll_offset_affected_by_page_scale() {
_has_bits_[0] &= ~0x00000020u;
}
inline void ScrollNodeData::clear_max_scroll_offset_affected_by_page_scale() {
max_scroll_offset_affected_by_page_scale_ = false;
clear_has_max_scroll_offset_affected_by_page_scale();
}
inline bool ScrollNodeData::max_scroll_offset_affected_by_page_scale() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.max_scroll_offset_affected_by_page_scale)
return max_scroll_offset_affected_by_page_scale_;
}
inline void ScrollNodeData::set_max_scroll_offset_affected_by_page_scale(bool value) {
set_has_max_scroll_offset_affected_by_page_scale();
max_scroll_offset_affected_by_page_scale_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollNodeData.max_scroll_offset_affected_by_page_scale)
}

// optional bool is_inner_viewport_scroll_layer = 7;
inline bool ScrollNodeData::has_is_inner_viewport_scroll_layer() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScrollNodeData::set_has_is_inner_viewport_scroll_layer() {
_has_bits_[0] |= 0x00000040u;
}
inline void ScrollNodeData::clear_has_is_inner_viewport_scroll_layer() {
_has_bits_[0] &= ~0x00000040u;
}
inline void ScrollNodeData::clear_is_inner_viewport_scroll_layer() {
is_inner_viewport_scroll_layer_ = false;
clear_has_is_inner_viewport_scroll_layer();
}
inline bool ScrollNodeData::is_inner_viewport_scroll_layer() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.is_inner_viewport_scroll_layer)
return is_inner_viewport_scroll_layer_;
}
inline void ScrollNodeData::set_is_inner_viewport_scroll_layer(bool value) {
set_has_is_inner_viewport_scroll_layer();
is_inner_viewport_scroll_layer_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollNodeData.is_inner_viewport_scroll_layer)
}

// optional bool is_outer_viewport_scroll_layer = 8;
inline bool ScrollNodeData::has_is_outer_viewport_scroll_layer() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ScrollNodeData::set_has_is_outer_viewport_scroll_layer() {
_has_bits_[0] |= 0x00000080u;
}
inline void ScrollNodeData::clear_has_is_outer_viewport_scroll_layer() {
_has_bits_[0] &= ~0x00000080u;
}
inline void ScrollNodeData::clear_is_outer_viewport_scroll_layer() {
is_outer_viewport_scroll_layer_ = false;
clear_has_is_outer_viewport_scroll_layer();
}
inline bool ScrollNodeData::is_outer_viewport_scroll_layer() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.is_outer_viewport_scroll_layer)
return is_outer_viewport_scroll_layer_;
}
inline void ScrollNodeData::set_is_outer_viewport_scroll_layer(bool value) {
set_has_is_outer_viewport_scroll_layer();
is_outer_viewport_scroll_layer_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollNodeData.is_outer_viewport_scroll_layer)
}

// optional .cc.proto.Vector2dF offset_to_transform_parent = 9;
inline bool ScrollNodeData::has_offset_to_transform_parent() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ScrollNodeData::set_has_offset_to_transform_parent() {
_has_bits_[0] |= 0x00000100u;
}
inline void ScrollNodeData::clear_has_offset_to_transform_parent() {
_has_bits_[0] &= ~0x00000100u;
}
inline void ScrollNodeData::clear_offset_to_transform_parent() {
if (offset_to_transform_parent_ != NULL) offset_to_transform_parent_->::cc::proto::Vector2dF::Clear();
clear_has_offset_to_transform_parent();
}
inline const ::cc::proto::Vector2dF& ScrollNodeData::offset_to_transform_parent() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.offset_to_transform_parent)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return offset_to_transform_parent_ != NULL ? *offset_to_transform_parent_ : *default_instance().offset_to_transform_parent_;
#else
return offset_to_transform_parent_ != NULL ? *offset_to_transform_parent_ : *default_instance_->offset_to_transform_parent_;
#endif
}
inline ::cc::proto::Vector2dF* ScrollNodeData::mutable_offset_to_transform_parent() {
set_has_offset_to_transform_parent();
if (offset_to_transform_parent_ == NULL) {
offset_to_transform_parent_ = new ::cc::proto::Vector2dF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollNodeData.offset_to_transform_parent)
return offset_to_transform_parent_;
}
inline ::cc::proto::Vector2dF* ScrollNodeData::release_offset_to_transform_parent() {
// @@protoc_insertion_point(field_release:cc.proto.ScrollNodeData.offset_to_transform_parent)
clear_has_offset_to_transform_parent();
::cc::proto::Vector2dF* temp = offset_to_transform_parent_;
offset_to_transform_parent_ = NULL;
return temp;
}
inline void ScrollNodeData::set_allocated_offset_to_transform_parent(::cc::proto::Vector2dF* offset_to_transform_parent) {
delete offset_to_transform_parent_;
offset_to_transform_parent_ = offset_to_transform_parent;
if (offset_to_transform_parent) {
set_has_offset_to_transform_parent();
} else {
clear_has_offset_to_transform_parent();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollNodeData.offset_to_transform_parent)
}

// optional bool should_flatten = 10;
inline bool ScrollNodeData::has_should_flatten() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ScrollNodeData::set_has_should_flatten() {
_has_bits_[0] |= 0x00000200u;
}
inline void ScrollNodeData::clear_has_should_flatten() {
_has_bits_[0] &= ~0x00000200u;
}
inline void ScrollNodeData::clear_should_flatten() {
should_flatten_ = false;
clear_has_should_flatten();
}
inline bool ScrollNodeData::should_flatten() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.should_flatten)
return should_flatten_;
}
inline void ScrollNodeData::set_should_flatten(bool value) {
set_has_should_flatten();
should_flatten_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollNodeData.should_flatten)
}

// optional bool user_scrollable_horizontal = 13;
inline bool ScrollNodeData::has_user_scrollable_horizontal() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ScrollNodeData::set_has_user_scrollable_horizontal() {
_has_bits_[0] |= 0x00000400u;
}
inline void ScrollNodeData::clear_has_user_scrollable_horizontal() {
_has_bits_[0] &= ~0x00000400u;
}
inline void ScrollNodeData::clear_user_scrollable_horizontal() {
user_scrollable_horizontal_ = false;
clear_has_user_scrollable_horizontal();
}
inline bool ScrollNodeData::user_scrollable_horizontal() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.user_scrollable_horizontal)
return user_scrollable_horizontal_;
}
inline void ScrollNodeData::set_user_scrollable_horizontal(bool value) {
set_has_user_scrollable_horizontal();
user_scrollable_horizontal_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollNodeData.user_scrollable_horizontal)
}

// optional bool user_scrollable_vertical = 14;
inline bool ScrollNodeData::has_user_scrollable_vertical() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ScrollNodeData::set_has_user_scrollable_vertical() {
_has_bits_[0] |= 0x00000800u;
}
inline void ScrollNodeData::clear_has_user_scrollable_vertical() {
_has_bits_[0] &= ~0x00000800u;
}
inline void ScrollNodeData::clear_user_scrollable_vertical() {
user_scrollable_vertical_ = false;
clear_has_user_scrollable_vertical();
}
inline bool ScrollNodeData::user_scrollable_vertical() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.user_scrollable_vertical)
return user_scrollable_vertical_;
}
inline void ScrollNodeData::set_user_scrollable_vertical(bool value) {
set_has_user_scrollable_vertical();
user_scrollable_vertical_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollNodeData.user_scrollable_vertical)
}

// optional .cc.proto.ElementId element_id = 15;
inline bool ScrollNodeData::has_element_id() const {
return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ScrollNodeData::set_has_element_id() {
_has_bits_[0] |= 0x00001000u;
}
inline void ScrollNodeData::clear_has_element_id() {
_has_bits_[0] &= ~0x00001000u;
}
inline void ScrollNodeData::clear_element_id() {
if (element_id_ != NULL) element_id_->::cc::proto::ElementId::Clear();
clear_has_element_id();
}
inline const ::cc::proto::ElementId& ScrollNodeData::element_id() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.element_id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return element_id_ != NULL ? *element_id_ : *default_instance().element_id_;
#else
return element_id_ != NULL ? *element_id_ : *default_instance_->element_id_;
#endif
}
inline ::cc::proto::ElementId* ScrollNodeData::mutable_element_id() {
set_has_element_id();
if (element_id_ == NULL) {
element_id_ = new ::cc::proto::ElementId;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollNodeData.element_id)
return element_id_;
}
inline ::cc::proto::ElementId* ScrollNodeData::release_element_id() {
// @@protoc_insertion_point(field_release:cc.proto.ScrollNodeData.element_id)
clear_has_element_id();
::cc::proto::ElementId* temp = element_id_;
element_id_ = NULL;
return temp;
}
inline void ScrollNodeData::set_allocated_element_id(::cc::proto::ElementId* element_id) {
delete element_id_;
element_id_ = element_id;
if (element_id) {
set_has_element_id();
} else {
clear_has_element_id();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollNodeData.element_id)
}

// optional int64 transform_id = 11;
inline bool ScrollNodeData::has_transform_id() const {
return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ScrollNodeData::set_has_transform_id() {
_has_bits_[0] |= 0x00002000u;
}
inline void ScrollNodeData::clear_has_transform_id() {
_has_bits_[0] &= ~0x00002000u;
}
inline void ScrollNodeData::clear_transform_id() {
transform_id_ = GOOGLE_LONGLONG(0);
clear_has_transform_id();
}
inline ::google::protobuf::int64 ScrollNodeData::transform_id() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollNodeData.transform_id)
return transform_id_;
}
inline void ScrollNodeData::set_transform_id(::google::protobuf::int64 value) {
set_has_transform_id();
transform_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollNodeData.transform_id)
}

// -------------------------------------------------------------------

// TreeNode

// optional int64 id = 1;
inline bool TreeNode::has_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TreeNode::set_has_id() {
_has_bits_[0] |= 0x00000001u;
}
inline void TreeNode::clear_has_id() {
_has_bits_[0] &= ~0x00000001u;
}
inline void TreeNode::clear_id() {
id_ = GOOGLE_LONGLONG(0);
clear_has_id();
}
inline ::google::protobuf::int64 TreeNode::id() const {
// @@protoc_insertion_point(field_get:cc.proto.TreeNode.id)
return id_;
}
inline void TreeNode::set_id(::google::protobuf::int64 value) {
set_has_id();
id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TreeNode.id)
}

// optional int64 parent_id = 2;
inline bool TreeNode::has_parent_id() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TreeNode::set_has_parent_id() {
_has_bits_[0] |= 0x00000002u;
}
inline void TreeNode::clear_has_parent_id() {
_has_bits_[0] &= ~0x00000002u;
}
inline void TreeNode::clear_parent_id() {
parent_id_ = GOOGLE_LONGLONG(0);
clear_has_parent_id();
}
inline ::google::protobuf::int64 TreeNode::parent_id() const {
// @@protoc_insertion_point(field_get:cc.proto.TreeNode.parent_id)
return parent_id_;
}
inline void TreeNode::set_parent_id(::google::protobuf::int64 value) {
set_has_parent_id();
parent_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TreeNode.parent_id)
}

// optional int64 owner_id = 3;
inline bool TreeNode::has_owner_id() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TreeNode::set_has_owner_id() {
_has_bits_[0] |= 0x00000004u;
}
inline void TreeNode::clear_has_owner_id() {
_has_bits_[0] &= ~0x00000004u;
}
inline void TreeNode::clear_owner_id() {
owner_id_ = GOOGLE_LONGLONG(0);
clear_has_owner_id();
}
inline ::google::protobuf::int64 TreeNode::owner_id() const {
// @@protoc_insertion_point(field_get:cc.proto.TreeNode.owner_id)
return owner_id_;
}
inline void TreeNode::set_owner_id(::google::protobuf::int64 value) {
set_has_owner_id();
owner_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TreeNode.owner_id)
}

// optional .cc.proto.TranformNodeData transform_node_data = 1000;
inline bool TreeNode::has_transform_node_data() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TreeNode::set_has_transform_node_data() {
_has_bits_[0] |= 0x00000008u;
}
inline void TreeNode::clear_has_transform_node_data() {
_has_bits_[0] &= ~0x00000008u;
}
inline void TreeNode::clear_transform_node_data() {
if (transform_node_data_ != NULL) transform_node_data_->::cc::proto::TranformNodeData::Clear();
clear_has_transform_node_data();
}
inline const ::cc::proto::TranformNodeData& TreeNode::transform_node_data() const {
// @@protoc_insertion_point(field_get:cc.proto.TreeNode.transform_node_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return transform_node_data_ != NULL ? *transform_node_data_ : *default_instance().transform_node_data_;
#else
return transform_node_data_ != NULL ? *transform_node_data_ : *default_instance_->transform_node_data_;
#endif
}
inline ::cc::proto::TranformNodeData* TreeNode::mutable_transform_node_data() {
set_has_transform_node_data();
if (transform_node_data_ == NULL) {
transform_node_data_ = new ::cc::proto::TranformNodeData;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TreeNode.transform_node_data)
return transform_node_data_;
}
inline ::cc::proto::TranformNodeData* TreeNode::release_transform_node_data() {
// @@protoc_insertion_point(field_release:cc.proto.TreeNode.transform_node_data)
clear_has_transform_node_data();
::cc::proto::TranformNodeData* temp = transform_node_data_;
transform_node_data_ = NULL;
return temp;
}
inline void TreeNode::set_allocated_transform_node_data(::cc::proto::TranformNodeData* transform_node_data) {
delete transform_node_data_;
transform_node_data_ = transform_node_data;
if (transform_node_data) {
set_has_transform_node_data();
} else {
clear_has_transform_node_data();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TreeNode.transform_node_data)
}

// optional .cc.proto.ClipNodeData clip_node_data = 1001;
inline bool TreeNode::has_clip_node_data() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TreeNode::set_has_clip_node_data() {
_has_bits_[0] |= 0x00000010u;
}
inline void TreeNode::clear_has_clip_node_data() {
_has_bits_[0] &= ~0x00000010u;
}
inline void TreeNode::clear_clip_node_data() {
if (clip_node_data_ != NULL) clip_node_data_->::cc::proto::ClipNodeData::Clear();
clear_has_clip_node_data();
}
inline const ::cc::proto::ClipNodeData& TreeNode::clip_node_data() const {
// @@protoc_insertion_point(field_get:cc.proto.TreeNode.clip_node_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return clip_node_data_ != NULL ? *clip_node_data_ : *default_instance().clip_node_data_;
#else
return clip_node_data_ != NULL ? *clip_node_data_ : *default_instance_->clip_node_data_;
#endif
}
inline ::cc::proto::ClipNodeData* TreeNode::mutable_clip_node_data() {
set_has_clip_node_data();
if (clip_node_data_ == NULL) {
clip_node_data_ = new ::cc::proto::ClipNodeData;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TreeNode.clip_node_data)
return clip_node_data_;
}
inline ::cc::proto::ClipNodeData* TreeNode::release_clip_node_data() {
// @@protoc_insertion_point(field_release:cc.proto.TreeNode.clip_node_data)
clear_has_clip_node_data();
::cc::proto::ClipNodeData* temp = clip_node_data_;
clip_node_data_ = NULL;
return temp;
}
inline void TreeNode::set_allocated_clip_node_data(::cc::proto::ClipNodeData* clip_node_data) {
delete clip_node_data_;
clip_node_data_ = clip_node_data;
if (clip_node_data) {
set_has_clip_node_data();
} else {
clear_has_clip_node_data();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TreeNode.clip_node_data)
}

// optional .cc.proto.EffectNodeData effect_node_data = 1002;
inline bool TreeNode::has_effect_node_data() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TreeNode::set_has_effect_node_data() {
_has_bits_[0] |= 0x00000020u;
}
inline void TreeNode::clear_has_effect_node_data() {
_has_bits_[0] &= ~0x00000020u;
}
inline void TreeNode::clear_effect_node_data() {
if (effect_node_data_ != NULL) effect_node_data_->::cc::proto::EffectNodeData::Clear();
clear_has_effect_node_data();
}
inline const ::cc::proto::EffectNodeData& TreeNode::effect_node_data() const {
// @@protoc_insertion_point(field_get:cc.proto.TreeNode.effect_node_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return effect_node_data_ != NULL ? *effect_node_data_ : *default_instance().effect_node_data_;
#else
return effect_node_data_ != NULL ? *effect_node_data_ : *default_instance_->effect_node_data_;
#endif
}
inline ::cc::proto::EffectNodeData* TreeNode::mutable_effect_node_data() {
set_has_effect_node_data();
if (effect_node_data_ == NULL) {
effect_node_data_ = new ::cc::proto::EffectNodeData;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TreeNode.effect_node_data)
return effect_node_data_;
}
inline ::cc::proto::EffectNodeData* TreeNode::release_effect_node_data() {
// @@protoc_insertion_point(field_release:cc.proto.TreeNode.effect_node_data)
clear_has_effect_node_data();
::cc::proto::EffectNodeData* temp = effect_node_data_;
effect_node_data_ = NULL;
return temp;
}
inline void TreeNode::set_allocated_effect_node_data(::cc::proto::EffectNodeData* effect_node_data) {
delete effect_node_data_;
effect_node_data_ = effect_node_data;
if (effect_node_data) {
set_has_effect_node_data();
} else {
clear_has_effect_node_data();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TreeNode.effect_node_data)
}

// optional .cc.proto.ScrollNodeData scroll_node_data = 1003;
inline bool TreeNode::has_scroll_node_data() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TreeNode::set_has_scroll_node_data() {
_has_bits_[0] |= 0x00000040u;
}
inline void TreeNode::clear_has_scroll_node_data() {
_has_bits_[0] &= ~0x00000040u;
}
inline void TreeNode::clear_scroll_node_data() {
if (scroll_node_data_ != NULL) scroll_node_data_->::cc::proto::ScrollNodeData::Clear();
clear_has_scroll_node_data();
}
inline const ::cc::proto::ScrollNodeData& TreeNode::scroll_node_data() const {
// @@protoc_insertion_point(field_get:cc.proto.TreeNode.scroll_node_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return scroll_node_data_ != NULL ? *scroll_node_data_ : *default_instance().scroll_node_data_;
#else
return scroll_node_data_ != NULL ? *scroll_node_data_ : *default_instance_->scroll_node_data_;
#endif
}
inline ::cc::proto::ScrollNodeData* TreeNode::mutable_scroll_node_data() {
set_has_scroll_node_data();
if (scroll_node_data_ == NULL) {
scroll_node_data_ = new ::cc::proto::ScrollNodeData;
}
// @@protoc_insertion_point(field_mutable:cc.proto.TreeNode.scroll_node_data)
return scroll_node_data_;
}
inline ::cc::proto::ScrollNodeData* TreeNode::release_scroll_node_data() {
// @@protoc_insertion_point(field_release:cc.proto.TreeNode.scroll_node_data)
clear_has_scroll_node_data();
::cc::proto::ScrollNodeData* temp = scroll_node_data_;
scroll_node_data_ = NULL;
return temp;
}
inline void TreeNode::set_allocated_scroll_node_data(::cc::proto::ScrollNodeData* scroll_node_data) {
delete scroll_node_data_;
scroll_node_data_ = scroll_node_data;
if (scroll_node_data) {
set_has_scroll_node_data();
} else {
clear_has_scroll_node_data();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.TreeNode.scroll_node_data)
}

// -------------------------------------------------------------------

// PropertyTree

// optional .cc.proto.PropertyTree.PropertyType property_type = 1;
inline bool PropertyTree::has_property_type() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyTree::set_has_property_type() {
_has_bits_[0] |= 0x00000001u;
}
inline void PropertyTree::clear_has_property_type() {
_has_bits_[0] &= ~0x00000001u;
}
inline void PropertyTree::clear_property_type() {
property_type_ = 1;
clear_has_property_type();
}
inline ::cc::proto::PropertyTree_PropertyType PropertyTree::property_type() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTree.property_type)
return static_cast< ::cc::proto::PropertyTree_PropertyType >(property_type_);
}
inline void PropertyTree::set_property_type(::cc::proto::PropertyTree_PropertyType value) {
assert(::cc::proto::PropertyTree_PropertyType_IsValid(value));
set_has_property_type();
property_type_ = value;
// @@protoc_insertion_point(field_set:cc.proto.PropertyTree.property_type)
}

// repeated .cc.proto.TreeNode nodes = 2;
inline int PropertyTree::nodes_size() const {
return nodes_.size();
}
inline void PropertyTree::clear_nodes() {
nodes_.Clear();
}
inline const ::cc::proto::TreeNode& PropertyTree::nodes(int index) const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTree.nodes)
return nodes_.Get(index);
}
inline ::cc::proto::TreeNode* PropertyTree::mutable_nodes(int index) {
// @@protoc_insertion_point(field_mutable:cc.proto.PropertyTree.nodes)
return nodes_.Mutable(index);
}
inline ::cc::proto::TreeNode* PropertyTree::add_nodes() {
// @@protoc_insertion_point(field_add:cc.proto.PropertyTree.nodes)
return nodes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cc::proto::TreeNode >*
PropertyTree::mutable_nodes() {
// @@protoc_insertion_point(field_mutable_list:cc.proto.PropertyTree.nodes)
return &nodes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::TreeNode >&
PropertyTree::nodes() const {
// @@protoc_insertion_point(field_list:cc.proto.PropertyTree.nodes)
return nodes_;
}

// optional bool needs_update = 3;
inline bool PropertyTree::has_needs_update() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PropertyTree::set_has_needs_update() {
_has_bits_[0] |= 0x00000004u;
}
inline void PropertyTree::clear_has_needs_update() {
_has_bits_[0] &= ~0x00000004u;
}
inline void PropertyTree::clear_needs_update() {
needs_update_ = false;
clear_has_needs_update();
}
inline bool PropertyTree::needs_update() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTree.needs_update)
return needs_update_;
}
inline void PropertyTree::set_needs_update(bool value) {
set_has_needs_update();
needs_update_ = value;
// @@protoc_insertion_point(field_set:cc.proto.PropertyTree.needs_update)
}

// optional .cc.proto.TransformTreeData transform_tree_data = 1000;
inline bool PropertyTree::has_transform_tree_data() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PropertyTree::set_has_transform_tree_data() {
_has_bits_[0] |= 0x00000008u;
}
inline void PropertyTree::clear_has_transform_tree_data() {
_has_bits_[0] &= ~0x00000008u;
}
inline void PropertyTree::clear_transform_tree_data() {
if (transform_tree_data_ != NULL) transform_tree_data_->::cc::proto::TransformTreeData::Clear();
clear_has_transform_tree_data();
}
inline const ::cc::proto::TransformTreeData& PropertyTree::transform_tree_data() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTree.transform_tree_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return transform_tree_data_ != NULL ? *transform_tree_data_ : *default_instance().transform_tree_data_;
#else
return transform_tree_data_ != NULL ? *transform_tree_data_ : *default_instance_->transform_tree_data_;
#endif
}
inline ::cc::proto::TransformTreeData* PropertyTree::mutable_transform_tree_data() {
set_has_transform_tree_data();
if (transform_tree_data_ == NULL) {
transform_tree_data_ = new ::cc::proto::TransformTreeData;
}
// @@protoc_insertion_point(field_mutable:cc.proto.PropertyTree.transform_tree_data)
return transform_tree_data_;
}
inline ::cc::proto::TransformTreeData* PropertyTree::release_transform_tree_data() {
// @@protoc_insertion_point(field_release:cc.proto.PropertyTree.transform_tree_data)
clear_has_transform_tree_data();
::cc::proto::TransformTreeData* temp = transform_tree_data_;
transform_tree_data_ = NULL;
return temp;
}
inline void PropertyTree::set_allocated_transform_tree_data(::cc::proto::TransformTreeData* transform_tree_data) {
delete transform_tree_data_;
transform_tree_data_ = transform_tree_data;
if (transform_tree_data) {
set_has_transform_tree_data();
} else {
clear_has_transform_tree_data();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.PropertyTree.transform_tree_data)
}

// optional .cc.proto.ScrollTreeData scroll_tree_data = 1001;
inline bool PropertyTree::has_scroll_tree_data() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PropertyTree::set_has_scroll_tree_data() {
_has_bits_[0] |= 0x00000010u;
}
inline void PropertyTree::clear_has_scroll_tree_data() {
_has_bits_[0] &= ~0x00000010u;
}
inline void PropertyTree::clear_scroll_tree_data() {
if (scroll_tree_data_ != NULL) scroll_tree_data_->::cc::proto::ScrollTreeData::Clear();
clear_has_scroll_tree_data();
}
inline const ::cc::proto::ScrollTreeData& PropertyTree::scroll_tree_data() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTree.scroll_tree_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return scroll_tree_data_ != NULL ? *scroll_tree_data_ : *default_instance().scroll_tree_data_;
#else
return scroll_tree_data_ != NULL ? *scroll_tree_data_ : *default_instance_->scroll_tree_data_;
#endif
}
inline ::cc::proto::ScrollTreeData* PropertyTree::mutable_scroll_tree_data() {
set_has_scroll_tree_data();
if (scroll_tree_data_ == NULL) {
scroll_tree_data_ = new ::cc::proto::ScrollTreeData;
}
// @@protoc_insertion_point(field_mutable:cc.proto.PropertyTree.scroll_tree_data)
return scroll_tree_data_;
}
inline ::cc::proto::ScrollTreeData* PropertyTree::release_scroll_tree_data() {
// @@protoc_insertion_point(field_release:cc.proto.PropertyTree.scroll_tree_data)
clear_has_scroll_tree_data();
::cc::proto::ScrollTreeData* temp = scroll_tree_data_;
scroll_tree_data_ = NULL;
return temp;
}
inline void PropertyTree::set_allocated_scroll_tree_data(::cc::proto::ScrollTreeData* scroll_tree_data) {
delete scroll_tree_data_;
scroll_tree_data_ = scroll_tree_data;
if (scroll_tree_data) {
set_has_scroll_tree_data();
} else {
clear_has_scroll_tree_data();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.PropertyTree.scroll_tree_data)
}

// optional .cc.proto.EffectTreeData effect_tree_data = 1002;
inline bool PropertyTree::has_effect_tree_data() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PropertyTree::set_has_effect_tree_data() {
_has_bits_[0] |= 0x00000020u;
}
inline void PropertyTree::clear_has_effect_tree_data() {
_has_bits_[0] &= ~0x00000020u;
}
inline void PropertyTree::clear_effect_tree_data() {
if (effect_tree_data_ != NULL) effect_tree_data_->::cc::proto::EffectTreeData::Clear();
clear_has_effect_tree_data();
}
inline const ::cc::proto::EffectTreeData& PropertyTree::effect_tree_data() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTree.effect_tree_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return effect_tree_data_ != NULL ? *effect_tree_data_ : *default_instance().effect_tree_data_;
#else
return effect_tree_data_ != NULL ? *effect_tree_data_ : *default_instance_->effect_tree_data_;
#endif
}
inline ::cc::proto::EffectTreeData* PropertyTree::mutable_effect_tree_data() {
set_has_effect_tree_data();
if (effect_tree_data_ == NULL) {
effect_tree_data_ = new ::cc::proto::EffectTreeData;
}
// @@protoc_insertion_point(field_mutable:cc.proto.PropertyTree.effect_tree_data)
return effect_tree_data_;
}
inline ::cc::proto::EffectTreeData* PropertyTree::release_effect_tree_data() {
// @@protoc_insertion_point(field_release:cc.proto.PropertyTree.effect_tree_data)
clear_has_effect_tree_data();
::cc::proto::EffectTreeData* temp = effect_tree_data_;
effect_tree_data_ = NULL;
return temp;
}
inline void PropertyTree::set_allocated_effect_tree_data(::cc::proto::EffectTreeData* effect_tree_data) {
delete effect_tree_data_;
effect_tree_data_ = effect_tree_data;
if (effect_tree_data) {
set_has_effect_tree_data();
} else {
clear_has_effect_tree_data();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.PropertyTree.effect_tree_data)
}

// -------------------------------------------------------------------

// ScrollOffsetMapEntry

// required int64 layer_id = 1;
inline bool ScrollOffsetMapEntry::has_layer_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScrollOffsetMapEntry::set_has_layer_id() {
_has_bits_[0] |= 0x00000001u;
}
inline void ScrollOffsetMapEntry::clear_has_layer_id() {
_has_bits_[0] &= ~0x00000001u;
}
inline void ScrollOffsetMapEntry::clear_layer_id() {
layer_id_ = GOOGLE_LONGLONG(0);
clear_has_layer_id();
}
inline ::google::protobuf::int64 ScrollOffsetMapEntry::layer_id() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollOffsetMapEntry.layer_id)
return layer_id_;
}
inline void ScrollOffsetMapEntry::set_layer_id(::google::protobuf::int64 value) {
set_has_layer_id();
layer_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollOffsetMapEntry.layer_id)
}

// optional .cc.proto.SyncedProperty scroll_offset = 2;
inline bool ScrollOffsetMapEntry::has_scroll_offset() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScrollOffsetMapEntry::set_has_scroll_offset() {
_has_bits_[0] |= 0x00000002u;
}
inline void ScrollOffsetMapEntry::clear_has_scroll_offset() {
_has_bits_[0] &= ~0x00000002u;
}
inline void ScrollOffsetMapEntry::clear_scroll_offset() {
if (scroll_offset_ != NULL) scroll_offset_->::cc::proto::SyncedProperty::Clear();
clear_has_scroll_offset();
}
inline const ::cc::proto::SyncedProperty& ScrollOffsetMapEntry::scroll_offset() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollOffsetMapEntry.scroll_offset)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return scroll_offset_ != NULL ? *scroll_offset_ : *default_instance().scroll_offset_;
#else
return scroll_offset_ != NULL ? *scroll_offset_ : *default_instance_->scroll_offset_;
#endif
}
inline ::cc::proto::SyncedProperty* ScrollOffsetMapEntry::mutable_scroll_offset() {
set_has_scroll_offset();
if (scroll_offset_ == NULL) {
scroll_offset_ = new ::cc::proto::SyncedProperty;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollOffsetMapEntry.scroll_offset)
return scroll_offset_;
}
inline ::cc::proto::SyncedProperty* ScrollOffsetMapEntry::release_scroll_offset() {
// @@protoc_insertion_point(field_release:cc.proto.ScrollOffsetMapEntry.scroll_offset)
clear_has_scroll_offset();
::cc::proto::SyncedProperty* temp = scroll_offset_;
scroll_offset_ = NULL;
return temp;
}
inline void ScrollOffsetMapEntry::set_allocated_scroll_offset(::cc::proto::SyncedProperty* scroll_offset) {
delete scroll_offset_;
scroll_offset_ = scroll_offset;
if (scroll_offset) {
set_has_scroll_offset();
} else {
clear_has_scroll_offset();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollOffsetMapEntry.scroll_offset)
}

// -------------------------------------------------------------------

// ScrollTreeData

// optional int64 currently_scrolling_node_id = 1;
inline bool ScrollTreeData::has_currently_scrolling_node_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScrollTreeData::set_has_currently_scrolling_node_id() {
_has_bits_[0] |= 0x00000001u;
}
inline void ScrollTreeData::clear_has_currently_scrolling_node_id() {
_has_bits_[0] &= ~0x00000001u;
}
inline void ScrollTreeData::clear_currently_scrolling_node_id() {
currently_scrolling_node_id_ = GOOGLE_LONGLONG(0);
clear_has_currently_scrolling_node_id();
}
inline ::google::protobuf::int64 ScrollTreeData::currently_scrolling_node_id() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollTreeData.currently_scrolling_node_id)
return currently_scrolling_node_id_;
}
inline void ScrollTreeData::set_currently_scrolling_node_id(::google::protobuf::int64 value) {
set_has_currently_scrolling_node_id();
currently_scrolling_node_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollTreeData.currently_scrolling_node_id)
}

// repeated .cc.proto.ScrollOffsetMapEntry layer_id_to_scroll_offset_map = 2;
inline int ScrollTreeData::layer_id_to_scroll_offset_map_size() const {
return layer_id_to_scroll_offset_map_.size();
}
inline void ScrollTreeData::clear_layer_id_to_scroll_offset_map() {
layer_id_to_scroll_offset_map_.Clear();
}
inline const ::cc::proto::ScrollOffsetMapEntry& ScrollTreeData::layer_id_to_scroll_offset_map(int index) const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollTreeData.layer_id_to_scroll_offset_map)
return layer_id_to_scroll_offset_map_.Get(index);
}
inline ::cc::proto::ScrollOffsetMapEntry* ScrollTreeData::mutable_layer_id_to_scroll_offset_map(int index) {
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollTreeData.layer_id_to_scroll_offset_map)
return layer_id_to_scroll_offset_map_.Mutable(index);
}
inline ::cc::proto::ScrollOffsetMapEntry* ScrollTreeData::add_layer_id_to_scroll_offset_map() {
// @@protoc_insertion_point(field_add:cc.proto.ScrollTreeData.layer_id_to_scroll_offset_map)
return layer_id_to_scroll_offset_map_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cc::proto::ScrollOffsetMapEntry >*
ScrollTreeData::mutable_layer_id_to_scroll_offset_map() {
// @@protoc_insertion_point(field_mutable_list:cc.proto.ScrollTreeData.layer_id_to_scroll_offset_map)
return &layer_id_to_scroll_offset_map_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::ScrollOffsetMapEntry >&
ScrollTreeData::layer_id_to_scroll_offset_map() const {
// @@protoc_insertion_point(field_list:cc.proto.ScrollTreeData.layer_id_to_scroll_offset_map)
return layer_id_to_scroll_offset_map_;
}

// -------------------------------------------------------------------

// TransformTreeData

// optional bool source_to_parent_updates_allowed = 1;
inline bool TransformTreeData::has_source_to_parent_updates_allowed() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransformTreeData::set_has_source_to_parent_updates_allowed() {
_has_bits_[0] |= 0x00000001u;
}
inline void TransformTreeData::clear_has_source_to_parent_updates_allowed() {
_has_bits_[0] &= ~0x00000001u;
}
inline void TransformTreeData::clear_source_to_parent_updates_allowed() {
source_to_parent_updates_allowed_ = false;
clear_has_source_to_parent_updates_allowed();
}
inline bool TransformTreeData::source_to_parent_updates_allowed() const {
// @@protoc_insertion_point(field_get:cc.proto.TransformTreeData.source_to_parent_updates_allowed)
return source_to_parent_updates_allowed_;
}
inline void TransformTreeData::set_source_to_parent_updates_allowed(bool value) {
set_has_source_to_parent_updates_allowed();
source_to_parent_updates_allowed_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TransformTreeData.source_to_parent_updates_allowed)
}

// optional float page_scale_factor = 2;
inline bool TransformTreeData::has_page_scale_factor() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransformTreeData::set_has_page_scale_factor() {
_has_bits_[0] |= 0x00000002u;
}
inline void TransformTreeData::clear_has_page_scale_factor() {
_has_bits_[0] &= ~0x00000002u;
}
inline void TransformTreeData::clear_page_scale_factor() {
page_scale_factor_ = 0;
clear_has_page_scale_factor();
}
inline float TransformTreeData::page_scale_factor() const {
// @@protoc_insertion_point(field_get:cc.proto.TransformTreeData.page_scale_factor)
return page_scale_factor_;
}
inline void TransformTreeData::set_page_scale_factor(float value) {
set_has_page_scale_factor();
page_scale_factor_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TransformTreeData.page_scale_factor)
}

// optional float device_scale_factor = 3;
inline bool TransformTreeData::has_device_scale_factor() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransformTreeData::set_has_device_scale_factor() {
_has_bits_[0] |= 0x00000004u;
}
inline void TransformTreeData::clear_has_device_scale_factor() {
_has_bits_[0] &= ~0x00000004u;
}
inline void TransformTreeData::clear_device_scale_factor() {
device_scale_factor_ = 0;
clear_has_device_scale_factor();
}
inline float TransformTreeData::device_scale_factor() const {
// @@protoc_insertion_point(field_get:cc.proto.TransformTreeData.device_scale_factor)
return device_scale_factor_;
}
inline void TransformTreeData::set_device_scale_factor(float value) {
set_has_device_scale_factor();
device_scale_factor_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TransformTreeData.device_scale_factor)
}

// optional float device_transform_scale_factor = 4;
inline bool TransformTreeData::has_device_transform_scale_factor() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransformTreeData::set_has_device_transform_scale_factor() {
_has_bits_[0] |= 0x00000008u;
}
inline void TransformTreeData::clear_has_device_transform_scale_factor() {
_has_bits_[0] &= ~0x00000008u;
}
inline void TransformTreeData::clear_device_transform_scale_factor() {
device_transform_scale_factor_ = 0;
clear_has_device_transform_scale_factor();
}
inline float TransformTreeData::device_transform_scale_factor() const {
// @@protoc_insertion_point(field_get:cc.proto.TransformTreeData.device_transform_scale_factor)
return device_transform_scale_factor_;
}
inline void TransformTreeData::set_device_transform_scale_factor(float value) {
set_has_device_transform_scale_factor();
device_transform_scale_factor_ = value;
// @@protoc_insertion_point(field_set:cc.proto.TransformTreeData.device_transform_scale_factor)
}

// repeated int64 nodes_affected_by_inner_viewport_bounds_delta = 7 [packed = true];
inline int TransformTreeData::nodes_affected_by_inner_viewport_bounds_delta_size() const {
return nodes_affected_by_inner_viewport_bounds_delta_.size();
}
inline void TransformTreeData::clear_nodes_affected_by_inner_viewport_bounds_delta() {
nodes_affected_by_inner_viewport_bounds_delta_.Clear();
}
inline ::google::protobuf::int64 TransformTreeData::nodes_affected_by_inner_viewport_bounds_delta(int index) const {
// @@protoc_insertion_point(field_get:cc.proto.TransformTreeData.nodes_affected_by_inner_viewport_bounds_delta)
return nodes_affected_by_inner_viewport_bounds_delta_.Get(index);
}
inline void TransformTreeData::set_nodes_affected_by_inner_viewport_bounds_delta(int index, ::google::protobuf::int64 value) {
nodes_affected_by_inner_viewport_bounds_delta_.Set(index, value);
// @@protoc_insertion_point(field_set:cc.proto.TransformTreeData.nodes_affected_by_inner_viewport_bounds_delta)
}
inline void TransformTreeData::add_nodes_affected_by_inner_viewport_bounds_delta(::google::protobuf::int64 value) {
nodes_affected_by_inner_viewport_bounds_delta_.Add(value);
// @@protoc_insertion_point(field_add:cc.proto.TransformTreeData.nodes_affected_by_inner_viewport_bounds_delta)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TransformTreeData::nodes_affected_by_inner_viewport_bounds_delta() const {
// @@protoc_insertion_point(field_list:cc.proto.TransformTreeData.nodes_affected_by_inner_viewport_bounds_delta)
return nodes_affected_by_inner_viewport_bounds_delta_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TransformTreeData::mutable_nodes_affected_by_inner_viewport_bounds_delta() {
// @@protoc_insertion_point(field_mutable_list:cc.proto.TransformTreeData.nodes_affected_by_inner_viewport_bounds_delta)
return &nodes_affected_by_inner_viewport_bounds_delta_;
}

// repeated int64 nodes_affected_by_outer_viewport_bounds_delta = 8 [packed = true];
inline int TransformTreeData::nodes_affected_by_outer_viewport_bounds_delta_size() const {
return nodes_affected_by_outer_viewport_bounds_delta_.size();
}
inline void TransformTreeData::clear_nodes_affected_by_outer_viewport_bounds_delta() {
nodes_affected_by_outer_viewport_bounds_delta_.Clear();
}
inline ::google::protobuf::int64 TransformTreeData::nodes_affected_by_outer_viewport_bounds_delta(int index) const {
// @@protoc_insertion_point(field_get:cc.proto.TransformTreeData.nodes_affected_by_outer_viewport_bounds_delta)
return nodes_affected_by_outer_viewport_bounds_delta_.Get(index);
}
inline void TransformTreeData::set_nodes_affected_by_outer_viewport_bounds_delta(int index, ::google::protobuf::int64 value) {
nodes_affected_by_outer_viewport_bounds_delta_.Set(index, value);
// @@protoc_insertion_point(field_set:cc.proto.TransformTreeData.nodes_affected_by_outer_viewport_bounds_delta)
}
inline void TransformTreeData::add_nodes_affected_by_outer_viewport_bounds_delta(::google::protobuf::int64 value) {
nodes_affected_by_outer_viewport_bounds_delta_.Add(value);
// @@protoc_insertion_point(field_add:cc.proto.TransformTreeData.nodes_affected_by_outer_viewport_bounds_delta)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TransformTreeData::nodes_affected_by_outer_viewport_bounds_delta() const {
// @@protoc_insertion_point(field_list:cc.proto.TransformTreeData.nodes_affected_by_outer_viewport_bounds_delta)
return nodes_affected_by_outer_viewport_bounds_delta_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TransformTreeData::mutable_nodes_affected_by_outer_viewport_bounds_delta() {
// @@protoc_insertion_point(field_mutable_list:cc.proto.TransformTreeData.nodes_affected_by_outer_viewport_bounds_delta)
return &nodes_affected_by_outer_viewport_bounds_delta_;
}

// repeated .cc.proto.TransformCachedNodeData cached_data = 9;
inline int TransformTreeData::cached_data_size() const {
return cached_data_.size();
}
inline void TransformTreeData::clear_cached_data() {
cached_data_.Clear();
}
inline const ::cc::proto::TransformCachedNodeData& TransformTreeData::cached_data(int index) const {
// @@protoc_insertion_point(field_get:cc.proto.TransformTreeData.cached_data)
return cached_data_.Get(index);
}
inline ::cc::proto::TransformCachedNodeData* TransformTreeData::mutable_cached_data(int index) {
// @@protoc_insertion_point(field_mutable:cc.proto.TransformTreeData.cached_data)
return cached_data_.Mutable(index);
}
inline ::cc::proto::TransformCachedNodeData* TransformTreeData::add_cached_data() {
// @@protoc_insertion_point(field_add:cc.proto.TransformTreeData.cached_data)
return cached_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cc::proto::TransformCachedNodeData >*
TransformTreeData::mutable_cached_data() {
// @@protoc_insertion_point(field_mutable_list:cc.proto.TransformTreeData.cached_data)
return &cached_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::TransformCachedNodeData >&
TransformTreeData::cached_data() const {
// @@protoc_insertion_point(field_list:cc.proto.TransformTreeData.cached_data)
return cached_data_;
}

// -------------------------------------------------------------------

// EffectTreeData

// repeated int64 mask_replica_layer_ids = 1 [packed = true];
inline int EffectTreeData::mask_replica_layer_ids_size() const {
return mask_replica_layer_ids_.size();
}
inline void EffectTreeData::clear_mask_replica_layer_ids() {
mask_replica_layer_ids_.Clear();
}
inline ::google::protobuf::int64 EffectTreeData::mask_replica_layer_ids(int index) const {
// @@protoc_insertion_point(field_get:cc.proto.EffectTreeData.mask_replica_layer_ids)
return mask_replica_layer_ids_.Get(index);
}
inline void EffectTreeData::set_mask_replica_layer_ids(int index, ::google::protobuf::int64 value) {
mask_replica_layer_ids_.Set(index, value);
// @@protoc_insertion_point(field_set:cc.proto.EffectTreeData.mask_replica_layer_ids)
}
inline void EffectTreeData::add_mask_replica_layer_ids(::google::protobuf::int64 value) {
mask_replica_layer_ids_.Add(value);
// @@protoc_insertion_point(field_add:cc.proto.EffectTreeData.mask_replica_layer_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
EffectTreeData::mask_replica_layer_ids() const {
// @@protoc_insertion_point(field_list:cc.proto.EffectTreeData.mask_replica_layer_ids)
return mask_replica_layer_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
EffectTreeData::mutable_mask_replica_layer_ids() {
// @@protoc_insertion_point(field_mutable_list:cc.proto.EffectTreeData.mask_replica_layer_ids)
return &mask_replica_layer_ids_;
}

// -------------------------------------------------------------------

// PropertyTrees

// optional .cc.proto.PropertyTree transform_tree = 1;
inline bool PropertyTrees::has_transform_tree() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PropertyTrees::set_has_transform_tree() {
_has_bits_[0] |= 0x00000001u;
}
inline void PropertyTrees::clear_has_transform_tree() {
_has_bits_[0] &= ~0x00000001u;
}
inline void PropertyTrees::clear_transform_tree() {
if (transform_tree_ != NULL) transform_tree_->::cc::proto::PropertyTree::Clear();
clear_has_transform_tree();
}
inline const ::cc::proto::PropertyTree& PropertyTrees::transform_tree() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.transform_tree)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return transform_tree_ != NULL ? *transform_tree_ : *default_instance().transform_tree_;
#else
return transform_tree_ != NULL ? *transform_tree_ : *default_instance_->transform_tree_;
#endif
}
inline ::cc::proto::PropertyTree* PropertyTrees::mutable_transform_tree() {
set_has_transform_tree();
if (transform_tree_ == NULL) {
transform_tree_ = new ::cc::proto::PropertyTree;
}
// @@protoc_insertion_point(field_mutable:cc.proto.PropertyTrees.transform_tree)
return transform_tree_;
}
inline ::cc::proto::PropertyTree* PropertyTrees::release_transform_tree() {
// @@protoc_insertion_point(field_release:cc.proto.PropertyTrees.transform_tree)
clear_has_transform_tree();
::cc::proto::PropertyTree* temp = transform_tree_;
transform_tree_ = NULL;
return temp;
}
inline void PropertyTrees::set_allocated_transform_tree(::cc::proto::PropertyTree* transform_tree) {
delete transform_tree_;
transform_tree_ = transform_tree;
if (transform_tree) {
set_has_transform_tree();
} else {
clear_has_transform_tree();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.PropertyTrees.transform_tree)
}

// optional .cc.proto.PropertyTree effect_tree = 2;
inline bool PropertyTrees::has_effect_tree() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PropertyTrees::set_has_effect_tree() {
_has_bits_[0] |= 0x00000002u;
}
inline void PropertyTrees::clear_has_effect_tree() {
_has_bits_[0] &= ~0x00000002u;
}
inline void PropertyTrees::clear_effect_tree() {
if (effect_tree_ != NULL) effect_tree_->::cc::proto::PropertyTree::Clear();
clear_has_effect_tree();
}
inline const ::cc::proto::PropertyTree& PropertyTrees::effect_tree() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.effect_tree)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return effect_tree_ != NULL ? *effect_tree_ : *default_instance().effect_tree_;
#else
return effect_tree_ != NULL ? *effect_tree_ : *default_instance_->effect_tree_;
#endif
}
inline ::cc::proto::PropertyTree* PropertyTrees::mutable_effect_tree() {
set_has_effect_tree();
if (effect_tree_ == NULL) {
effect_tree_ = new ::cc::proto::PropertyTree;
}
// @@protoc_insertion_point(field_mutable:cc.proto.PropertyTrees.effect_tree)
return effect_tree_;
}
inline ::cc::proto::PropertyTree* PropertyTrees::release_effect_tree() {
// @@protoc_insertion_point(field_release:cc.proto.PropertyTrees.effect_tree)
clear_has_effect_tree();
::cc::proto::PropertyTree* temp = effect_tree_;
effect_tree_ = NULL;
return temp;
}
inline void PropertyTrees::set_allocated_effect_tree(::cc::proto::PropertyTree* effect_tree) {
delete effect_tree_;
effect_tree_ = effect_tree;
if (effect_tree) {
set_has_effect_tree();
} else {
clear_has_effect_tree();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.PropertyTrees.effect_tree)
}

// optional .cc.proto.PropertyTree clip_tree = 3;
inline bool PropertyTrees::has_clip_tree() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PropertyTrees::set_has_clip_tree() {
_has_bits_[0] |= 0x00000004u;
}
inline void PropertyTrees::clear_has_clip_tree() {
_has_bits_[0] &= ~0x00000004u;
}
inline void PropertyTrees::clear_clip_tree() {
if (clip_tree_ != NULL) clip_tree_->::cc::proto::PropertyTree::Clear();
clear_has_clip_tree();
}
inline const ::cc::proto::PropertyTree& PropertyTrees::clip_tree() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.clip_tree)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return clip_tree_ != NULL ? *clip_tree_ : *default_instance().clip_tree_;
#else
return clip_tree_ != NULL ? *clip_tree_ : *default_instance_->clip_tree_;
#endif
}
inline ::cc::proto::PropertyTree* PropertyTrees::mutable_clip_tree() {
set_has_clip_tree();
if (clip_tree_ == NULL) {
clip_tree_ = new ::cc::proto::PropertyTree;
}
// @@protoc_insertion_point(field_mutable:cc.proto.PropertyTrees.clip_tree)
return clip_tree_;
}
inline ::cc::proto::PropertyTree* PropertyTrees::release_clip_tree() {
// @@protoc_insertion_point(field_release:cc.proto.PropertyTrees.clip_tree)
clear_has_clip_tree();
::cc::proto::PropertyTree* temp = clip_tree_;
clip_tree_ = NULL;
return temp;
}
inline void PropertyTrees::set_allocated_clip_tree(::cc::proto::PropertyTree* clip_tree) {
delete clip_tree_;
clip_tree_ = clip_tree;
if (clip_tree) {
set_has_clip_tree();
} else {
clear_has_clip_tree();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.PropertyTrees.clip_tree)
}

// optional .cc.proto.PropertyTree scroll_tree = 7;
inline bool PropertyTrees::has_scroll_tree() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PropertyTrees::set_has_scroll_tree() {
_has_bits_[0] |= 0x00000008u;
}
inline void PropertyTrees::clear_has_scroll_tree() {
_has_bits_[0] &= ~0x00000008u;
}
inline void PropertyTrees::clear_scroll_tree() {
if (scroll_tree_ != NULL) scroll_tree_->::cc::proto::PropertyTree::Clear();
clear_has_scroll_tree();
}
inline const ::cc::proto::PropertyTree& PropertyTrees::scroll_tree() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.scroll_tree)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return scroll_tree_ != NULL ? *scroll_tree_ : *default_instance().scroll_tree_;
#else
return scroll_tree_ != NULL ? *scroll_tree_ : *default_instance_->scroll_tree_;
#endif
}
inline ::cc::proto::PropertyTree* PropertyTrees::mutable_scroll_tree() {
set_has_scroll_tree();
if (scroll_tree_ == NULL) {
scroll_tree_ = new ::cc::proto::PropertyTree;
}
// @@protoc_insertion_point(field_mutable:cc.proto.PropertyTrees.scroll_tree)
return scroll_tree_;
}
inline ::cc::proto::PropertyTree* PropertyTrees::release_scroll_tree() {
// @@protoc_insertion_point(field_release:cc.proto.PropertyTrees.scroll_tree)
clear_has_scroll_tree();
::cc::proto::PropertyTree* temp = scroll_tree_;
scroll_tree_ = NULL;
return temp;
}
inline void PropertyTrees::set_allocated_scroll_tree(::cc::proto::PropertyTree* scroll_tree) {
delete scroll_tree_;
scroll_tree_ = scroll_tree;
if (scroll_tree) {
set_has_scroll_tree();
} else {
clear_has_scroll_tree();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.PropertyTrees.scroll_tree)
}

// optional bool needs_rebuild = 4;
inline bool PropertyTrees::has_needs_rebuild() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PropertyTrees::set_has_needs_rebuild() {
_has_bits_[0] |= 0x00000010u;
}
inline void PropertyTrees::clear_has_needs_rebuild() {
_has_bits_[0] &= ~0x00000010u;
}
inline void PropertyTrees::clear_needs_rebuild() {
needs_rebuild_ = false;
clear_has_needs_rebuild();
}
inline bool PropertyTrees::needs_rebuild() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.needs_rebuild)
return needs_rebuild_;
}
inline void PropertyTrees::set_needs_rebuild(bool value) {
set_has_needs_rebuild();
needs_rebuild_ = value;
// @@protoc_insertion_point(field_set:cc.proto.PropertyTrees.needs_rebuild)
}

// optional bool non_root_surfaces_enabled = 5;
inline bool PropertyTrees::has_non_root_surfaces_enabled() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PropertyTrees::set_has_non_root_surfaces_enabled() {
_has_bits_[0] |= 0x00000020u;
}
inline void PropertyTrees::clear_has_non_root_surfaces_enabled() {
_has_bits_[0] &= ~0x00000020u;
}
inline void PropertyTrees::clear_non_root_surfaces_enabled() {
non_root_surfaces_enabled_ = false;
clear_has_non_root_surfaces_enabled();
}
inline bool PropertyTrees::non_root_surfaces_enabled() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.non_root_surfaces_enabled)
return non_root_surfaces_enabled_;
}
inline void PropertyTrees::set_non_root_surfaces_enabled(bool value) {
set_has_non_root_surfaces_enabled();
non_root_surfaces_enabled_ = value;
// @@protoc_insertion_point(field_set:cc.proto.PropertyTrees.non_root_surfaces_enabled)
}

// optional bool changed = 11;
inline bool PropertyTrees::has_changed() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PropertyTrees::set_has_changed() {
_has_bits_[0] |= 0x00000040u;
}
inline void PropertyTrees::clear_has_changed() {
_has_bits_[0] &= ~0x00000040u;
}
inline void PropertyTrees::clear_changed() {
changed_ = false;
clear_has_changed();
}
inline bool PropertyTrees::changed() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.changed)
return changed_;
}
inline void PropertyTrees::set_changed(bool value) {
set_has_changed();
changed_ = value;
// @@protoc_insertion_point(field_set:cc.proto.PropertyTrees.changed)
}

// optional bool full_tree_damaged = 12;
inline bool PropertyTrees::has_full_tree_damaged() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PropertyTrees::set_has_full_tree_damaged() {
_has_bits_[0] |= 0x00000080u;
}
inline void PropertyTrees::clear_has_full_tree_damaged() {
_has_bits_[0] &= ~0x00000080u;
}
inline void PropertyTrees::clear_full_tree_damaged() {
full_tree_damaged_ = false;
clear_has_full_tree_damaged();
}
inline bool PropertyTrees::full_tree_damaged() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.full_tree_damaged)
return full_tree_damaged_;
}
inline void PropertyTrees::set_full_tree_damaged(bool value) {
set_has_full_tree_damaged();
full_tree_damaged_ = value;
// @@protoc_insertion_point(field_set:cc.proto.PropertyTrees.full_tree_damaged)
}

// optional int64 sequence_number = 6;
inline bool PropertyTrees::has_sequence_number() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PropertyTrees::set_has_sequence_number() {
_has_bits_[0] |= 0x00000100u;
}
inline void PropertyTrees::clear_has_sequence_number() {
_has_bits_[0] &= ~0x00000100u;
}
inline void PropertyTrees::clear_sequence_number() {
sequence_number_ = GOOGLE_LONGLONG(0);
clear_has_sequence_number();
}
inline ::google::protobuf::int64 PropertyTrees::sequence_number() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.sequence_number)
return sequence_number_;
}
inline void PropertyTrees::set_sequence_number(::google::protobuf::int64 value) {
set_has_sequence_number();
sequence_number_ = value;
// @@protoc_insertion_point(field_set:cc.proto.PropertyTrees.sequence_number)
}

// optional bool is_main_thread = 13;
inline bool PropertyTrees::has_is_main_thread() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PropertyTrees::set_has_is_main_thread() {
_has_bits_[0] |= 0x00000200u;
}
inline void PropertyTrees::clear_has_is_main_thread() {
_has_bits_[0] &= ~0x00000200u;
}
inline void PropertyTrees::clear_is_main_thread() {
is_main_thread_ = false;
clear_has_is_main_thread();
}
inline bool PropertyTrees::is_main_thread() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.is_main_thread)
return is_main_thread_;
}
inline void PropertyTrees::set_is_main_thread(bool value) {
set_has_is_main_thread();
is_main_thread_ = value;
// @@protoc_insertion_point(field_set:cc.proto.PropertyTrees.is_main_thread)
}

// optional bool is_active = 14;
inline bool PropertyTrees::has_is_active() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PropertyTrees::set_has_is_active() {
_has_bits_[0] |= 0x00000400u;
}
inline void PropertyTrees::clear_has_is_active() {
_has_bits_[0] &= ~0x00000400u;
}
inline void PropertyTrees::clear_is_active() {
is_active_ = false;
clear_has_is_active();
}
inline bool PropertyTrees::is_active() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.is_active)
return is_active_;
}
inline void PropertyTrees::set_is_active(bool value) {
set_has_is_active();
is_active_ = value;
// @@protoc_insertion_point(field_set:cc.proto.PropertyTrees.is_active)
}

// optional bool verify_transform_tree_calculations = 16;
inline bool PropertyTrees::has_verify_transform_tree_calculations() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PropertyTrees::set_has_verify_transform_tree_calculations() {
_has_bits_[0] |= 0x00000800u;
}
inline void PropertyTrees::clear_has_verify_transform_tree_calculations() {
_has_bits_[0] &= ~0x00000800u;
}
inline void PropertyTrees::clear_verify_transform_tree_calculations() {
verify_transform_tree_calculations_ = false;
clear_has_verify_transform_tree_calculations();
}
inline bool PropertyTrees::verify_transform_tree_calculations() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.verify_transform_tree_calculations)
return verify_transform_tree_calculations_;
}
inline void PropertyTrees::set_verify_transform_tree_calculations(bool value) {
set_has_verify_transform_tree_calculations();
verify_transform_tree_calculations_ = value;
// @@protoc_insertion_point(field_set:cc.proto.PropertyTrees.verify_transform_tree_calculations)
}

// optional .cc.proto.Vector2dF inner_viewport_container_bounds_delta = 8;
inline bool PropertyTrees::has_inner_viewport_container_bounds_delta() const {
return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PropertyTrees::set_has_inner_viewport_container_bounds_delta() {
_has_bits_[0] |= 0x00001000u;
}
inline void PropertyTrees::clear_has_inner_viewport_container_bounds_delta() {
_has_bits_[0] &= ~0x00001000u;
}
inline void PropertyTrees::clear_inner_viewport_container_bounds_delta() {
if (inner_viewport_container_bounds_delta_ != NULL) inner_viewport_container_bounds_delta_->::cc::proto::Vector2dF::Clear();
clear_has_inner_viewport_container_bounds_delta();
}
inline const ::cc::proto::Vector2dF& PropertyTrees::inner_viewport_container_bounds_delta() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.inner_viewport_container_bounds_delta)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return inner_viewport_container_bounds_delta_ != NULL ? *inner_viewport_container_bounds_delta_ : *default_instance().inner_viewport_container_bounds_delta_;
#else
return inner_viewport_container_bounds_delta_ != NULL ? *inner_viewport_container_bounds_delta_ : *default_instance_->inner_viewport_container_bounds_delta_;
#endif
}
inline ::cc::proto::Vector2dF* PropertyTrees::mutable_inner_viewport_container_bounds_delta() {
set_has_inner_viewport_container_bounds_delta();
if (inner_viewport_container_bounds_delta_ == NULL) {
inner_viewport_container_bounds_delta_ = new ::cc::proto::Vector2dF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.PropertyTrees.inner_viewport_container_bounds_delta)
return inner_viewport_container_bounds_delta_;
}
inline ::cc::proto::Vector2dF* PropertyTrees::release_inner_viewport_container_bounds_delta() {
// @@protoc_insertion_point(field_release:cc.proto.PropertyTrees.inner_viewport_container_bounds_delta)
clear_has_inner_viewport_container_bounds_delta();
::cc::proto::Vector2dF* temp = inner_viewport_container_bounds_delta_;
inner_viewport_container_bounds_delta_ = NULL;
return temp;
}
inline void PropertyTrees::set_allocated_inner_viewport_container_bounds_delta(::cc::proto::Vector2dF* inner_viewport_container_bounds_delta) {
delete inner_viewport_container_bounds_delta_;
inner_viewport_container_bounds_delta_ = inner_viewport_container_bounds_delta;
if (inner_viewport_container_bounds_delta) {
set_has_inner_viewport_container_bounds_delta();
} else {
clear_has_inner_viewport_container_bounds_delta();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.PropertyTrees.inner_viewport_container_bounds_delta)
}

// optional .cc.proto.Vector2dF outer_viewport_container_bounds_delta = 9;
inline bool PropertyTrees::has_outer_viewport_container_bounds_delta() const {
return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PropertyTrees::set_has_outer_viewport_container_bounds_delta() {
_has_bits_[0] |= 0x00002000u;
}
inline void PropertyTrees::clear_has_outer_viewport_container_bounds_delta() {
_has_bits_[0] &= ~0x00002000u;
}
inline void PropertyTrees::clear_outer_viewport_container_bounds_delta() {
if (outer_viewport_container_bounds_delta_ != NULL) outer_viewport_container_bounds_delta_->::cc::proto::Vector2dF::Clear();
clear_has_outer_viewport_container_bounds_delta();
}
inline const ::cc::proto::Vector2dF& PropertyTrees::outer_viewport_container_bounds_delta() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.outer_viewport_container_bounds_delta)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return outer_viewport_container_bounds_delta_ != NULL ? *outer_viewport_container_bounds_delta_ : *default_instance().outer_viewport_container_bounds_delta_;
#else
return outer_viewport_container_bounds_delta_ != NULL ? *outer_viewport_container_bounds_delta_ : *default_instance_->outer_viewport_container_bounds_delta_;
#endif
}
inline ::cc::proto::Vector2dF* PropertyTrees::mutable_outer_viewport_container_bounds_delta() {
set_has_outer_viewport_container_bounds_delta();
if (outer_viewport_container_bounds_delta_ == NULL) {
outer_viewport_container_bounds_delta_ = new ::cc::proto::Vector2dF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.PropertyTrees.outer_viewport_container_bounds_delta)
return outer_viewport_container_bounds_delta_;
}
inline ::cc::proto::Vector2dF* PropertyTrees::release_outer_viewport_container_bounds_delta() {
// @@protoc_insertion_point(field_release:cc.proto.PropertyTrees.outer_viewport_container_bounds_delta)
clear_has_outer_viewport_container_bounds_delta();
::cc::proto::Vector2dF* temp = outer_viewport_container_bounds_delta_;
outer_viewport_container_bounds_delta_ = NULL;
return temp;
}
inline void PropertyTrees::set_allocated_outer_viewport_container_bounds_delta(::cc::proto::Vector2dF* outer_viewport_container_bounds_delta) {
delete outer_viewport_container_bounds_delta_;
outer_viewport_container_bounds_delta_ = outer_viewport_container_bounds_delta;
if (outer_viewport_container_bounds_delta) {
set_has_outer_viewport_container_bounds_delta();
} else {
clear_has_outer_viewport_container_bounds_delta();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.PropertyTrees.outer_viewport_container_bounds_delta)
}

// optional .cc.proto.Vector2dF inner_viewport_scroll_bounds_delta = 10;
inline bool PropertyTrees::has_inner_viewport_scroll_bounds_delta() const {
return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PropertyTrees::set_has_inner_viewport_scroll_bounds_delta() {
_has_bits_[0] |= 0x00004000u;
}
inline void PropertyTrees::clear_has_inner_viewport_scroll_bounds_delta() {
_has_bits_[0] &= ~0x00004000u;
}
inline void PropertyTrees::clear_inner_viewport_scroll_bounds_delta() {
if (inner_viewport_scroll_bounds_delta_ != NULL) inner_viewport_scroll_bounds_delta_->::cc::proto::Vector2dF::Clear();
clear_has_inner_viewport_scroll_bounds_delta();
}
inline const ::cc::proto::Vector2dF& PropertyTrees::inner_viewport_scroll_bounds_delta() const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.inner_viewport_scroll_bounds_delta)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return inner_viewport_scroll_bounds_delta_ != NULL ? *inner_viewport_scroll_bounds_delta_ : *default_instance().inner_viewport_scroll_bounds_delta_;
#else
return inner_viewport_scroll_bounds_delta_ != NULL ? *inner_viewport_scroll_bounds_delta_ : *default_instance_->inner_viewport_scroll_bounds_delta_;
#endif
}
inline ::cc::proto::Vector2dF* PropertyTrees::mutable_inner_viewport_scroll_bounds_delta() {
set_has_inner_viewport_scroll_bounds_delta();
if (inner_viewport_scroll_bounds_delta_ == NULL) {
inner_viewport_scroll_bounds_delta_ = new ::cc::proto::Vector2dF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.PropertyTrees.inner_viewport_scroll_bounds_delta)
return inner_viewport_scroll_bounds_delta_;
}
inline ::cc::proto::Vector2dF* PropertyTrees::release_inner_viewport_scroll_bounds_delta() {
// @@protoc_insertion_point(field_release:cc.proto.PropertyTrees.inner_viewport_scroll_bounds_delta)
clear_has_inner_viewport_scroll_bounds_delta();
::cc::proto::Vector2dF* temp = inner_viewport_scroll_bounds_delta_;
inner_viewport_scroll_bounds_delta_ = NULL;
return temp;
}
inline void PropertyTrees::set_allocated_inner_viewport_scroll_bounds_delta(::cc::proto::Vector2dF* inner_viewport_scroll_bounds_delta) {
delete inner_viewport_scroll_bounds_delta_;
inner_viewport_scroll_bounds_delta_ = inner_viewport_scroll_bounds_delta;
if (inner_viewport_scroll_bounds_delta) {
set_has_inner_viewport_scroll_bounds_delta();
} else {
clear_has_inner_viewport_scroll_bounds_delta();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.PropertyTrees.inner_viewport_scroll_bounds_delta)
}

// repeated int64 always_use_active_tree_opacity_effect_ids = 15 [packed = true];
inline int PropertyTrees::always_use_active_tree_opacity_effect_ids_size() const {
return always_use_active_tree_opacity_effect_ids_.size();
}
inline void PropertyTrees::clear_always_use_active_tree_opacity_effect_ids() {
always_use_active_tree_opacity_effect_ids_.Clear();
}
inline ::google::protobuf::int64 PropertyTrees::always_use_active_tree_opacity_effect_ids(int index) const {
// @@protoc_insertion_point(field_get:cc.proto.PropertyTrees.always_use_active_tree_opacity_effect_ids)
return always_use_active_tree_opacity_effect_ids_.Get(index);
}
inline void PropertyTrees::set_always_use_active_tree_opacity_effect_ids(int index, ::google::protobuf::int64 value) {
always_use_active_tree_opacity_effect_ids_.Set(index, value);
// @@protoc_insertion_point(field_set:cc.proto.PropertyTrees.always_use_active_tree_opacity_effect_ids)
}
inline void PropertyTrees::add_always_use_active_tree_opacity_effect_ids(::google::protobuf::int64 value) {
always_use_active_tree_opacity_effect_ids_.Add(value);
// @@protoc_insertion_point(field_add:cc.proto.PropertyTrees.always_use_active_tree_opacity_effect_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
PropertyTrees::always_use_active_tree_opacity_effect_ids() const {
// @@protoc_insertion_point(field_list:cc.proto.PropertyTrees.always_use_active_tree_opacity_effect_ids)
return always_use_active_tree_opacity_effect_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
PropertyTrees::mutable_always_use_active_tree_opacity_effect_ids() {
// @@protoc_insertion_point(field_mutable_list:cc.proto.PropertyTrees.always_use_active_tree_opacity_effect_ids)
return &always_use_active_tree_opacity_effect_ids_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cc::proto::PropertyTree_PropertyType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_property_5ftree_2eproto__INCLUDED
