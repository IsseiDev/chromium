// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: layer_tree_host.proto

#ifndef PROTOBUF_layer_5ftree_5fhost_2eproto__INCLUDED
#define PROTOBUF_layer_5ftree_5fhost_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "display_item.pb.h"
#include "layer.pb.h"
#include "layer_tree.pb.h"
#include "layer_tree_debug_state.pb.h"
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

// Internal implementation detail -- do not call these.
void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
void protobuf_AssignDesc_layer_5ftree_5fhost_2eproto();
void protobuf_ShutdownFile_layer_5ftree_5fhost_2eproto();

class LayerTreeHost;
class SkPictureData;
class SkPictures;

// ===================================================================

class CC_PROTO_EXPORT SkPictureData : public ::google::protobuf::MessageLite {
public:
SkPictureData();
virtual ~SkPictureData();

SkPictureData(const SkPictureData& from);

inline SkPictureData& operator=(const SkPictureData& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const SkPictureData& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const SkPictureData* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(SkPictureData* other);

// implements Message ----------------------------------------------

inline SkPictureData* New() const { return New(NULL); }

SkPictureData* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const SkPictureData& from);
void MergeFrom(const SkPictureData& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(SkPictureData* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional .cc.proto.SkPictureID id = 1;
bool has_id() const;
void clear_id();
static const int kIdFieldNumber = 1;
const ::cc::proto::SkPictureID& id() const;
::cc::proto::SkPictureID* mutable_id();
::cc::proto::SkPictureID* release_id();
void set_allocated_id(::cc::proto::SkPictureID* id);

// optional bytes payload = 2;
bool has_payload() const;
void clear_payload();
static const int kPayloadFieldNumber = 2;
const ::std::string& payload() const;
void set_payload(const ::std::string& value);
void set_payload(const char* value);
void set_payload(const void* value, size_t size);
::std::string* mutable_payload();
::std::string* release_payload();
void set_allocated_payload(::std::string* payload);

// @@protoc_insertion_point(class_scope:cc.proto.SkPictureData)
private:
inline void set_has_id();
inline void clear_has_id();
inline void set_has_payload();
inline void clear_has_payload();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::cc::proto::SkPictureID* id_;
::google::protobuf::internal::ArenaStringPtr payload_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fhost_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
#endif
friend void protobuf_AssignDesc_layer_5ftree_5fhost_2eproto();
friend void protobuf_ShutdownFile_layer_5ftree_5fhost_2eproto();

void InitAsDefaultInstance();
static SkPictureData* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT SkPictures : public ::google::protobuf::MessageLite {
public:
SkPictures();
virtual ~SkPictures();

SkPictures(const SkPictures& from);

inline SkPictures& operator=(const SkPictures& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const SkPictures& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const SkPictures* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(SkPictures* other);

// implements Message ----------------------------------------------

inline SkPictures* New() const { return New(NULL); }

SkPictures* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const SkPictures& from);
void MergeFrom(const SkPictures& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(SkPictures* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// repeated .cc.proto.SkPictureData pictures = 1;
int pictures_size() const;
void clear_pictures();
static const int kPicturesFieldNumber = 1;
const ::cc::proto::SkPictureData& pictures(int index) const;
::cc::proto::SkPictureData* mutable_pictures(int index);
::cc::proto::SkPictureData* add_pictures();
::google::protobuf::RepeatedPtrField< ::cc::proto::SkPictureData >*
mutable_pictures();
const ::google::protobuf::RepeatedPtrField< ::cc::proto::SkPictureData >&
pictures() const;

// @@protoc_insertion_point(class_scope:cc.proto.SkPictures)
private:

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::google::protobuf::RepeatedPtrField< ::cc::proto::SkPictureData > pictures_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fhost_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
#endif
friend void protobuf_AssignDesc_layer_5ftree_5fhost_2eproto();
friend void protobuf_ShutdownFile_layer_5ftree_5fhost_2eproto();

void InitAsDefaultInstance();
static SkPictures* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT LayerTreeHost : public ::google::protobuf::MessageLite {
public:
LayerTreeHost();
virtual ~LayerTreeHost();

LayerTreeHost(const LayerTreeHost& from);

inline LayerTreeHost& operator=(const LayerTreeHost& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const LayerTreeHost& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const LayerTreeHost* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(LayerTreeHost* other);

// implements Message ----------------------------------------------

inline LayerTreeHost* New() const { return New(NULL); }

LayerTreeHost* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const LayerTreeHost& from);
void MergeFrom(const LayerTreeHost& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(LayerTreeHost* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional int32 source_frame_number = 3;
bool has_source_frame_number() const;
void clear_source_frame_number();
static const int kSourceFrameNumberFieldNumber = 3;
::google::protobuf::int32 source_frame_number() const;
void set_source_frame_number(::google::protobuf::int32 value);

// optional int32 meta_information_sequence_number = 4;
bool has_meta_information_sequence_number() const;
void clear_meta_information_sequence_number();
static const int kMetaInformationSequenceNumberFieldNumber = 4;
::google::protobuf::int32 meta_information_sequence_number() const;
void set_meta_information_sequence_number(::google::protobuf::int32 value);

// optional .cc.proto.LayerTreeDebugState debug_state = 8;
bool has_debug_state() const;
void clear_debug_state();
static const int kDebugStateFieldNumber = 8;
const ::cc::proto::LayerTreeDebugState& debug_state() const;
::cc::proto::LayerTreeDebugState* mutable_debug_state();
::cc::proto::LayerTreeDebugState* release_debug_state();
void set_allocated_debug_state(::cc::proto::LayerTreeDebugState* debug_state);

// optional bool has_gpu_rasterization_trigger = 19;
bool has_has_gpu_rasterization_trigger() const;
void clear_has_gpu_rasterization_trigger();
static const int kHasGpuRasterizationTriggerFieldNumber = 19;
bool has_gpu_rasterization_trigger() const;
void set_has_gpu_rasterization_trigger(bool value);

// optional bool content_is_suitable_for_gpu_rasterization = 20;
bool has_content_is_suitable_for_gpu_rasterization() const;
void clear_content_is_suitable_for_gpu_rasterization();
static const int kContentIsSuitableForGpuRasterizationFieldNumber = 20;
bool content_is_suitable_for_gpu_rasterization() const;
void set_content_is_suitable_for_gpu_rasterization(bool value);

// optional int32 id = 23;
bool has_id() const;
void clear_id();
static const int kIdFieldNumber = 23;
::google::protobuf::int32 id() const;
void set_id(::google::protobuf::int32 value);

// optional bool next_commit_forces_redraw = 24;
bool has_next_commit_forces_redraw() const;
void clear_next_commit_forces_redraw();
static const int kNextCommitForcesRedrawFieldNumber = 24;
bool next_commit_forces_redraw() const;
void set_next_commit_forces_redraw(bool value);

// optional uint32 surface_client_id = 31;
bool has_surface_client_id() const;
void clear_surface_client_id();
static const int kSurfaceClientIdFieldNumber = 31;
::google::protobuf::uint32 surface_client_id() const;
void set_surface_client_id(::google::protobuf::uint32 value);

// optional uint32 next_surface_sequence = 32;
bool has_next_surface_sequence() const;
void clear_next_surface_sequence();
static const int kNextSurfaceSequenceFieldNumber = 32;
::google::protobuf::uint32 next_surface_sequence() const;
void set_next_surface_sequence(::google::protobuf::uint32 value);

// optional .cc.proto.LayerTree layer_tree = 36;
bool has_layer_tree() const;
void clear_layer_tree();
static const int kLayerTreeFieldNumber = 36;
const ::cc::proto::LayerTree& layer_tree() const;
::cc::proto::LayerTree* mutable_layer_tree();
::cc::proto::LayerTree* release_layer_tree();
void set_allocated_layer_tree(::cc::proto::LayerTree* layer_tree);

// optional .cc.proto.LayerUpdate layer_updates = 28;
bool has_layer_updates() const;
void clear_layer_updates();
static const int kLayerUpdatesFieldNumber = 28;
const ::cc::proto::LayerUpdate& layer_updates() const;
::cc::proto::LayerUpdate* mutable_layer_updates();
::cc::proto::LayerUpdate* release_layer_updates();
void set_allocated_layer_updates(::cc::proto::LayerUpdate* layer_updates);

// optional .cc.proto.SkPictures pictures = 38;
bool has_pictures() const;
void clear_pictures();
static const int kPicturesFieldNumber = 38;
const ::cc::proto::SkPictures& pictures() const;
::cc::proto::SkPictures* mutable_pictures();
::cc::proto::SkPictures* release_pictures();
void set_allocated_pictures(::cc::proto::SkPictures* pictures);

// @@protoc_insertion_point(class_scope:cc.proto.LayerTreeHost)
private:
inline void set_has_source_frame_number();
inline void clear_has_source_frame_number();
inline void set_has_meta_information_sequence_number();
inline void clear_has_meta_information_sequence_number();
inline void set_has_debug_state();
inline void clear_has_debug_state();
inline void set_has_has_gpu_rasterization_trigger();
inline void clear_has_has_gpu_rasterization_trigger();
inline void set_has_content_is_suitable_for_gpu_rasterization();
inline void clear_has_content_is_suitable_for_gpu_rasterization();
inline void set_has_id();
inline void clear_has_id();
inline void set_has_next_commit_forces_redraw();
inline void clear_has_next_commit_forces_redraw();
inline void set_has_surface_client_id();
inline void clear_has_surface_client_id();
inline void set_has_next_surface_sequence();
inline void clear_has_next_surface_sequence();
inline void set_has_layer_tree();
inline void clear_has_layer_tree();
inline void set_has_layer_updates();
inline void clear_has_layer_updates();
inline void set_has_pictures();
inline void clear_has_pictures();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::google::protobuf::int32 source_frame_number_;
::google::protobuf::int32 meta_information_sequence_number_;
::cc::proto::LayerTreeDebugState* debug_state_;
bool has_gpu_rasterization_trigger_;
bool content_is_suitable_for_gpu_rasterization_;
bool next_commit_forces_redraw_;
::google::protobuf::int32 id_;
::google::protobuf::uint32 surface_client_id_;
::google::protobuf::uint32 next_surface_sequence_;
::cc::proto::LayerTree* layer_tree_;
::cc::proto::LayerUpdate* layer_updates_;
::cc::proto::SkPictures* pictures_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fhost_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fhost_2eproto();
#endif
friend void protobuf_AssignDesc_layer_5ftree_5fhost_2eproto();
friend void protobuf_ShutdownFile_layer_5ftree_5fhost_2eproto();

void InitAsDefaultInstance();
static LayerTreeHost* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// SkPictureData

// optional .cc.proto.SkPictureID id = 1;
inline bool SkPictureData::has_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkPictureData::set_has_id() {
_has_bits_[0] |= 0x00000001u;
}
inline void SkPictureData::clear_has_id() {
_has_bits_[0] &= ~0x00000001u;
}
inline void SkPictureData::clear_id() {
if (id_ != NULL) id_->::cc::proto::SkPictureID::Clear();
clear_has_id();
}
inline const ::cc::proto::SkPictureID& SkPictureData::id() const {
// @@protoc_insertion_point(field_get:cc.proto.SkPictureData.id)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return id_ != NULL ? *id_ : *default_instance().id_;
#else
return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
inline ::cc::proto::SkPictureID* SkPictureData::mutable_id() {
set_has_id();
if (id_ == NULL) {
id_ = new ::cc::proto::SkPictureID;
}
// @@protoc_insertion_point(field_mutable:cc.proto.SkPictureData.id)
return id_;
}
inline ::cc::proto::SkPictureID* SkPictureData::release_id() {
// @@protoc_insertion_point(field_release:cc.proto.SkPictureData.id)
clear_has_id();
::cc::proto::SkPictureID* temp = id_;
id_ = NULL;
return temp;
}
inline void SkPictureData::set_allocated_id(::cc::proto::SkPictureID* id) {
delete id_;
id_ = id;
if (id) {
set_has_id();
} else {
clear_has_id();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.SkPictureData.id)
}

// optional bytes payload = 2;
inline bool SkPictureData::has_payload() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkPictureData::set_has_payload() {
_has_bits_[0] |= 0x00000002u;
}
inline void SkPictureData::clear_has_payload() {
_has_bits_[0] &= ~0x00000002u;
}
inline void SkPictureData::clear_payload() {
payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
clear_has_payload();
}
inline const ::std::string& SkPictureData::payload() const {
// @@protoc_insertion_point(field_get:cc.proto.SkPictureData.payload)
return payload_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SkPictureData::set_payload(const ::std::string& value) {
set_has_payload();
payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
// @@protoc_insertion_point(field_set:cc.proto.SkPictureData.payload)
}
inline void SkPictureData::set_payload(const char* value) {
set_has_payload();
payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
// @@protoc_insertion_point(field_set_char:cc.proto.SkPictureData.payload)
}
inline void SkPictureData::set_payload(const void* value, size_t size) {
set_has_payload();
payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
::std::string(reinterpret_cast<const char*>(value), size));
// @@protoc_insertion_point(field_set_pointer:cc.proto.SkPictureData.payload)
}
inline ::std::string* SkPictureData::mutable_payload() {
set_has_payload();
// @@protoc_insertion_point(field_mutable:cc.proto.SkPictureData.payload)
return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SkPictureData::release_payload() {
// @@protoc_insertion_point(field_release:cc.proto.SkPictureData.payload)
clear_has_payload();
return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SkPictureData::set_allocated_payload(::std::string* payload) {
if (payload != NULL) {
set_has_payload();
} else {
clear_has_payload();
}
payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
// @@protoc_insertion_point(field_set_allocated:cc.proto.SkPictureData.payload)
}

// -------------------------------------------------------------------

// SkPictures

// repeated .cc.proto.SkPictureData pictures = 1;
inline int SkPictures::pictures_size() const {
return pictures_.size();
}
inline void SkPictures::clear_pictures() {
pictures_.Clear();
}
inline const ::cc::proto::SkPictureData& SkPictures::pictures(int index) const {
// @@protoc_insertion_point(field_get:cc.proto.SkPictures.pictures)
return pictures_.Get(index);
}
inline ::cc::proto::SkPictureData* SkPictures::mutable_pictures(int index) {
// @@protoc_insertion_point(field_mutable:cc.proto.SkPictures.pictures)
return pictures_.Mutable(index);
}
inline ::cc::proto::SkPictureData* SkPictures::add_pictures() {
// @@protoc_insertion_point(field_add:cc.proto.SkPictures.pictures)
return pictures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cc::proto::SkPictureData >*
SkPictures::mutable_pictures() {
// @@protoc_insertion_point(field_mutable_list:cc.proto.SkPictures.pictures)
return &pictures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::SkPictureData >&
SkPictures::pictures() const {
// @@protoc_insertion_point(field_list:cc.proto.SkPictures.pictures)
return pictures_;
}

// -------------------------------------------------------------------

// LayerTreeHost

// optional int32 source_frame_number = 3;
inline bool LayerTreeHost::has_source_frame_number() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerTreeHost::set_has_source_frame_number() {
_has_bits_[0] |= 0x00000001u;
}
inline void LayerTreeHost::clear_has_source_frame_number() {
_has_bits_[0] &= ~0x00000001u;
}
inline void LayerTreeHost::clear_source_frame_number() {
source_frame_number_ = 0;
clear_has_source_frame_number();
}
inline ::google::protobuf::int32 LayerTreeHost::source_frame_number() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.source_frame_number)
return source_frame_number_;
}
inline void LayerTreeHost::set_source_frame_number(::google::protobuf::int32 value) {
set_has_source_frame_number();
source_frame_number_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.source_frame_number)
}

// optional int32 meta_information_sequence_number = 4;
inline bool LayerTreeHost::has_meta_information_sequence_number() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerTreeHost::set_has_meta_information_sequence_number() {
_has_bits_[0] |= 0x00000002u;
}
inline void LayerTreeHost::clear_has_meta_information_sequence_number() {
_has_bits_[0] &= ~0x00000002u;
}
inline void LayerTreeHost::clear_meta_information_sequence_number() {
meta_information_sequence_number_ = 0;
clear_has_meta_information_sequence_number();
}
inline ::google::protobuf::int32 LayerTreeHost::meta_information_sequence_number() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.meta_information_sequence_number)
return meta_information_sequence_number_;
}
inline void LayerTreeHost::set_meta_information_sequence_number(::google::protobuf::int32 value) {
set_has_meta_information_sequence_number();
meta_information_sequence_number_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.meta_information_sequence_number)
}

// optional .cc.proto.LayerTreeDebugState debug_state = 8;
inline bool LayerTreeHost::has_debug_state() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerTreeHost::set_has_debug_state() {
_has_bits_[0] |= 0x00000004u;
}
inline void LayerTreeHost::clear_has_debug_state() {
_has_bits_[0] &= ~0x00000004u;
}
inline void LayerTreeHost::clear_debug_state() {
if (debug_state_ != NULL) debug_state_->::cc::proto::LayerTreeDebugState::Clear();
clear_has_debug_state();
}
inline const ::cc::proto::LayerTreeDebugState& LayerTreeHost::debug_state() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.debug_state)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return debug_state_ != NULL ? *debug_state_ : *default_instance().debug_state_;
#else
return debug_state_ != NULL ? *debug_state_ : *default_instance_->debug_state_;
#endif
}
inline ::cc::proto::LayerTreeDebugState* LayerTreeHost::mutable_debug_state() {
set_has_debug_state();
if (debug_state_ == NULL) {
debug_state_ = new ::cc::proto::LayerTreeDebugState;
}
// @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeHost.debug_state)
return debug_state_;
}
inline ::cc::proto::LayerTreeDebugState* LayerTreeHost::release_debug_state() {
// @@protoc_insertion_point(field_release:cc.proto.LayerTreeHost.debug_state)
clear_has_debug_state();
::cc::proto::LayerTreeDebugState* temp = debug_state_;
debug_state_ = NULL;
return temp;
}
inline void LayerTreeHost::set_allocated_debug_state(::cc::proto::LayerTreeDebugState* debug_state) {
delete debug_state_;
debug_state_ = debug_state;
if (debug_state) {
set_has_debug_state();
} else {
clear_has_debug_state();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeHost.debug_state)
}

// optional bool has_gpu_rasterization_trigger = 19;
inline bool LayerTreeHost::has_has_gpu_rasterization_trigger() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayerTreeHost::set_has_has_gpu_rasterization_trigger() {
_has_bits_[0] |= 0x00000008u;
}
inline void LayerTreeHost::clear_has_has_gpu_rasterization_trigger() {
_has_bits_[0] &= ~0x00000008u;
}
inline void LayerTreeHost::clear_has_gpu_rasterization_trigger() {
has_gpu_rasterization_trigger_ = false;
clear_has_has_gpu_rasterization_trigger();
}
inline bool LayerTreeHost::has_gpu_rasterization_trigger() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.has_gpu_rasterization_trigger)
return has_gpu_rasterization_trigger_;
}
inline void LayerTreeHost::set_has_gpu_rasterization_trigger(bool value) {
set_has_has_gpu_rasterization_trigger();
has_gpu_rasterization_trigger_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.has_gpu_rasterization_trigger)
}

// optional bool content_is_suitable_for_gpu_rasterization = 20;
inline bool LayerTreeHost::has_content_is_suitable_for_gpu_rasterization() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LayerTreeHost::set_has_content_is_suitable_for_gpu_rasterization() {
_has_bits_[0] |= 0x00000010u;
}
inline void LayerTreeHost::clear_has_content_is_suitable_for_gpu_rasterization() {
_has_bits_[0] &= ~0x00000010u;
}
inline void LayerTreeHost::clear_content_is_suitable_for_gpu_rasterization() {
content_is_suitable_for_gpu_rasterization_ = false;
clear_has_content_is_suitable_for_gpu_rasterization();
}
inline bool LayerTreeHost::content_is_suitable_for_gpu_rasterization() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.content_is_suitable_for_gpu_rasterization)
return content_is_suitable_for_gpu_rasterization_;
}
inline void LayerTreeHost::set_content_is_suitable_for_gpu_rasterization(bool value) {
set_has_content_is_suitable_for_gpu_rasterization();
content_is_suitable_for_gpu_rasterization_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.content_is_suitable_for_gpu_rasterization)
}

// optional int32 id = 23;
inline bool LayerTreeHost::has_id() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LayerTreeHost::set_has_id() {
_has_bits_[0] |= 0x00000020u;
}
inline void LayerTreeHost::clear_has_id() {
_has_bits_[0] &= ~0x00000020u;
}
inline void LayerTreeHost::clear_id() {
id_ = 0;
clear_has_id();
}
inline ::google::protobuf::int32 LayerTreeHost::id() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.id)
return id_;
}
inline void LayerTreeHost::set_id(::google::protobuf::int32 value) {
set_has_id();
id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.id)
}

// optional bool next_commit_forces_redraw = 24;
inline bool LayerTreeHost::has_next_commit_forces_redraw() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LayerTreeHost::set_has_next_commit_forces_redraw() {
_has_bits_[0] |= 0x00000040u;
}
inline void LayerTreeHost::clear_has_next_commit_forces_redraw() {
_has_bits_[0] &= ~0x00000040u;
}
inline void LayerTreeHost::clear_next_commit_forces_redraw() {
next_commit_forces_redraw_ = false;
clear_has_next_commit_forces_redraw();
}
inline bool LayerTreeHost::next_commit_forces_redraw() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.next_commit_forces_redraw)
return next_commit_forces_redraw_;
}
inline void LayerTreeHost::set_next_commit_forces_redraw(bool value) {
set_has_next_commit_forces_redraw();
next_commit_forces_redraw_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.next_commit_forces_redraw)
}

// optional uint32 surface_client_id = 31;
inline bool LayerTreeHost::has_surface_client_id() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LayerTreeHost::set_has_surface_client_id() {
_has_bits_[0] |= 0x00000080u;
}
inline void LayerTreeHost::clear_has_surface_client_id() {
_has_bits_[0] &= ~0x00000080u;
}
inline void LayerTreeHost::clear_surface_client_id() {
surface_client_id_ = 0u;
clear_has_surface_client_id();
}
inline ::google::protobuf::uint32 LayerTreeHost::surface_client_id() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.surface_client_id)
return surface_client_id_;
}
inline void LayerTreeHost::set_surface_client_id(::google::protobuf::uint32 value) {
set_has_surface_client_id();
surface_client_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.surface_client_id)
}

// optional uint32 next_surface_sequence = 32;
inline bool LayerTreeHost::has_next_surface_sequence() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LayerTreeHost::set_has_next_surface_sequence() {
_has_bits_[0] |= 0x00000100u;
}
inline void LayerTreeHost::clear_has_next_surface_sequence() {
_has_bits_[0] &= ~0x00000100u;
}
inline void LayerTreeHost::clear_next_surface_sequence() {
next_surface_sequence_ = 0u;
clear_has_next_surface_sequence();
}
inline ::google::protobuf::uint32 LayerTreeHost::next_surface_sequence() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.next_surface_sequence)
return next_surface_sequence_;
}
inline void LayerTreeHost::set_next_surface_sequence(::google::protobuf::uint32 value) {
set_has_next_surface_sequence();
next_surface_sequence_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeHost.next_surface_sequence)
}

// optional .cc.proto.LayerTree layer_tree = 36;
inline bool LayerTreeHost::has_layer_tree() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LayerTreeHost::set_has_layer_tree() {
_has_bits_[0] |= 0x00000200u;
}
inline void LayerTreeHost::clear_has_layer_tree() {
_has_bits_[0] &= ~0x00000200u;
}
inline void LayerTreeHost::clear_layer_tree() {
if (layer_tree_ != NULL) layer_tree_->::cc::proto::LayerTree::Clear();
clear_has_layer_tree();
}
inline const ::cc::proto::LayerTree& LayerTreeHost::layer_tree() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.layer_tree)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return layer_tree_ != NULL ? *layer_tree_ : *default_instance().layer_tree_;
#else
return layer_tree_ != NULL ? *layer_tree_ : *default_instance_->layer_tree_;
#endif
}
inline ::cc::proto::LayerTree* LayerTreeHost::mutable_layer_tree() {
set_has_layer_tree();
if (layer_tree_ == NULL) {
layer_tree_ = new ::cc::proto::LayerTree;
}
// @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeHost.layer_tree)
return layer_tree_;
}
inline ::cc::proto::LayerTree* LayerTreeHost::release_layer_tree() {
// @@protoc_insertion_point(field_release:cc.proto.LayerTreeHost.layer_tree)
clear_has_layer_tree();
::cc::proto::LayerTree* temp = layer_tree_;
layer_tree_ = NULL;
return temp;
}
inline void LayerTreeHost::set_allocated_layer_tree(::cc::proto::LayerTree* layer_tree) {
delete layer_tree_;
layer_tree_ = layer_tree;
if (layer_tree) {
set_has_layer_tree();
} else {
clear_has_layer_tree();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeHost.layer_tree)
}

// optional .cc.proto.LayerUpdate layer_updates = 28;
inline bool LayerTreeHost::has_layer_updates() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LayerTreeHost::set_has_layer_updates() {
_has_bits_[0] |= 0x00000400u;
}
inline void LayerTreeHost::clear_has_layer_updates() {
_has_bits_[0] &= ~0x00000400u;
}
inline void LayerTreeHost::clear_layer_updates() {
if (layer_updates_ != NULL) layer_updates_->::cc::proto::LayerUpdate::Clear();
clear_has_layer_updates();
}
inline const ::cc::proto::LayerUpdate& LayerTreeHost::layer_updates() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.layer_updates)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return layer_updates_ != NULL ? *layer_updates_ : *default_instance().layer_updates_;
#else
return layer_updates_ != NULL ? *layer_updates_ : *default_instance_->layer_updates_;
#endif
}
inline ::cc::proto::LayerUpdate* LayerTreeHost::mutable_layer_updates() {
set_has_layer_updates();
if (layer_updates_ == NULL) {
layer_updates_ = new ::cc::proto::LayerUpdate;
}
// @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeHost.layer_updates)
return layer_updates_;
}
inline ::cc::proto::LayerUpdate* LayerTreeHost::release_layer_updates() {
// @@protoc_insertion_point(field_release:cc.proto.LayerTreeHost.layer_updates)
clear_has_layer_updates();
::cc::proto::LayerUpdate* temp = layer_updates_;
layer_updates_ = NULL;
return temp;
}
inline void LayerTreeHost::set_allocated_layer_updates(::cc::proto::LayerUpdate* layer_updates) {
delete layer_updates_;
layer_updates_ = layer_updates;
if (layer_updates) {
set_has_layer_updates();
} else {
clear_has_layer_updates();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeHost.layer_updates)
}

// optional .cc.proto.SkPictures pictures = 38;
inline bool LayerTreeHost::has_pictures() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LayerTreeHost::set_has_pictures() {
_has_bits_[0] |= 0x00000800u;
}
inline void LayerTreeHost::clear_has_pictures() {
_has_bits_[0] &= ~0x00000800u;
}
inline void LayerTreeHost::clear_pictures() {
if (pictures_ != NULL) pictures_->::cc::proto::SkPictures::Clear();
clear_has_pictures();
}
inline const ::cc::proto::SkPictures& LayerTreeHost::pictures() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeHost.pictures)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return pictures_ != NULL ? *pictures_ : *default_instance().pictures_;
#else
return pictures_ != NULL ? *pictures_ : *default_instance_->pictures_;
#endif
}
inline ::cc::proto::SkPictures* LayerTreeHost::mutable_pictures() {
set_has_pictures();
if (pictures_ == NULL) {
pictures_ = new ::cc::proto::SkPictures;
}
// @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeHost.pictures)
return pictures_;
}
inline ::cc::proto::SkPictures* LayerTreeHost::release_pictures() {
// @@protoc_insertion_point(field_release:cc.proto.LayerTreeHost.pictures)
clear_has_pictures();
::cc::proto::SkPictures* temp = pictures_;
pictures_ = NULL;
return temp;
}
inline void LayerTreeHost::set_allocated_pictures(::cc::proto::SkPictures* pictures) {
delete pictures_;
pictures_ = pictures;
if (pictures) {
set_has_pictures();
} else {
clear_has_pictures();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeHost.pictures)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_layer_5ftree_5fhost_2eproto__INCLUDED
