// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: synced_property.proto

#ifndef PROTOBUF_synced_5fproperty_2eproto__INCLUDED
#define PROTOBUF_synced_5fproperty_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "scroll_offset.pb.h"
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

// Internal implementation detail -- do not call these.
void CC_PROTO_EXPORT protobuf_AddDesc_synced_5fproperty_2eproto();
void protobuf_AssignDesc_synced_5fproperty_2eproto();
void protobuf_ShutdownFile_synced_5fproperty_2eproto();

class ScrollOffsetGroup;
class SyncedProperty;

// ===================================================================

class CC_PROTO_EXPORT ScrollOffsetGroup : public ::google::protobuf::MessageLite {
public:
ScrollOffsetGroup();
virtual ~ScrollOffsetGroup();

ScrollOffsetGroup(const ScrollOffsetGroup& from);

inline ScrollOffsetGroup& operator=(const ScrollOffsetGroup& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const ScrollOffsetGroup& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const ScrollOffsetGroup* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(ScrollOffsetGroup* other);

// implements Message ----------------------------------------------

inline ScrollOffsetGroup* New() const { return New(NULL); }

ScrollOffsetGroup* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const ScrollOffsetGroup& from);
void MergeFrom(const ScrollOffsetGroup& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ScrollOffsetGroup* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional .cc.proto.ScrollOffset pending_base = 1;
bool has_pending_base() const;
void clear_pending_base();
static const int kPendingBaseFieldNumber = 1;
const ::cc::proto::ScrollOffset& pending_base() const;
::cc::proto::ScrollOffset* mutable_pending_base();
::cc::proto::ScrollOffset* release_pending_base();
void set_allocated_pending_base(::cc::proto::ScrollOffset* pending_base);

// optional .cc.proto.ScrollOffset pending_delta = 2;
bool has_pending_delta() const;
void clear_pending_delta();
static const int kPendingDeltaFieldNumber = 2;
const ::cc::proto::ScrollOffset& pending_delta() const;
::cc::proto::ScrollOffset* mutable_pending_delta();
::cc::proto::ScrollOffset* release_pending_delta();
void set_allocated_pending_delta(::cc::proto::ScrollOffset* pending_delta);

// optional .cc.proto.ScrollOffset active_base = 3;
bool has_active_base() const;
void clear_active_base();
static const int kActiveBaseFieldNumber = 3;
const ::cc::proto::ScrollOffset& active_base() const;
::cc::proto::ScrollOffset* mutable_active_base();
::cc::proto::ScrollOffset* release_active_base();
void set_allocated_active_base(::cc::proto::ScrollOffset* active_base);

// optional .cc.proto.ScrollOffset active_delta = 4;
bool has_active_delta() const;
void clear_active_delta();
static const int kActiveDeltaFieldNumber = 4;
const ::cc::proto::ScrollOffset& active_delta() const;
::cc::proto::ScrollOffset* mutable_active_delta();
::cc::proto::ScrollOffset* release_active_delta();
void set_allocated_active_delta(::cc::proto::ScrollOffset* active_delta);

// optional .cc.proto.ScrollOffset sent_delta = 5;
bool has_sent_delta() const;
void clear_sent_delta();
static const int kSentDeltaFieldNumber = 5;
const ::cc::proto::ScrollOffset& sent_delta() const;
::cc::proto::ScrollOffset* mutable_sent_delta();
::cc::proto::ScrollOffset* release_sent_delta();
void set_allocated_sent_delta(::cc::proto::ScrollOffset* sent_delta);

// @@protoc_insertion_point(class_scope:cc.proto.ScrollOffsetGroup)
private:
inline void set_has_pending_base();
inline void clear_has_pending_base();
inline void set_has_pending_delta();
inline void clear_has_pending_delta();
inline void set_has_active_base();
inline void clear_has_active_base();
inline void set_has_active_delta();
inline void clear_has_active_delta();
inline void set_has_sent_delta();
inline void clear_has_sent_delta();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::cc::proto::ScrollOffset* pending_base_;
::cc::proto::ScrollOffset* pending_delta_;
::cc::proto::ScrollOffset* active_base_;
::cc::proto::ScrollOffset* active_delta_;
::cc::proto::ScrollOffset* sent_delta_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_synced_5fproperty_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_synced_5fproperty_2eproto();
#endif
friend void protobuf_AssignDesc_synced_5fproperty_2eproto();
friend void protobuf_ShutdownFile_synced_5fproperty_2eproto();

void InitAsDefaultInstance();
static ScrollOffsetGroup* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT SyncedProperty : public ::google::protobuf::MessageLite {
public:
SyncedProperty();
virtual ~SyncedProperty();

SyncedProperty(const SyncedProperty& from);

inline SyncedProperty& operator=(const SyncedProperty& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const SyncedProperty& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const SyncedProperty* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(SyncedProperty* other);

// implements Message ----------------------------------------------

inline SyncedProperty* New() const { return New(NULL); }

SyncedProperty* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const SyncedProperty& from);
void MergeFrom(const SyncedProperty& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(SyncedProperty* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional bool clobber_active_value = 1;
bool has_clobber_active_value() const;
void clear_clobber_active_value();
static const int kClobberActiveValueFieldNumber = 1;
bool clobber_active_value() const;
void set_clobber_active_value(bool value);

// optional .cc.proto.ScrollOffsetGroup scroll_offset_group = 1001;
bool has_scroll_offset_group() const;
void clear_scroll_offset_group();
static const int kScrollOffsetGroupFieldNumber = 1001;
const ::cc::proto::ScrollOffsetGroup& scroll_offset_group() const;
::cc::proto::ScrollOffsetGroup* mutable_scroll_offset_group();
::cc::proto::ScrollOffsetGroup* release_scroll_offset_group();
void set_allocated_scroll_offset_group(::cc::proto::ScrollOffsetGroup* scroll_offset_group);

// @@protoc_insertion_point(class_scope:cc.proto.SyncedProperty)
private:
inline void set_has_clobber_active_value();
inline void clear_has_clobber_active_value();
inline void set_has_scroll_offset_group();
inline void clear_has_scroll_offset_group();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::cc::proto::ScrollOffsetGroup* scroll_offset_group_;
bool clobber_active_value_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_synced_5fproperty_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_synced_5fproperty_2eproto();
#endif
friend void protobuf_AssignDesc_synced_5fproperty_2eproto();
friend void protobuf_ShutdownFile_synced_5fproperty_2eproto();

void InitAsDefaultInstance();
static SyncedProperty* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ScrollOffsetGroup

// optional .cc.proto.ScrollOffset pending_base = 1;
inline bool ScrollOffsetGroup::has_pending_base() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScrollOffsetGroup::set_has_pending_base() {
_has_bits_[0] |= 0x00000001u;
}
inline void ScrollOffsetGroup::clear_has_pending_base() {
_has_bits_[0] &= ~0x00000001u;
}
inline void ScrollOffsetGroup::clear_pending_base() {
if (pending_base_ != NULL) pending_base_->::cc::proto::ScrollOffset::Clear();
clear_has_pending_base();
}
inline const ::cc::proto::ScrollOffset& ScrollOffsetGroup::pending_base() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollOffsetGroup.pending_base)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return pending_base_ != NULL ? *pending_base_ : *default_instance().pending_base_;
#else
return pending_base_ != NULL ? *pending_base_ : *default_instance_->pending_base_;
#endif
}
inline ::cc::proto::ScrollOffset* ScrollOffsetGroup::mutable_pending_base() {
set_has_pending_base();
if (pending_base_ == NULL) {
pending_base_ = new ::cc::proto::ScrollOffset;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollOffsetGroup.pending_base)
return pending_base_;
}
inline ::cc::proto::ScrollOffset* ScrollOffsetGroup::release_pending_base() {
// @@protoc_insertion_point(field_release:cc.proto.ScrollOffsetGroup.pending_base)
clear_has_pending_base();
::cc::proto::ScrollOffset* temp = pending_base_;
pending_base_ = NULL;
return temp;
}
inline void ScrollOffsetGroup::set_allocated_pending_base(::cc::proto::ScrollOffset* pending_base) {
delete pending_base_;
pending_base_ = pending_base;
if (pending_base) {
set_has_pending_base();
} else {
clear_has_pending_base();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollOffsetGroup.pending_base)
}

// optional .cc.proto.ScrollOffset pending_delta = 2;
inline bool ScrollOffsetGroup::has_pending_delta() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScrollOffsetGroup::set_has_pending_delta() {
_has_bits_[0] |= 0x00000002u;
}
inline void ScrollOffsetGroup::clear_has_pending_delta() {
_has_bits_[0] &= ~0x00000002u;
}
inline void ScrollOffsetGroup::clear_pending_delta() {
if (pending_delta_ != NULL) pending_delta_->::cc::proto::ScrollOffset::Clear();
clear_has_pending_delta();
}
inline const ::cc::proto::ScrollOffset& ScrollOffsetGroup::pending_delta() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollOffsetGroup.pending_delta)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return pending_delta_ != NULL ? *pending_delta_ : *default_instance().pending_delta_;
#else
return pending_delta_ != NULL ? *pending_delta_ : *default_instance_->pending_delta_;
#endif
}
inline ::cc::proto::ScrollOffset* ScrollOffsetGroup::mutable_pending_delta() {
set_has_pending_delta();
if (pending_delta_ == NULL) {
pending_delta_ = new ::cc::proto::ScrollOffset;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollOffsetGroup.pending_delta)
return pending_delta_;
}
inline ::cc::proto::ScrollOffset* ScrollOffsetGroup::release_pending_delta() {
// @@protoc_insertion_point(field_release:cc.proto.ScrollOffsetGroup.pending_delta)
clear_has_pending_delta();
::cc::proto::ScrollOffset* temp = pending_delta_;
pending_delta_ = NULL;
return temp;
}
inline void ScrollOffsetGroup::set_allocated_pending_delta(::cc::proto::ScrollOffset* pending_delta) {
delete pending_delta_;
pending_delta_ = pending_delta;
if (pending_delta) {
set_has_pending_delta();
} else {
clear_has_pending_delta();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollOffsetGroup.pending_delta)
}

// optional .cc.proto.ScrollOffset active_base = 3;
inline bool ScrollOffsetGroup::has_active_base() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScrollOffsetGroup::set_has_active_base() {
_has_bits_[0] |= 0x00000004u;
}
inline void ScrollOffsetGroup::clear_has_active_base() {
_has_bits_[0] &= ~0x00000004u;
}
inline void ScrollOffsetGroup::clear_active_base() {
if (active_base_ != NULL) active_base_->::cc::proto::ScrollOffset::Clear();
clear_has_active_base();
}
inline const ::cc::proto::ScrollOffset& ScrollOffsetGroup::active_base() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollOffsetGroup.active_base)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return active_base_ != NULL ? *active_base_ : *default_instance().active_base_;
#else
return active_base_ != NULL ? *active_base_ : *default_instance_->active_base_;
#endif
}
inline ::cc::proto::ScrollOffset* ScrollOffsetGroup::mutable_active_base() {
set_has_active_base();
if (active_base_ == NULL) {
active_base_ = new ::cc::proto::ScrollOffset;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollOffsetGroup.active_base)
return active_base_;
}
inline ::cc::proto::ScrollOffset* ScrollOffsetGroup::release_active_base() {
// @@protoc_insertion_point(field_release:cc.proto.ScrollOffsetGroup.active_base)
clear_has_active_base();
::cc::proto::ScrollOffset* temp = active_base_;
active_base_ = NULL;
return temp;
}
inline void ScrollOffsetGroup::set_allocated_active_base(::cc::proto::ScrollOffset* active_base) {
delete active_base_;
active_base_ = active_base;
if (active_base) {
set_has_active_base();
} else {
clear_has_active_base();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollOffsetGroup.active_base)
}

// optional .cc.proto.ScrollOffset active_delta = 4;
inline bool ScrollOffsetGroup::has_active_delta() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScrollOffsetGroup::set_has_active_delta() {
_has_bits_[0] |= 0x00000008u;
}
inline void ScrollOffsetGroup::clear_has_active_delta() {
_has_bits_[0] &= ~0x00000008u;
}
inline void ScrollOffsetGroup::clear_active_delta() {
if (active_delta_ != NULL) active_delta_->::cc::proto::ScrollOffset::Clear();
clear_has_active_delta();
}
inline const ::cc::proto::ScrollOffset& ScrollOffsetGroup::active_delta() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollOffsetGroup.active_delta)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return active_delta_ != NULL ? *active_delta_ : *default_instance().active_delta_;
#else
return active_delta_ != NULL ? *active_delta_ : *default_instance_->active_delta_;
#endif
}
inline ::cc::proto::ScrollOffset* ScrollOffsetGroup::mutable_active_delta() {
set_has_active_delta();
if (active_delta_ == NULL) {
active_delta_ = new ::cc::proto::ScrollOffset;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollOffsetGroup.active_delta)
return active_delta_;
}
inline ::cc::proto::ScrollOffset* ScrollOffsetGroup::release_active_delta() {
// @@protoc_insertion_point(field_release:cc.proto.ScrollOffsetGroup.active_delta)
clear_has_active_delta();
::cc::proto::ScrollOffset* temp = active_delta_;
active_delta_ = NULL;
return temp;
}
inline void ScrollOffsetGroup::set_allocated_active_delta(::cc::proto::ScrollOffset* active_delta) {
delete active_delta_;
active_delta_ = active_delta;
if (active_delta) {
set_has_active_delta();
} else {
clear_has_active_delta();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollOffsetGroup.active_delta)
}

// optional .cc.proto.ScrollOffset sent_delta = 5;
inline bool ScrollOffsetGroup::has_sent_delta() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScrollOffsetGroup::set_has_sent_delta() {
_has_bits_[0] |= 0x00000010u;
}
inline void ScrollOffsetGroup::clear_has_sent_delta() {
_has_bits_[0] &= ~0x00000010u;
}
inline void ScrollOffsetGroup::clear_sent_delta() {
if (sent_delta_ != NULL) sent_delta_->::cc::proto::ScrollOffset::Clear();
clear_has_sent_delta();
}
inline const ::cc::proto::ScrollOffset& ScrollOffsetGroup::sent_delta() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollOffsetGroup.sent_delta)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return sent_delta_ != NULL ? *sent_delta_ : *default_instance().sent_delta_;
#else
return sent_delta_ != NULL ? *sent_delta_ : *default_instance_->sent_delta_;
#endif
}
inline ::cc::proto::ScrollOffset* ScrollOffsetGroup::mutable_sent_delta() {
set_has_sent_delta();
if (sent_delta_ == NULL) {
sent_delta_ = new ::cc::proto::ScrollOffset;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollOffsetGroup.sent_delta)
return sent_delta_;
}
inline ::cc::proto::ScrollOffset* ScrollOffsetGroup::release_sent_delta() {
// @@protoc_insertion_point(field_release:cc.proto.ScrollOffsetGroup.sent_delta)
clear_has_sent_delta();
::cc::proto::ScrollOffset* temp = sent_delta_;
sent_delta_ = NULL;
return temp;
}
inline void ScrollOffsetGroup::set_allocated_sent_delta(::cc::proto::ScrollOffset* sent_delta) {
delete sent_delta_;
sent_delta_ = sent_delta;
if (sent_delta) {
set_has_sent_delta();
} else {
clear_has_sent_delta();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollOffsetGroup.sent_delta)
}

// -------------------------------------------------------------------

// SyncedProperty

// optional bool clobber_active_value = 1;
inline bool SyncedProperty::has_clobber_active_value() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncedProperty::set_has_clobber_active_value() {
_has_bits_[0] |= 0x00000001u;
}
inline void SyncedProperty::clear_has_clobber_active_value() {
_has_bits_[0] &= ~0x00000001u;
}
inline void SyncedProperty::clear_clobber_active_value() {
clobber_active_value_ = false;
clear_has_clobber_active_value();
}
inline bool SyncedProperty::clobber_active_value() const {
// @@protoc_insertion_point(field_get:cc.proto.SyncedProperty.clobber_active_value)
return clobber_active_value_;
}
inline void SyncedProperty::set_clobber_active_value(bool value) {
set_has_clobber_active_value();
clobber_active_value_ = value;
// @@protoc_insertion_point(field_set:cc.proto.SyncedProperty.clobber_active_value)
}

// optional .cc.proto.ScrollOffsetGroup scroll_offset_group = 1001;
inline bool SyncedProperty::has_scroll_offset_group() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncedProperty::set_has_scroll_offset_group() {
_has_bits_[0] |= 0x00000002u;
}
inline void SyncedProperty::clear_has_scroll_offset_group() {
_has_bits_[0] &= ~0x00000002u;
}
inline void SyncedProperty::clear_scroll_offset_group() {
if (scroll_offset_group_ != NULL) scroll_offset_group_->::cc::proto::ScrollOffsetGroup::Clear();
clear_has_scroll_offset_group();
}
inline const ::cc::proto::ScrollOffsetGroup& SyncedProperty::scroll_offset_group() const {
// @@protoc_insertion_point(field_get:cc.proto.SyncedProperty.scroll_offset_group)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return scroll_offset_group_ != NULL ? *scroll_offset_group_ : *default_instance().scroll_offset_group_;
#else
return scroll_offset_group_ != NULL ? *scroll_offset_group_ : *default_instance_->scroll_offset_group_;
#endif
}
inline ::cc::proto::ScrollOffsetGroup* SyncedProperty::mutable_scroll_offset_group() {
set_has_scroll_offset_group();
if (scroll_offset_group_ == NULL) {
scroll_offset_group_ = new ::cc::proto::ScrollOffsetGroup;
}
// @@protoc_insertion_point(field_mutable:cc.proto.SyncedProperty.scroll_offset_group)
return scroll_offset_group_;
}
inline ::cc::proto::ScrollOffsetGroup* SyncedProperty::release_scroll_offset_group() {
// @@protoc_insertion_point(field_release:cc.proto.SyncedProperty.scroll_offset_group)
clear_has_scroll_offset_group();
::cc::proto::ScrollOffsetGroup* temp = scroll_offset_group_;
scroll_offset_group_ = NULL;
return temp;
}
inline void SyncedProperty::set_allocated_scroll_offset_group(::cc::proto::ScrollOffsetGroup* scroll_offset_group) {
delete scroll_offset_group_;
scroll_offset_group_ = scroll_offset_group;
if (scroll_offset_group) {
set_has_scroll_offset_group();
} else {
clear_has_scroll_offset_group();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.SyncedProperty.scroll_offset_group)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_synced_5fproperty_2eproto__INCLUDED
