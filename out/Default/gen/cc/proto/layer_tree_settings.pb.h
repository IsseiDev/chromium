// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: layer_tree_settings.proto

#ifndef PROTOBUF_layer_5ftree_5fsettings_2eproto__INCLUDED
#define PROTOBUF_layer_5ftree_5fsettings_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include "layer_tree_debug_state.pb.h"
#include "managed_memory_policy.pb.h"
#include "renderer_settings.pb.h"
#include "size.pb.h"
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

// Internal implementation detail -- do not call these.
void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fsettings_2eproto();
void protobuf_AssignDesc_layer_5ftree_5fsettings_2eproto();
void protobuf_ShutdownFile_layer_5ftree_5fsettings_2eproto();

class LayerTreeSettings;

enum LayerTreeSettings_ScrollbarAnimator {
LayerTreeSettings_ScrollbarAnimator_UNKNOWN = 0,
LayerTreeSettings_ScrollbarAnimator_NO_ANIMATOR = 1,
LayerTreeSettings_ScrollbarAnimator_LINEAR_FADE = 2,
LayerTreeSettings_ScrollbarAnimator_THINNING = 3
};
CC_PROTO_EXPORT bool LayerTreeSettings_ScrollbarAnimator_IsValid(int value);
const LayerTreeSettings_ScrollbarAnimator LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_MIN = LayerTreeSettings_ScrollbarAnimator_UNKNOWN;
const LayerTreeSettings_ScrollbarAnimator LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_MAX = LayerTreeSettings_ScrollbarAnimator_THINNING;
const int LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_ARRAYSIZE = LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_MAX + 1;

// ===================================================================

class CC_PROTO_EXPORT LayerTreeSettings : public ::google::protobuf::MessageLite {
public:
LayerTreeSettings();
virtual ~LayerTreeSettings();

LayerTreeSettings(const LayerTreeSettings& from);

inline LayerTreeSettings& operator=(const LayerTreeSettings& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const LayerTreeSettings& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const LayerTreeSettings* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(LayerTreeSettings* other);

// implements Message ----------------------------------------------

inline LayerTreeSettings* New() const { return New(NULL); }

LayerTreeSettings* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const LayerTreeSettings& from);
void MergeFrom(const LayerTreeSettings& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(LayerTreeSettings* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

typedef LayerTreeSettings_ScrollbarAnimator ScrollbarAnimator;
static const ScrollbarAnimator UNKNOWN =
LayerTreeSettings_ScrollbarAnimator_UNKNOWN;
static const ScrollbarAnimator NO_ANIMATOR =
LayerTreeSettings_ScrollbarAnimator_NO_ANIMATOR;
static const ScrollbarAnimator LINEAR_FADE =
LayerTreeSettings_ScrollbarAnimator_LINEAR_FADE;
static const ScrollbarAnimator THINNING =
LayerTreeSettings_ScrollbarAnimator_THINNING;
static inline bool ScrollbarAnimator_IsValid(int value) {
return LayerTreeSettings_ScrollbarAnimator_IsValid(value);
}
static const ScrollbarAnimator ScrollbarAnimator_MIN =
LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_MIN;
static const ScrollbarAnimator ScrollbarAnimator_MAX =
LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_MAX;
static const int ScrollbarAnimator_ARRAYSIZE =
LayerTreeSettings_ScrollbarAnimator_ScrollbarAnimator_ARRAYSIZE;

// accessors -------------------------------------------------------

// optional .cc.proto.RendererSettings renderer_settings = 1;
bool has_renderer_settings() const;
void clear_renderer_settings();
static const int kRendererSettingsFieldNumber = 1;
const ::cc::proto::RendererSettings& renderer_settings() const;
::cc::proto::RendererSettings* mutable_renderer_settings();
::cc::proto::RendererSettings* release_renderer_settings();
void set_allocated_renderer_settings(::cc::proto::RendererSettings* renderer_settings);

// optional bool single_thread_proxy_scheduler = 2;
bool has_single_thread_proxy_scheduler() const;
void clear_single_thread_proxy_scheduler();
static const int kSingleThreadProxySchedulerFieldNumber = 2;
bool single_thread_proxy_scheduler() const;
void set_single_thread_proxy_scheduler(bool value);

// optional bool use_external_begin_frame_source = 3;
bool has_use_external_begin_frame_source() const;
void clear_use_external_begin_frame_source();
static const int kUseExternalBeginFrameSourceFieldNumber = 3;
bool use_external_begin_frame_source() const;
void set_use_external_begin_frame_source(bool value);

// optional bool main_frame_before_activation_enabled = 4;
bool has_main_frame_before_activation_enabled() const;
void clear_main_frame_before_activation_enabled();
static const int kMainFrameBeforeActivationEnabledFieldNumber = 4;
bool main_frame_before_activation_enabled() const;
void set_main_frame_before_activation_enabled(bool value);

// optional bool using_synchronous_renderer_compositor = 5;
bool has_using_synchronous_renderer_compositor() const;
void clear_using_synchronous_renderer_compositor();
static const int kUsingSynchronousRendererCompositorFieldNumber = 5;
bool using_synchronous_renderer_compositor() const;
void set_using_synchronous_renderer_compositor(bool value);

// optional bool accelerated_animation_enabled = 6;
bool has_accelerated_animation_enabled() const;
void clear_accelerated_animation_enabled();
static const int kAcceleratedAnimationEnabledFieldNumber = 6;
bool accelerated_animation_enabled() const;
void set_accelerated_animation_enabled(bool value);

// optional bool can_use_lcd_text = 7;
bool has_can_use_lcd_text() const;
void clear_can_use_lcd_text();
static const int kCanUseLcdTextFieldNumber = 7;
bool can_use_lcd_text() const;
void set_can_use_lcd_text(bool value);

// optional bool use_distance_field_text = 8;
bool has_use_distance_field_text() const;
void clear_use_distance_field_text();
static const int kUseDistanceFieldTextFieldNumber = 8;
bool use_distance_field_text() const;
void set_use_distance_field_text(bool value);

// optional bool gpu_rasterization_enabled = 9;
bool has_gpu_rasterization_enabled() const;
void clear_gpu_rasterization_enabled();
static const int kGpuRasterizationEnabledFieldNumber = 9;
bool gpu_rasterization_enabled() const;
void set_gpu_rasterization_enabled(bool value);

// optional bool gpu_rasterization_forced = 10;
bool has_gpu_rasterization_forced() const;
void clear_gpu_rasterization_forced();
static const int kGpuRasterizationForcedFieldNumber = 10;
bool gpu_rasterization_forced() const;
void set_gpu_rasterization_forced(bool value);

// optional int32 gpu_rasterization_msaa_sample_count = 11;
bool has_gpu_rasterization_msaa_sample_count() const;
void clear_gpu_rasterization_msaa_sample_count();
static const int kGpuRasterizationMsaaSampleCountFieldNumber = 11;
::google::protobuf::int32 gpu_rasterization_msaa_sample_count() const;
void set_gpu_rasterization_msaa_sample_count(::google::protobuf::int32 value);

// optional float gpu_rasterization_skewport_target_time_in_seconds = 12;
bool has_gpu_rasterization_skewport_target_time_in_seconds() const;
void clear_gpu_rasterization_skewport_target_time_in_seconds();
static const int kGpuRasterizationSkewportTargetTimeInSecondsFieldNumber = 12;
float gpu_rasterization_skewport_target_time_in_seconds() const;
void set_gpu_rasterization_skewport_target_time_in_seconds(float value);

// optional bool create_low_res_tiling = 13;
bool has_create_low_res_tiling() const;
void clear_create_low_res_tiling();
static const int kCreateLowResTilingFieldNumber = 13;
bool create_low_res_tiling() const;
void set_create_low_res_tiling(bool value);

// optional .cc.proto.LayerTreeSettings.ScrollbarAnimator scrollbar_animator = 14;
bool has_scrollbar_animator() const;
void clear_scrollbar_animator();
static const int kScrollbarAnimatorFieldNumber = 14;
::cc::proto::LayerTreeSettings_ScrollbarAnimator scrollbar_animator() const;
void set_scrollbar_animator(::cc::proto::LayerTreeSettings_ScrollbarAnimator value);

// optional int32 scrollbar_fade_delay_ms = 15;
bool has_scrollbar_fade_delay_ms() const;
void clear_scrollbar_fade_delay_ms();
static const int kScrollbarFadeDelayMsFieldNumber = 15;
::google::protobuf::int32 scrollbar_fade_delay_ms() const;
void set_scrollbar_fade_delay_ms(::google::protobuf::int32 value);

// optional int32 scrollbar_fade_resize_delay_ms = 16;
bool has_scrollbar_fade_resize_delay_ms() const;
void clear_scrollbar_fade_resize_delay_ms();
static const int kScrollbarFadeResizeDelayMsFieldNumber = 16;
::google::protobuf::int32 scrollbar_fade_resize_delay_ms() const;
void set_scrollbar_fade_resize_delay_ms(::google::protobuf::int32 value);

// optional int32 scrollbar_fade_duration_ms = 17;
bool has_scrollbar_fade_duration_ms() const;
void clear_scrollbar_fade_duration_ms();
static const int kScrollbarFadeDurationMsFieldNumber = 17;
::google::protobuf::int32 scrollbar_fade_duration_ms() const;
void set_scrollbar_fade_duration_ms(::google::protobuf::int32 value);

// optional uint32 solid_color_scrollbar_color = 18;
bool has_solid_color_scrollbar_color() const;
void clear_solid_color_scrollbar_color();
static const int kSolidColorScrollbarColorFieldNumber = 18;
::google::protobuf::uint32 solid_color_scrollbar_color() const;
void set_solid_color_scrollbar_color(::google::protobuf::uint32 value);

// optional bool timeout_and_draw_when_animation_checkerboards = 19;
bool has_timeout_and_draw_when_animation_checkerboards() const;
void clear_timeout_and_draw_when_animation_checkerboards();
static const int kTimeoutAndDrawWhenAnimationCheckerboardsFieldNumber = 19;
bool timeout_and_draw_when_animation_checkerboards() const;
void set_timeout_and_draw_when_animation_checkerboards(bool value);

// optional bool layer_transforms_should_scale_layer_contents = 20;
bool has_layer_transforms_should_scale_layer_contents() const;
void clear_layer_transforms_should_scale_layer_contents();
static const int kLayerTransformsShouldScaleLayerContentsFieldNumber = 20;
bool layer_transforms_should_scale_layer_contents() const;
void set_layer_transforms_should_scale_layer_contents(bool value);

// optional bool layers_always_allowed_lcd_text = 21;
bool has_layers_always_allowed_lcd_text() const;
void clear_layers_always_allowed_lcd_text();
static const int kLayersAlwaysAllowedLcdTextFieldNumber = 21;
bool layers_always_allowed_lcd_text() const;
void set_layers_always_allowed_lcd_text(bool value);

// optional float minimum_contents_scale = 22;
bool has_minimum_contents_scale() const;
void clear_minimum_contents_scale();
static const int kMinimumContentsScaleFieldNumber = 22;
float minimum_contents_scale() const;
void set_minimum_contents_scale(float value);

// optional float low_res_contents_scale_factor = 23;
bool has_low_res_contents_scale_factor() const;
void clear_low_res_contents_scale_factor();
static const int kLowResContentsScaleFactorFieldNumber = 23;
float low_res_contents_scale_factor() const;
void set_low_res_contents_scale_factor(float value);

// optional float top_controls_show_threshold = 24;
bool has_top_controls_show_threshold() const;
void clear_top_controls_show_threshold();
static const int kTopControlsShowThresholdFieldNumber = 24;
float top_controls_show_threshold() const;
void set_top_controls_show_threshold(float value);

// optional float top_controls_hide_threshold = 25;
bool has_top_controls_hide_threshold() const;
void clear_top_controls_hide_threshold();
static const int kTopControlsHideThresholdFieldNumber = 25;
float top_controls_hide_threshold() const;
void set_top_controls_hide_threshold(float value);

// optional double background_animation_rate = 26;
bool has_background_animation_rate() const;
void clear_background_animation_rate();
static const int kBackgroundAnimationRateFieldNumber = 26;
double background_animation_rate() const;
void set_background_animation_rate(double value);

// optional .cc.proto.Size default_tile_size = 27;
bool has_default_tile_size() const;
void clear_default_tile_size();
static const int kDefaultTileSizeFieldNumber = 27;
const ::cc::proto::Size& default_tile_size() const;
::cc::proto::Size* mutable_default_tile_size();
::cc::proto::Size* release_default_tile_size();
void set_allocated_default_tile_size(::cc::proto::Size* default_tile_size);

// optional .cc.proto.Size max_untiled_layer_size = 28;
bool has_max_untiled_layer_size() const;
void clear_max_untiled_layer_size();
static const int kMaxUntiledLayerSizeFieldNumber = 28;
const ::cc::proto::Size& max_untiled_layer_size() const;
::cc::proto::Size* mutable_max_untiled_layer_size();
::cc::proto::Size* release_max_untiled_layer_size();
void set_allocated_max_untiled_layer_size(::cc::proto::Size* max_untiled_layer_size);

// optional .cc.proto.Size minimum_occlusion_tracking_size = 29;
bool has_minimum_occlusion_tracking_size() const;
void clear_minimum_occlusion_tracking_size();
static const int kMinimumOcclusionTrackingSizeFieldNumber = 29;
const ::cc::proto::Size& minimum_occlusion_tracking_size() const;
::cc::proto::Size* mutable_minimum_occlusion_tracking_size();
::cc::proto::Size* release_minimum_occlusion_tracking_size();
void set_allocated_minimum_occlusion_tracking_size(::cc::proto::Size* minimum_occlusion_tracking_size);

// optional uint32 tiling_interest_area_padding = 30;
bool has_tiling_interest_area_padding() const;
void clear_tiling_interest_area_padding();
static const int kTilingInterestAreaPaddingFieldNumber = 30;
::google::protobuf::uint32 tiling_interest_area_padding() const;
void set_tiling_interest_area_padding(::google::protobuf::uint32 value);

// optional float skewport_target_time_in_seconds = 31;
bool has_skewport_target_time_in_seconds() const;
void clear_skewport_target_time_in_seconds();
static const int kSkewportTargetTimeInSecondsFieldNumber = 31;
float skewport_target_time_in_seconds() const;
void set_skewport_target_time_in_seconds(float value);

// optional int32 skewport_extrapolation_limit_in_screen_pixels = 32;
bool has_skewport_extrapolation_limit_in_screen_pixels() const;
void clear_skewport_extrapolation_limit_in_screen_pixels();
static const int kSkewportExtrapolationLimitInScreenPixelsFieldNumber = 32;
::google::protobuf::int32 skewport_extrapolation_limit_in_screen_pixels() const;
void set_skewport_extrapolation_limit_in_screen_pixels(::google::protobuf::int32 value);

// optional uint32 max_memory_for_prepaint_percentage = 33;
bool has_max_memory_for_prepaint_percentage() const;
void clear_max_memory_for_prepaint_percentage();
static const int kMaxMemoryForPrepaintPercentageFieldNumber = 33;
::google::protobuf::uint32 max_memory_for_prepaint_percentage() const;
void set_max_memory_for_prepaint_percentage(::google::protobuf::uint32 value);

// optional bool use_zero_copy = 35;
bool has_use_zero_copy() const;
void clear_use_zero_copy();
static const int kUseZeroCopyFieldNumber = 35;
bool use_zero_copy() const;
void set_use_zero_copy(bool value);

// optional bool use_partial_raster = 36;
bool has_use_partial_raster() const;
void clear_use_partial_raster();
static const int kUsePartialRasterFieldNumber = 36;
bool use_partial_raster() const;
void set_use_partial_raster(bool value);

// optional bool enable_elastic_overscroll = 37;
bool has_enable_elastic_overscroll() const;
void clear_enable_elastic_overscroll();
static const int kEnableElasticOverscrollFieldNumber = 37;
bool enable_elastic_overscroll() const;
void set_enable_elastic_overscroll(bool value);

// optional bool ignore_root_layer_flings = 39;
bool has_ignore_root_layer_flings() const;
void clear_ignore_root_layer_flings();
static const int kIgnoreRootLayerFlingsFieldNumber = 39;
bool ignore_root_layer_flings() const;
void set_ignore_root_layer_flings(bool value);

// optional uint32 scheduled_raster_task_limit = 40;
bool has_scheduled_raster_task_limit() const;
void clear_scheduled_raster_task_limit();
static const int kScheduledRasterTaskLimitFieldNumber = 40;
::google::protobuf::uint32 scheduled_raster_task_limit() const;
void set_scheduled_raster_task_limit(::google::protobuf::uint32 value);

// optional bool use_occlusion_for_tile_prioritization = 41;
bool has_use_occlusion_for_tile_prioritization() const;
void clear_use_occlusion_for_tile_prioritization();
static const int kUseOcclusionForTilePrioritizationFieldNumber = 41;
bool use_occlusion_for_tile_prioritization() const;
void set_use_occlusion_for_tile_prioritization(bool value);

// optional bool image_decode_tasks_enabled = 44;
bool has_image_decode_tasks_enabled() const;
void clear_image_decode_tasks_enabled();
static const int kImageDecodeTasksEnabledFieldNumber = 44;
bool image_decode_tasks_enabled() const;
void set_image_decode_tasks_enabled(bool value);

// optional bool use_compositor_animation_timelines = 45;
bool has_use_compositor_animation_timelines() const;
void clear_use_compositor_animation_timelines();
static const int kUseCompositorAnimationTimelinesFieldNumber = 45;
bool use_compositor_animation_timelines() const;
void set_use_compositor_animation_timelines(bool value);

// optional bool wait_for_beginframe_interval = 46;
bool has_wait_for_beginframe_interval() const;
void clear_wait_for_beginframe_interval();
static const int kWaitForBeginframeIntervalFieldNumber = 46;
bool wait_for_beginframe_interval() const;
void set_wait_for_beginframe_interval(bool value);

// optional int32 max_staging_buffer_usage_in_bytes = 47;
bool has_max_staging_buffer_usage_in_bytes() const;
void clear_max_staging_buffer_usage_in_bytes();
static const int kMaxStagingBufferUsageInBytesFieldNumber = 47;
::google::protobuf::int32 max_staging_buffer_usage_in_bytes() const;
void set_max_staging_buffer_usage_in_bytes(::google::protobuf::int32 value);

// optional .cc.proto.ManagedMemoryPolicy memory_policy = 48;
bool has_memory_policy() const;
void clear_memory_policy();
static const int kMemoryPolicyFieldNumber = 48;
const ::cc::proto::ManagedMemoryPolicy& memory_policy() const;
::cc::proto::ManagedMemoryPolicy* mutable_memory_policy();
::cc::proto::ManagedMemoryPolicy* release_memory_policy();
void set_allocated_memory_policy(::cc::proto::ManagedMemoryPolicy* memory_policy);

// optional .cc.proto.LayerTreeDebugState initial_debug_state = 49;
bool has_initial_debug_state() const;
void clear_initial_debug_state();
static const int kInitialDebugStateFieldNumber = 49;
const ::cc::proto::LayerTreeDebugState& initial_debug_state() const;
::cc::proto::LayerTreeDebugState* mutable_initial_debug_state();
::cc::proto::LayerTreeDebugState* release_initial_debug_state();
void set_allocated_initial_debug_state(::cc::proto::LayerTreeDebugState* initial_debug_state);

// optional bool use_cached_picture_raster = 51;
bool has_use_cached_picture_raster() const;
void clear_use_cached_picture_raster();
static const int kUseCachedPictureRasterFieldNumber = 51;
bool use_cached_picture_raster() const;
void set_use_cached_picture_raster(bool value);

// optional bool async_worker_context_enabled = 52;
bool has_async_worker_context_enabled() const;
void clear_async_worker_context_enabled();
static const int kAsyncWorkerContextEnabledFieldNumber = 52;
bool async_worker_context_enabled() const;
void set_async_worker_context_enabled(bool value);

// @@protoc_insertion_point(class_scope:cc.proto.LayerTreeSettings)
private:
inline void set_has_renderer_settings();
inline void clear_has_renderer_settings();
inline void set_has_single_thread_proxy_scheduler();
inline void clear_has_single_thread_proxy_scheduler();
inline void set_has_use_external_begin_frame_source();
inline void clear_has_use_external_begin_frame_source();
inline void set_has_main_frame_before_activation_enabled();
inline void clear_has_main_frame_before_activation_enabled();
inline void set_has_using_synchronous_renderer_compositor();
inline void clear_has_using_synchronous_renderer_compositor();
inline void set_has_accelerated_animation_enabled();
inline void clear_has_accelerated_animation_enabled();
inline void set_has_can_use_lcd_text();
inline void clear_has_can_use_lcd_text();
inline void set_has_use_distance_field_text();
inline void clear_has_use_distance_field_text();
inline void set_has_gpu_rasterization_enabled();
inline void clear_has_gpu_rasterization_enabled();
inline void set_has_gpu_rasterization_forced();
inline void clear_has_gpu_rasterization_forced();
inline void set_has_gpu_rasterization_msaa_sample_count();
inline void clear_has_gpu_rasterization_msaa_sample_count();
inline void set_has_gpu_rasterization_skewport_target_time_in_seconds();
inline void clear_has_gpu_rasterization_skewport_target_time_in_seconds();
inline void set_has_create_low_res_tiling();
inline void clear_has_create_low_res_tiling();
inline void set_has_scrollbar_animator();
inline void clear_has_scrollbar_animator();
inline void set_has_scrollbar_fade_delay_ms();
inline void clear_has_scrollbar_fade_delay_ms();
inline void set_has_scrollbar_fade_resize_delay_ms();
inline void clear_has_scrollbar_fade_resize_delay_ms();
inline void set_has_scrollbar_fade_duration_ms();
inline void clear_has_scrollbar_fade_duration_ms();
inline void set_has_solid_color_scrollbar_color();
inline void clear_has_solid_color_scrollbar_color();
inline void set_has_timeout_and_draw_when_animation_checkerboards();
inline void clear_has_timeout_and_draw_when_animation_checkerboards();
inline void set_has_layer_transforms_should_scale_layer_contents();
inline void clear_has_layer_transforms_should_scale_layer_contents();
inline void set_has_layers_always_allowed_lcd_text();
inline void clear_has_layers_always_allowed_lcd_text();
inline void set_has_minimum_contents_scale();
inline void clear_has_minimum_contents_scale();
inline void set_has_low_res_contents_scale_factor();
inline void clear_has_low_res_contents_scale_factor();
inline void set_has_top_controls_show_threshold();
inline void clear_has_top_controls_show_threshold();
inline void set_has_top_controls_hide_threshold();
inline void clear_has_top_controls_hide_threshold();
inline void set_has_background_animation_rate();
inline void clear_has_background_animation_rate();
inline void set_has_default_tile_size();
inline void clear_has_default_tile_size();
inline void set_has_max_untiled_layer_size();
inline void clear_has_max_untiled_layer_size();
inline void set_has_minimum_occlusion_tracking_size();
inline void clear_has_minimum_occlusion_tracking_size();
inline void set_has_tiling_interest_area_padding();
inline void clear_has_tiling_interest_area_padding();
inline void set_has_skewport_target_time_in_seconds();
inline void clear_has_skewport_target_time_in_seconds();
inline void set_has_skewport_extrapolation_limit_in_screen_pixels();
inline void clear_has_skewport_extrapolation_limit_in_screen_pixels();
inline void set_has_max_memory_for_prepaint_percentage();
inline void clear_has_max_memory_for_prepaint_percentage();
inline void set_has_use_zero_copy();
inline void clear_has_use_zero_copy();
inline void set_has_use_partial_raster();
inline void clear_has_use_partial_raster();
inline void set_has_enable_elastic_overscroll();
inline void clear_has_enable_elastic_overscroll();
inline void set_has_ignore_root_layer_flings();
inline void clear_has_ignore_root_layer_flings();
inline void set_has_scheduled_raster_task_limit();
inline void clear_has_scheduled_raster_task_limit();
inline void set_has_use_occlusion_for_tile_prioritization();
inline void clear_has_use_occlusion_for_tile_prioritization();
inline void set_has_image_decode_tasks_enabled();
inline void clear_has_image_decode_tasks_enabled();
inline void set_has_use_compositor_animation_timelines();
inline void clear_has_use_compositor_animation_timelines();
inline void set_has_wait_for_beginframe_interval();
inline void clear_has_wait_for_beginframe_interval();
inline void set_has_max_staging_buffer_usage_in_bytes();
inline void clear_has_max_staging_buffer_usage_in_bytes();
inline void set_has_memory_policy();
inline void clear_has_memory_policy();
inline void set_has_initial_debug_state();
inline void clear_has_initial_debug_state();
inline void set_has_use_cached_picture_raster();
inline void clear_has_use_cached_picture_raster();
inline void set_has_async_worker_context_enabled();
inline void clear_has_async_worker_context_enabled();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[2];
::cc::proto::RendererSettings* renderer_settings_;
bool single_thread_proxy_scheduler_;
bool use_external_begin_frame_source_;
bool main_frame_before_activation_enabled_;
bool using_synchronous_renderer_compositor_;
bool accelerated_animation_enabled_;
bool can_use_lcd_text_;
bool use_distance_field_text_;
bool gpu_rasterization_enabled_;
::google::protobuf::int32 gpu_rasterization_msaa_sample_count_;
float gpu_rasterization_skewport_target_time_in_seconds_;
int scrollbar_animator_;
::google::protobuf::int32 scrollbar_fade_delay_ms_;
bool gpu_rasterization_forced_;
bool create_low_res_tiling_;
bool timeout_and_draw_when_animation_checkerboards_;
bool layer_transforms_should_scale_layer_contents_;
::google::protobuf::int32 scrollbar_fade_resize_delay_ms_;
::google::protobuf::int32 scrollbar_fade_duration_ms_;
::google::protobuf::uint32 solid_color_scrollbar_color_;
float minimum_contents_scale_;
float low_res_contents_scale_factor_;
float top_controls_show_threshold_;
float top_controls_hide_threshold_;
double background_animation_rate_;
::cc::proto::Size* default_tile_size_;
::cc::proto::Size* max_untiled_layer_size_;
::cc::proto::Size* minimum_occlusion_tracking_size_;
::google::protobuf::uint32 tiling_interest_area_padding_;
float skewport_target_time_in_seconds_;
bool layers_always_allowed_lcd_text_;
bool use_zero_copy_;
bool use_partial_raster_;
bool enable_elastic_overscroll_;
::google::protobuf::int32 skewport_extrapolation_limit_in_screen_pixels_;
::google::protobuf::uint32 max_memory_for_prepaint_percentage_;
::google::protobuf::uint32 scheduled_raster_task_limit_;
bool ignore_root_layer_flings_;
bool use_occlusion_for_tile_prioritization_;
bool image_decode_tasks_enabled_;
bool use_compositor_animation_timelines_;
::google::protobuf::int32 max_staging_buffer_usage_in_bytes_;
::cc::proto::ManagedMemoryPolicy* memory_policy_;
::cc::proto::LayerTreeDebugState* initial_debug_state_;
bool wait_for_beginframe_interval_;
bool use_cached_picture_raster_;
bool async_worker_context_enabled_;
mutable int _cached_size_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fsettings_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_layer_5ftree_5fsettings_2eproto();
#endif
friend void protobuf_AssignDesc_layer_5ftree_5fsettings_2eproto();
friend void protobuf_ShutdownFile_layer_5ftree_5fsettings_2eproto();

void InitAsDefaultInstance();
static LayerTreeSettings* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LayerTreeSettings

// optional .cc.proto.RendererSettings renderer_settings = 1;
inline bool LayerTreeSettings::has_renderer_settings() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerTreeSettings::set_has_renderer_settings() {
_has_bits_[0] |= 0x00000001u;
}
inline void LayerTreeSettings::clear_has_renderer_settings() {
_has_bits_[0] &= ~0x00000001u;
}
inline void LayerTreeSettings::clear_renderer_settings() {
if (renderer_settings_ != NULL) renderer_settings_->::cc::proto::RendererSettings::Clear();
clear_has_renderer_settings();
}
inline const ::cc::proto::RendererSettings& LayerTreeSettings::renderer_settings() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.renderer_settings)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return renderer_settings_ != NULL ? *renderer_settings_ : *default_instance().renderer_settings_;
#else
return renderer_settings_ != NULL ? *renderer_settings_ : *default_instance_->renderer_settings_;
#endif
}
inline ::cc::proto::RendererSettings* LayerTreeSettings::mutable_renderer_settings() {
set_has_renderer_settings();
if (renderer_settings_ == NULL) {
renderer_settings_ = new ::cc::proto::RendererSettings;
}
// @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeSettings.renderer_settings)
return renderer_settings_;
}
inline ::cc::proto::RendererSettings* LayerTreeSettings::release_renderer_settings() {
// @@protoc_insertion_point(field_release:cc.proto.LayerTreeSettings.renderer_settings)
clear_has_renderer_settings();
::cc::proto::RendererSettings* temp = renderer_settings_;
renderer_settings_ = NULL;
return temp;
}
inline void LayerTreeSettings::set_allocated_renderer_settings(::cc::proto::RendererSettings* renderer_settings) {
delete renderer_settings_;
renderer_settings_ = renderer_settings;
if (renderer_settings) {
set_has_renderer_settings();
} else {
clear_has_renderer_settings();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeSettings.renderer_settings)
}

// optional bool single_thread_proxy_scheduler = 2;
inline bool LayerTreeSettings::has_single_thread_proxy_scheduler() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerTreeSettings::set_has_single_thread_proxy_scheduler() {
_has_bits_[0] |= 0x00000002u;
}
inline void LayerTreeSettings::clear_has_single_thread_proxy_scheduler() {
_has_bits_[0] &= ~0x00000002u;
}
inline void LayerTreeSettings::clear_single_thread_proxy_scheduler() {
single_thread_proxy_scheduler_ = false;
clear_has_single_thread_proxy_scheduler();
}
inline bool LayerTreeSettings::single_thread_proxy_scheduler() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.single_thread_proxy_scheduler)
return single_thread_proxy_scheduler_;
}
inline void LayerTreeSettings::set_single_thread_proxy_scheduler(bool value) {
set_has_single_thread_proxy_scheduler();
single_thread_proxy_scheduler_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.single_thread_proxy_scheduler)
}

// optional bool use_external_begin_frame_source = 3;
inline bool LayerTreeSettings::has_use_external_begin_frame_source() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerTreeSettings::set_has_use_external_begin_frame_source() {
_has_bits_[0] |= 0x00000004u;
}
inline void LayerTreeSettings::clear_has_use_external_begin_frame_source() {
_has_bits_[0] &= ~0x00000004u;
}
inline void LayerTreeSettings::clear_use_external_begin_frame_source() {
use_external_begin_frame_source_ = false;
clear_has_use_external_begin_frame_source();
}
inline bool LayerTreeSettings::use_external_begin_frame_source() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.use_external_begin_frame_source)
return use_external_begin_frame_source_;
}
inline void LayerTreeSettings::set_use_external_begin_frame_source(bool value) {
set_has_use_external_begin_frame_source();
use_external_begin_frame_source_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.use_external_begin_frame_source)
}

// optional bool main_frame_before_activation_enabled = 4;
inline bool LayerTreeSettings::has_main_frame_before_activation_enabled() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayerTreeSettings::set_has_main_frame_before_activation_enabled() {
_has_bits_[0] |= 0x00000008u;
}
inline void LayerTreeSettings::clear_has_main_frame_before_activation_enabled() {
_has_bits_[0] &= ~0x00000008u;
}
inline void LayerTreeSettings::clear_main_frame_before_activation_enabled() {
main_frame_before_activation_enabled_ = false;
clear_has_main_frame_before_activation_enabled();
}
inline bool LayerTreeSettings::main_frame_before_activation_enabled() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.main_frame_before_activation_enabled)
return main_frame_before_activation_enabled_;
}
inline void LayerTreeSettings::set_main_frame_before_activation_enabled(bool value) {
set_has_main_frame_before_activation_enabled();
main_frame_before_activation_enabled_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.main_frame_before_activation_enabled)
}

// optional bool using_synchronous_renderer_compositor = 5;
inline bool LayerTreeSettings::has_using_synchronous_renderer_compositor() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LayerTreeSettings::set_has_using_synchronous_renderer_compositor() {
_has_bits_[0] |= 0x00000010u;
}
inline void LayerTreeSettings::clear_has_using_synchronous_renderer_compositor() {
_has_bits_[0] &= ~0x00000010u;
}
inline void LayerTreeSettings::clear_using_synchronous_renderer_compositor() {
using_synchronous_renderer_compositor_ = false;
clear_has_using_synchronous_renderer_compositor();
}
inline bool LayerTreeSettings::using_synchronous_renderer_compositor() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.using_synchronous_renderer_compositor)
return using_synchronous_renderer_compositor_;
}
inline void LayerTreeSettings::set_using_synchronous_renderer_compositor(bool value) {
set_has_using_synchronous_renderer_compositor();
using_synchronous_renderer_compositor_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.using_synchronous_renderer_compositor)
}

// optional bool accelerated_animation_enabled = 6;
inline bool LayerTreeSettings::has_accelerated_animation_enabled() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LayerTreeSettings::set_has_accelerated_animation_enabled() {
_has_bits_[0] |= 0x00000020u;
}
inline void LayerTreeSettings::clear_has_accelerated_animation_enabled() {
_has_bits_[0] &= ~0x00000020u;
}
inline void LayerTreeSettings::clear_accelerated_animation_enabled() {
accelerated_animation_enabled_ = false;
clear_has_accelerated_animation_enabled();
}
inline bool LayerTreeSettings::accelerated_animation_enabled() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.accelerated_animation_enabled)
return accelerated_animation_enabled_;
}
inline void LayerTreeSettings::set_accelerated_animation_enabled(bool value) {
set_has_accelerated_animation_enabled();
accelerated_animation_enabled_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.accelerated_animation_enabled)
}

// optional bool can_use_lcd_text = 7;
inline bool LayerTreeSettings::has_can_use_lcd_text() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LayerTreeSettings::set_has_can_use_lcd_text() {
_has_bits_[0] |= 0x00000040u;
}
inline void LayerTreeSettings::clear_has_can_use_lcd_text() {
_has_bits_[0] &= ~0x00000040u;
}
inline void LayerTreeSettings::clear_can_use_lcd_text() {
can_use_lcd_text_ = false;
clear_has_can_use_lcd_text();
}
inline bool LayerTreeSettings::can_use_lcd_text() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.can_use_lcd_text)
return can_use_lcd_text_;
}
inline void LayerTreeSettings::set_can_use_lcd_text(bool value) {
set_has_can_use_lcd_text();
can_use_lcd_text_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.can_use_lcd_text)
}

// optional bool use_distance_field_text = 8;
inline bool LayerTreeSettings::has_use_distance_field_text() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LayerTreeSettings::set_has_use_distance_field_text() {
_has_bits_[0] |= 0x00000080u;
}
inline void LayerTreeSettings::clear_has_use_distance_field_text() {
_has_bits_[0] &= ~0x00000080u;
}
inline void LayerTreeSettings::clear_use_distance_field_text() {
use_distance_field_text_ = false;
clear_has_use_distance_field_text();
}
inline bool LayerTreeSettings::use_distance_field_text() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.use_distance_field_text)
return use_distance_field_text_;
}
inline void LayerTreeSettings::set_use_distance_field_text(bool value) {
set_has_use_distance_field_text();
use_distance_field_text_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.use_distance_field_text)
}

// optional bool gpu_rasterization_enabled = 9;
inline bool LayerTreeSettings::has_gpu_rasterization_enabled() const {
return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LayerTreeSettings::set_has_gpu_rasterization_enabled() {
_has_bits_[0] |= 0x00000100u;
}
inline void LayerTreeSettings::clear_has_gpu_rasterization_enabled() {
_has_bits_[0] &= ~0x00000100u;
}
inline void LayerTreeSettings::clear_gpu_rasterization_enabled() {
gpu_rasterization_enabled_ = false;
clear_has_gpu_rasterization_enabled();
}
inline bool LayerTreeSettings::gpu_rasterization_enabled() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.gpu_rasterization_enabled)
return gpu_rasterization_enabled_;
}
inline void LayerTreeSettings::set_gpu_rasterization_enabled(bool value) {
set_has_gpu_rasterization_enabled();
gpu_rasterization_enabled_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.gpu_rasterization_enabled)
}

// optional bool gpu_rasterization_forced = 10;
inline bool LayerTreeSettings::has_gpu_rasterization_forced() const {
return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LayerTreeSettings::set_has_gpu_rasterization_forced() {
_has_bits_[0] |= 0x00000200u;
}
inline void LayerTreeSettings::clear_has_gpu_rasterization_forced() {
_has_bits_[0] &= ~0x00000200u;
}
inline void LayerTreeSettings::clear_gpu_rasterization_forced() {
gpu_rasterization_forced_ = false;
clear_has_gpu_rasterization_forced();
}
inline bool LayerTreeSettings::gpu_rasterization_forced() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.gpu_rasterization_forced)
return gpu_rasterization_forced_;
}
inline void LayerTreeSettings::set_gpu_rasterization_forced(bool value) {
set_has_gpu_rasterization_forced();
gpu_rasterization_forced_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.gpu_rasterization_forced)
}

// optional int32 gpu_rasterization_msaa_sample_count = 11;
inline bool LayerTreeSettings::has_gpu_rasterization_msaa_sample_count() const {
return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LayerTreeSettings::set_has_gpu_rasterization_msaa_sample_count() {
_has_bits_[0] |= 0x00000400u;
}
inline void LayerTreeSettings::clear_has_gpu_rasterization_msaa_sample_count() {
_has_bits_[0] &= ~0x00000400u;
}
inline void LayerTreeSettings::clear_gpu_rasterization_msaa_sample_count() {
gpu_rasterization_msaa_sample_count_ = 0;
clear_has_gpu_rasterization_msaa_sample_count();
}
inline ::google::protobuf::int32 LayerTreeSettings::gpu_rasterization_msaa_sample_count() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.gpu_rasterization_msaa_sample_count)
return gpu_rasterization_msaa_sample_count_;
}
inline void LayerTreeSettings::set_gpu_rasterization_msaa_sample_count(::google::protobuf::int32 value) {
set_has_gpu_rasterization_msaa_sample_count();
gpu_rasterization_msaa_sample_count_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.gpu_rasterization_msaa_sample_count)
}

// optional float gpu_rasterization_skewport_target_time_in_seconds = 12;
inline bool LayerTreeSettings::has_gpu_rasterization_skewport_target_time_in_seconds() const {
return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LayerTreeSettings::set_has_gpu_rasterization_skewport_target_time_in_seconds() {
_has_bits_[0] |= 0x00000800u;
}
inline void LayerTreeSettings::clear_has_gpu_rasterization_skewport_target_time_in_seconds() {
_has_bits_[0] &= ~0x00000800u;
}
inline void LayerTreeSettings::clear_gpu_rasterization_skewport_target_time_in_seconds() {
gpu_rasterization_skewport_target_time_in_seconds_ = 0;
clear_has_gpu_rasterization_skewport_target_time_in_seconds();
}
inline float LayerTreeSettings::gpu_rasterization_skewport_target_time_in_seconds() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.gpu_rasterization_skewport_target_time_in_seconds)
return gpu_rasterization_skewport_target_time_in_seconds_;
}
inline void LayerTreeSettings::set_gpu_rasterization_skewport_target_time_in_seconds(float value) {
set_has_gpu_rasterization_skewport_target_time_in_seconds();
gpu_rasterization_skewport_target_time_in_seconds_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.gpu_rasterization_skewport_target_time_in_seconds)
}

// optional bool create_low_res_tiling = 13;
inline bool LayerTreeSettings::has_create_low_res_tiling() const {
return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LayerTreeSettings::set_has_create_low_res_tiling() {
_has_bits_[0] |= 0x00001000u;
}
inline void LayerTreeSettings::clear_has_create_low_res_tiling() {
_has_bits_[0] &= ~0x00001000u;
}
inline void LayerTreeSettings::clear_create_low_res_tiling() {
create_low_res_tiling_ = false;
clear_has_create_low_res_tiling();
}
inline bool LayerTreeSettings::create_low_res_tiling() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.create_low_res_tiling)
return create_low_res_tiling_;
}
inline void LayerTreeSettings::set_create_low_res_tiling(bool value) {
set_has_create_low_res_tiling();
create_low_res_tiling_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.create_low_res_tiling)
}

// optional .cc.proto.LayerTreeSettings.ScrollbarAnimator scrollbar_animator = 14;
inline bool LayerTreeSettings::has_scrollbar_animator() const {
return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LayerTreeSettings::set_has_scrollbar_animator() {
_has_bits_[0] |= 0x00002000u;
}
inline void LayerTreeSettings::clear_has_scrollbar_animator() {
_has_bits_[0] &= ~0x00002000u;
}
inline void LayerTreeSettings::clear_scrollbar_animator() {
scrollbar_animator_ = 0;
clear_has_scrollbar_animator();
}
inline ::cc::proto::LayerTreeSettings_ScrollbarAnimator LayerTreeSettings::scrollbar_animator() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.scrollbar_animator)
return static_cast< ::cc::proto::LayerTreeSettings_ScrollbarAnimator >(scrollbar_animator_);
}
inline void LayerTreeSettings::set_scrollbar_animator(::cc::proto::LayerTreeSettings_ScrollbarAnimator value) {
assert(::cc::proto::LayerTreeSettings_ScrollbarAnimator_IsValid(value));
set_has_scrollbar_animator();
scrollbar_animator_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.scrollbar_animator)
}

// optional int32 scrollbar_fade_delay_ms = 15;
inline bool LayerTreeSettings::has_scrollbar_fade_delay_ms() const {
return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LayerTreeSettings::set_has_scrollbar_fade_delay_ms() {
_has_bits_[0] |= 0x00004000u;
}
inline void LayerTreeSettings::clear_has_scrollbar_fade_delay_ms() {
_has_bits_[0] &= ~0x00004000u;
}
inline void LayerTreeSettings::clear_scrollbar_fade_delay_ms() {
scrollbar_fade_delay_ms_ = 0;
clear_has_scrollbar_fade_delay_ms();
}
inline ::google::protobuf::int32 LayerTreeSettings::scrollbar_fade_delay_ms() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.scrollbar_fade_delay_ms)
return scrollbar_fade_delay_ms_;
}
inline void LayerTreeSettings::set_scrollbar_fade_delay_ms(::google::protobuf::int32 value) {
set_has_scrollbar_fade_delay_ms();
scrollbar_fade_delay_ms_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.scrollbar_fade_delay_ms)
}

// optional int32 scrollbar_fade_resize_delay_ms = 16;
inline bool LayerTreeSettings::has_scrollbar_fade_resize_delay_ms() const {
return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LayerTreeSettings::set_has_scrollbar_fade_resize_delay_ms() {
_has_bits_[0] |= 0x00008000u;
}
inline void LayerTreeSettings::clear_has_scrollbar_fade_resize_delay_ms() {
_has_bits_[0] &= ~0x00008000u;
}
inline void LayerTreeSettings::clear_scrollbar_fade_resize_delay_ms() {
scrollbar_fade_resize_delay_ms_ = 0;
clear_has_scrollbar_fade_resize_delay_ms();
}
inline ::google::protobuf::int32 LayerTreeSettings::scrollbar_fade_resize_delay_ms() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.scrollbar_fade_resize_delay_ms)
return scrollbar_fade_resize_delay_ms_;
}
inline void LayerTreeSettings::set_scrollbar_fade_resize_delay_ms(::google::protobuf::int32 value) {
set_has_scrollbar_fade_resize_delay_ms();
scrollbar_fade_resize_delay_ms_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.scrollbar_fade_resize_delay_ms)
}

// optional int32 scrollbar_fade_duration_ms = 17;
inline bool LayerTreeSettings::has_scrollbar_fade_duration_ms() const {
return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LayerTreeSettings::set_has_scrollbar_fade_duration_ms() {
_has_bits_[0] |= 0x00010000u;
}
inline void LayerTreeSettings::clear_has_scrollbar_fade_duration_ms() {
_has_bits_[0] &= ~0x00010000u;
}
inline void LayerTreeSettings::clear_scrollbar_fade_duration_ms() {
scrollbar_fade_duration_ms_ = 0;
clear_has_scrollbar_fade_duration_ms();
}
inline ::google::protobuf::int32 LayerTreeSettings::scrollbar_fade_duration_ms() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.scrollbar_fade_duration_ms)
return scrollbar_fade_duration_ms_;
}
inline void LayerTreeSettings::set_scrollbar_fade_duration_ms(::google::protobuf::int32 value) {
set_has_scrollbar_fade_duration_ms();
scrollbar_fade_duration_ms_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.scrollbar_fade_duration_ms)
}

// optional uint32 solid_color_scrollbar_color = 18;
inline bool LayerTreeSettings::has_solid_color_scrollbar_color() const {
return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LayerTreeSettings::set_has_solid_color_scrollbar_color() {
_has_bits_[0] |= 0x00020000u;
}
inline void LayerTreeSettings::clear_has_solid_color_scrollbar_color() {
_has_bits_[0] &= ~0x00020000u;
}
inline void LayerTreeSettings::clear_solid_color_scrollbar_color() {
solid_color_scrollbar_color_ = 0u;
clear_has_solid_color_scrollbar_color();
}
inline ::google::protobuf::uint32 LayerTreeSettings::solid_color_scrollbar_color() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.solid_color_scrollbar_color)
return solid_color_scrollbar_color_;
}
inline void LayerTreeSettings::set_solid_color_scrollbar_color(::google::protobuf::uint32 value) {
set_has_solid_color_scrollbar_color();
solid_color_scrollbar_color_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.solid_color_scrollbar_color)
}

// optional bool timeout_and_draw_when_animation_checkerboards = 19;
inline bool LayerTreeSettings::has_timeout_and_draw_when_animation_checkerboards() const {
return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LayerTreeSettings::set_has_timeout_and_draw_when_animation_checkerboards() {
_has_bits_[0] |= 0x00040000u;
}
inline void LayerTreeSettings::clear_has_timeout_and_draw_when_animation_checkerboards() {
_has_bits_[0] &= ~0x00040000u;
}
inline void LayerTreeSettings::clear_timeout_and_draw_when_animation_checkerboards() {
timeout_and_draw_when_animation_checkerboards_ = false;
clear_has_timeout_and_draw_when_animation_checkerboards();
}
inline bool LayerTreeSettings::timeout_and_draw_when_animation_checkerboards() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.timeout_and_draw_when_animation_checkerboards)
return timeout_and_draw_when_animation_checkerboards_;
}
inline void LayerTreeSettings::set_timeout_and_draw_when_animation_checkerboards(bool value) {
set_has_timeout_and_draw_when_animation_checkerboards();
timeout_and_draw_when_animation_checkerboards_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.timeout_and_draw_when_animation_checkerboards)
}

// optional bool layer_transforms_should_scale_layer_contents = 20;
inline bool LayerTreeSettings::has_layer_transforms_should_scale_layer_contents() const {
return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LayerTreeSettings::set_has_layer_transforms_should_scale_layer_contents() {
_has_bits_[0] |= 0x00080000u;
}
inline void LayerTreeSettings::clear_has_layer_transforms_should_scale_layer_contents() {
_has_bits_[0] &= ~0x00080000u;
}
inline void LayerTreeSettings::clear_layer_transforms_should_scale_layer_contents() {
layer_transforms_should_scale_layer_contents_ = false;
clear_has_layer_transforms_should_scale_layer_contents();
}
inline bool LayerTreeSettings::layer_transforms_should_scale_layer_contents() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.layer_transforms_should_scale_layer_contents)
return layer_transforms_should_scale_layer_contents_;
}
inline void LayerTreeSettings::set_layer_transforms_should_scale_layer_contents(bool value) {
set_has_layer_transforms_should_scale_layer_contents();
layer_transforms_should_scale_layer_contents_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.layer_transforms_should_scale_layer_contents)
}

// optional bool layers_always_allowed_lcd_text = 21;
inline bool LayerTreeSettings::has_layers_always_allowed_lcd_text() const {
return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void LayerTreeSettings::set_has_layers_always_allowed_lcd_text() {
_has_bits_[0] |= 0x00100000u;
}
inline void LayerTreeSettings::clear_has_layers_always_allowed_lcd_text() {
_has_bits_[0] &= ~0x00100000u;
}
inline void LayerTreeSettings::clear_layers_always_allowed_lcd_text() {
layers_always_allowed_lcd_text_ = false;
clear_has_layers_always_allowed_lcd_text();
}
inline bool LayerTreeSettings::layers_always_allowed_lcd_text() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.layers_always_allowed_lcd_text)
return layers_always_allowed_lcd_text_;
}
inline void LayerTreeSettings::set_layers_always_allowed_lcd_text(bool value) {
set_has_layers_always_allowed_lcd_text();
layers_always_allowed_lcd_text_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.layers_always_allowed_lcd_text)
}

// optional float minimum_contents_scale = 22;
inline bool LayerTreeSettings::has_minimum_contents_scale() const {
return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void LayerTreeSettings::set_has_minimum_contents_scale() {
_has_bits_[0] |= 0x00200000u;
}
inline void LayerTreeSettings::clear_has_minimum_contents_scale() {
_has_bits_[0] &= ~0x00200000u;
}
inline void LayerTreeSettings::clear_minimum_contents_scale() {
minimum_contents_scale_ = 0;
clear_has_minimum_contents_scale();
}
inline float LayerTreeSettings::minimum_contents_scale() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.minimum_contents_scale)
return minimum_contents_scale_;
}
inline void LayerTreeSettings::set_minimum_contents_scale(float value) {
set_has_minimum_contents_scale();
minimum_contents_scale_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.minimum_contents_scale)
}

// optional float low_res_contents_scale_factor = 23;
inline bool LayerTreeSettings::has_low_res_contents_scale_factor() const {
return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void LayerTreeSettings::set_has_low_res_contents_scale_factor() {
_has_bits_[0] |= 0x00400000u;
}
inline void LayerTreeSettings::clear_has_low_res_contents_scale_factor() {
_has_bits_[0] &= ~0x00400000u;
}
inline void LayerTreeSettings::clear_low_res_contents_scale_factor() {
low_res_contents_scale_factor_ = 0;
clear_has_low_res_contents_scale_factor();
}
inline float LayerTreeSettings::low_res_contents_scale_factor() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.low_res_contents_scale_factor)
return low_res_contents_scale_factor_;
}
inline void LayerTreeSettings::set_low_res_contents_scale_factor(float value) {
set_has_low_res_contents_scale_factor();
low_res_contents_scale_factor_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.low_res_contents_scale_factor)
}

// optional float top_controls_show_threshold = 24;
inline bool LayerTreeSettings::has_top_controls_show_threshold() const {
return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void LayerTreeSettings::set_has_top_controls_show_threshold() {
_has_bits_[0] |= 0x00800000u;
}
inline void LayerTreeSettings::clear_has_top_controls_show_threshold() {
_has_bits_[0] &= ~0x00800000u;
}
inline void LayerTreeSettings::clear_top_controls_show_threshold() {
top_controls_show_threshold_ = 0;
clear_has_top_controls_show_threshold();
}
inline float LayerTreeSettings::top_controls_show_threshold() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.top_controls_show_threshold)
return top_controls_show_threshold_;
}
inline void LayerTreeSettings::set_top_controls_show_threshold(float value) {
set_has_top_controls_show_threshold();
top_controls_show_threshold_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.top_controls_show_threshold)
}

// optional float top_controls_hide_threshold = 25;
inline bool LayerTreeSettings::has_top_controls_hide_threshold() const {
return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void LayerTreeSettings::set_has_top_controls_hide_threshold() {
_has_bits_[0] |= 0x01000000u;
}
inline void LayerTreeSettings::clear_has_top_controls_hide_threshold() {
_has_bits_[0] &= ~0x01000000u;
}
inline void LayerTreeSettings::clear_top_controls_hide_threshold() {
top_controls_hide_threshold_ = 0;
clear_has_top_controls_hide_threshold();
}
inline float LayerTreeSettings::top_controls_hide_threshold() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.top_controls_hide_threshold)
return top_controls_hide_threshold_;
}
inline void LayerTreeSettings::set_top_controls_hide_threshold(float value) {
set_has_top_controls_hide_threshold();
top_controls_hide_threshold_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.top_controls_hide_threshold)
}

// optional double background_animation_rate = 26;
inline bool LayerTreeSettings::has_background_animation_rate() const {
return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void LayerTreeSettings::set_has_background_animation_rate() {
_has_bits_[0] |= 0x02000000u;
}
inline void LayerTreeSettings::clear_has_background_animation_rate() {
_has_bits_[0] &= ~0x02000000u;
}
inline void LayerTreeSettings::clear_background_animation_rate() {
background_animation_rate_ = 0;
clear_has_background_animation_rate();
}
inline double LayerTreeSettings::background_animation_rate() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.background_animation_rate)
return background_animation_rate_;
}
inline void LayerTreeSettings::set_background_animation_rate(double value) {
set_has_background_animation_rate();
background_animation_rate_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.background_animation_rate)
}

// optional .cc.proto.Size default_tile_size = 27;
inline bool LayerTreeSettings::has_default_tile_size() const {
return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void LayerTreeSettings::set_has_default_tile_size() {
_has_bits_[0] |= 0x04000000u;
}
inline void LayerTreeSettings::clear_has_default_tile_size() {
_has_bits_[0] &= ~0x04000000u;
}
inline void LayerTreeSettings::clear_default_tile_size() {
if (default_tile_size_ != NULL) default_tile_size_->::cc::proto::Size::Clear();
clear_has_default_tile_size();
}
inline const ::cc::proto::Size& LayerTreeSettings::default_tile_size() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.default_tile_size)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return default_tile_size_ != NULL ? *default_tile_size_ : *default_instance().default_tile_size_;
#else
return default_tile_size_ != NULL ? *default_tile_size_ : *default_instance_->default_tile_size_;
#endif
}
inline ::cc::proto::Size* LayerTreeSettings::mutable_default_tile_size() {
set_has_default_tile_size();
if (default_tile_size_ == NULL) {
default_tile_size_ = new ::cc::proto::Size;
}
// @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeSettings.default_tile_size)
return default_tile_size_;
}
inline ::cc::proto::Size* LayerTreeSettings::release_default_tile_size() {
// @@protoc_insertion_point(field_release:cc.proto.LayerTreeSettings.default_tile_size)
clear_has_default_tile_size();
::cc::proto::Size* temp = default_tile_size_;
default_tile_size_ = NULL;
return temp;
}
inline void LayerTreeSettings::set_allocated_default_tile_size(::cc::proto::Size* default_tile_size) {
delete default_tile_size_;
default_tile_size_ = default_tile_size;
if (default_tile_size) {
set_has_default_tile_size();
} else {
clear_has_default_tile_size();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeSettings.default_tile_size)
}

// optional .cc.proto.Size max_untiled_layer_size = 28;
inline bool LayerTreeSettings::has_max_untiled_layer_size() const {
return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void LayerTreeSettings::set_has_max_untiled_layer_size() {
_has_bits_[0] |= 0x08000000u;
}
inline void LayerTreeSettings::clear_has_max_untiled_layer_size() {
_has_bits_[0] &= ~0x08000000u;
}
inline void LayerTreeSettings::clear_max_untiled_layer_size() {
if (max_untiled_layer_size_ != NULL) max_untiled_layer_size_->::cc::proto::Size::Clear();
clear_has_max_untiled_layer_size();
}
inline const ::cc::proto::Size& LayerTreeSettings::max_untiled_layer_size() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.max_untiled_layer_size)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return max_untiled_layer_size_ != NULL ? *max_untiled_layer_size_ : *default_instance().max_untiled_layer_size_;
#else
return max_untiled_layer_size_ != NULL ? *max_untiled_layer_size_ : *default_instance_->max_untiled_layer_size_;
#endif
}
inline ::cc::proto::Size* LayerTreeSettings::mutable_max_untiled_layer_size() {
set_has_max_untiled_layer_size();
if (max_untiled_layer_size_ == NULL) {
max_untiled_layer_size_ = new ::cc::proto::Size;
}
// @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeSettings.max_untiled_layer_size)
return max_untiled_layer_size_;
}
inline ::cc::proto::Size* LayerTreeSettings::release_max_untiled_layer_size() {
// @@protoc_insertion_point(field_release:cc.proto.LayerTreeSettings.max_untiled_layer_size)
clear_has_max_untiled_layer_size();
::cc::proto::Size* temp = max_untiled_layer_size_;
max_untiled_layer_size_ = NULL;
return temp;
}
inline void LayerTreeSettings::set_allocated_max_untiled_layer_size(::cc::proto::Size* max_untiled_layer_size) {
delete max_untiled_layer_size_;
max_untiled_layer_size_ = max_untiled_layer_size;
if (max_untiled_layer_size) {
set_has_max_untiled_layer_size();
} else {
clear_has_max_untiled_layer_size();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeSettings.max_untiled_layer_size)
}

// optional .cc.proto.Size minimum_occlusion_tracking_size = 29;
inline bool LayerTreeSettings::has_minimum_occlusion_tracking_size() const {
return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void LayerTreeSettings::set_has_minimum_occlusion_tracking_size() {
_has_bits_[0] |= 0x10000000u;
}
inline void LayerTreeSettings::clear_has_minimum_occlusion_tracking_size() {
_has_bits_[0] &= ~0x10000000u;
}
inline void LayerTreeSettings::clear_minimum_occlusion_tracking_size() {
if (minimum_occlusion_tracking_size_ != NULL) minimum_occlusion_tracking_size_->::cc::proto::Size::Clear();
clear_has_minimum_occlusion_tracking_size();
}
inline const ::cc::proto::Size& LayerTreeSettings::minimum_occlusion_tracking_size() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.minimum_occlusion_tracking_size)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return minimum_occlusion_tracking_size_ != NULL ? *minimum_occlusion_tracking_size_ : *default_instance().minimum_occlusion_tracking_size_;
#else
return minimum_occlusion_tracking_size_ != NULL ? *minimum_occlusion_tracking_size_ : *default_instance_->minimum_occlusion_tracking_size_;
#endif
}
inline ::cc::proto::Size* LayerTreeSettings::mutable_minimum_occlusion_tracking_size() {
set_has_minimum_occlusion_tracking_size();
if (minimum_occlusion_tracking_size_ == NULL) {
minimum_occlusion_tracking_size_ = new ::cc::proto::Size;
}
// @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeSettings.minimum_occlusion_tracking_size)
return minimum_occlusion_tracking_size_;
}
inline ::cc::proto::Size* LayerTreeSettings::release_minimum_occlusion_tracking_size() {
// @@protoc_insertion_point(field_release:cc.proto.LayerTreeSettings.minimum_occlusion_tracking_size)
clear_has_minimum_occlusion_tracking_size();
::cc::proto::Size* temp = minimum_occlusion_tracking_size_;
minimum_occlusion_tracking_size_ = NULL;
return temp;
}
inline void LayerTreeSettings::set_allocated_minimum_occlusion_tracking_size(::cc::proto::Size* minimum_occlusion_tracking_size) {
delete minimum_occlusion_tracking_size_;
minimum_occlusion_tracking_size_ = minimum_occlusion_tracking_size;
if (minimum_occlusion_tracking_size) {
set_has_minimum_occlusion_tracking_size();
} else {
clear_has_minimum_occlusion_tracking_size();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeSettings.minimum_occlusion_tracking_size)
}

// optional uint32 tiling_interest_area_padding = 30;
inline bool LayerTreeSettings::has_tiling_interest_area_padding() const {
return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void LayerTreeSettings::set_has_tiling_interest_area_padding() {
_has_bits_[0] |= 0x20000000u;
}
inline void LayerTreeSettings::clear_has_tiling_interest_area_padding() {
_has_bits_[0] &= ~0x20000000u;
}
inline void LayerTreeSettings::clear_tiling_interest_area_padding() {
tiling_interest_area_padding_ = 0u;
clear_has_tiling_interest_area_padding();
}
inline ::google::protobuf::uint32 LayerTreeSettings::tiling_interest_area_padding() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.tiling_interest_area_padding)
return tiling_interest_area_padding_;
}
inline void LayerTreeSettings::set_tiling_interest_area_padding(::google::protobuf::uint32 value) {
set_has_tiling_interest_area_padding();
tiling_interest_area_padding_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.tiling_interest_area_padding)
}

// optional float skewport_target_time_in_seconds = 31;
inline bool LayerTreeSettings::has_skewport_target_time_in_seconds() const {
return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void LayerTreeSettings::set_has_skewport_target_time_in_seconds() {
_has_bits_[0] |= 0x40000000u;
}
inline void LayerTreeSettings::clear_has_skewport_target_time_in_seconds() {
_has_bits_[0] &= ~0x40000000u;
}
inline void LayerTreeSettings::clear_skewport_target_time_in_seconds() {
skewport_target_time_in_seconds_ = 0;
clear_has_skewport_target_time_in_seconds();
}
inline float LayerTreeSettings::skewport_target_time_in_seconds() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.skewport_target_time_in_seconds)
return skewport_target_time_in_seconds_;
}
inline void LayerTreeSettings::set_skewport_target_time_in_seconds(float value) {
set_has_skewport_target_time_in_seconds();
skewport_target_time_in_seconds_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.skewport_target_time_in_seconds)
}

// optional int32 skewport_extrapolation_limit_in_screen_pixels = 32;
inline bool LayerTreeSettings::has_skewport_extrapolation_limit_in_screen_pixels() const {
return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void LayerTreeSettings::set_has_skewport_extrapolation_limit_in_screen_pixels() {
_has_bits_[0] |= 0x80000000u;
}
inline void LayerTreeSettings::clear_has_skewport_extrapolation_limit_in_screen_pixels() {
_has_bits_[0] &= ~0x80000000u;
}
inline void LayerTreeSettings::clear_skewport_extrapolation_limit_in_screen_pixels() {
skewport_extrapolation_limit_in_screen_pixels_ = 0;
clear_has_skewport_extrapolation_limit_in_screen_pixels();
}
inline ::google::protobuf::int32 LayerTreeSettings::skewport_extrapolation_limit_in_screen_pixels() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.skewport_extrapolation_limit_in_screen_pixels)
return skewport_extrapolation_limit_in_screen_pixels_;
}
inline void LayerTreeSettings::set_skewport_extrapolation_limit_in_screen_pixels(::google::protobuf::int32 value) {
set_has_skewport_extrapolation_limit_in_screen_pixels();
skewport_extrapolation_limit_in_screen_pixels_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.skewport_extrapolation_limit_in_screen_pixels)
}

// optional uint32 max_memory_for_prepaint_percentage = 33;
inline bool LayerTreeSettings::has_max_memory_for_prepaint_percentage() const {
return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void LayerTreeSettings::set_has_max_memory_for_prepaint_percentage() {
_has_bits_[1] |= 0x00000001u;
}
inline void LayerTreeSettings::clear_has_max_memory_for_prepaint_percentage() {
_has_bits_[1] &= ~0x00000001u;
}
inline void LayerTreeSettings::clear_max_memory_for_prepaint_percentage() {
max_memory_for_prepaint_percentage_ = 0u;
clear_has_max_memory_for_prepaint_percentage();
}
inline ::google::protobuf::uint32 LayerTreeSettings::max_memory_for_prepaint_percentage() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.max_memory_for_prepaint_percentage)
return max_memory_for_prepaint_percentage_;
}
inline void LayerTreeSettings::set_max_memory_for_prepaint_percentage(::google::protobuf::uint32 value) {
set_has_max_memory_for_prepaint_percentage();
max_memory_for_prepaint_percentage_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.max_memory_for_prepaint_percentage)
}

// optional bool use_zero_copy = 35;
inline bool LayerTreeSettings::has_use_zero_copy() const {
return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void LayerTreeSettings::set_has_use_zero_copy() {
_has_bits_[1] |= 0x00000002u;
}
inline void LayerTreeSettings::clear_has_use_zero_copy() {
_has_bits_[1] &= ~0x00000002u;
}
inline void LayerTreeSettings::clear_use_zero_copy() {
use_zero_copy_ = false;
clear_has_use_zero_copy();
}
inline bool LayerTreeSettings::use_zero_copy() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.use_zero_copy)
return use_zero_copy_;
}
inline void LayerTreeSettings::set_use_zero_copy(bool value) {
set_has_use_zero_copy();
use_zero_copy_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.use_zero_copy)
}

// optional bool use_partial_raster = 36;
inline bool LayerTreeSettings::has_use_partial_raster() const {
return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void LayerTreeSettings::set_has_use_partial_raster() {
_has_bits_[1] |= 0x00000004u;
}
inline void LayerTreeSettings::clear_has_use_partial_raster() {
_has_bits_[1] &= ~0x00000004u;
}
inline void LayerTreeSettings::clear_use_partial_raster() {
use_partial_raster_ = false;
clear_has_use_partial_raster();
}
inline bool LayerTreeSettings::use_partial_raster() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.use_partial_raster)
return use_partial_raster_;
}
inline void LayerTreeSettings::set_use_partial_raster(bool value) {
set_has_use_partial_raster();
use_partial_raster_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.use_partial_raster)
}

// optional bool enable_elastic_overscroll = 37;
inline bool LayerTreeSettings::has_enable_elastic_overscroll() const {
return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void LayerTreeSettings::set_has_enable_elastic_overscroll() {
_has_bits_[1] |= 0x00000008u;
}
inline void LayerTreeSettings::clear_has_enable_elastic_overscroll() {
_has_bits_[1] &= ~0x00000008u;
}
inline void LayerTreeSettings::clear_enable_elastic_overscroll() {
enable_elastic_overscroll_ = false;
clear_has_enable_elastic_overscroll();
}
inline bool LayerTreeSettings::enable_elastic_overscroll() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.enable_elastic_overscroll)
return enable_elastic_overscroll_;
}
inline void LayerTreeSettings::set_enable_elastic_overscroll(bool value) {
set_has_enable_elastic_overscroll();
enable_elastic_overscroll_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.enable_elastic_overscroll)
}

// optional bool ignore_root_layer_flings = 39;
inline bool LayerTreeSettings::has_ignore_root_layer_flings() const {
return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void LayerTreeSettings::set_has_ignore_root_layer_flings() {
_has_bits_[1] |= 0x00000010u;
}
inline void LayerTreeSettings::clear_has_ignore_root_layer_flings() {
_has_bits_[1] &= ~0x00000010u;
}
inline void LayerTreeSettings::clear_ignore_root_layer_flings() {
ignore_root_layer_flings_ = false;
clear_has_ignore_root_layer_flings();
}
inline bool LayerTreeSettings::ignore_root_layer_flings() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.ignore_root_layer_flings)
return ignore_root_layer_flings_;
}
inline void LayerTreeSettings::set_ignore_root_layer_flings(bool value) {
set_has_ignore_root_layer_flings();
ignore_root_layer_flings_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.ignore_root_layer_flings)
}

// optional uint32 scheduled_raster_task_limit = 40;
inline bool LayerTreeSettings::has_scheduled_raster_task_limit() const {
return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void LayerTreeSettings::set_has_scheduled_raster_task_limit() {
_has_bits_[1] |= 0x00000020u;
}
inline void LayerTreeSettings::clear_has_scheduled_raster_task_limit() {
_has_bits_[1] &= ~0x00000020u;
}
inline void LayerTreeSettings::clear_scheduled_raster_task_limit() {
scheduled_raster_task_limit_ = 0u;
clear_has_scheduled_raster_task_limit();
}
inline ::google::protobuf::uint32 LayerTreeSettings::scheduled_raster_task_limit() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.scheduled_raster_task_limit)
return scheduled_raster_task_limit_;
}
inline void LayerTreeSettings::set_scheduled_raster_task_limit(::google::protobuf::uint32 value) {
set_has_scheduled_raster_task_limit();
scheduled_raster_task_limit_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.scheduled_raster_task_limit)
}

// optional bool use_occlusion_for_tile_prioritization = 41;
inline bool LayerTreeSettings::has_use_occlusion_for_tile_prioritization() const {
return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void LayerTreeSettings::set_has_use_occlusion_for_tile_prioritization() {
_has_bits_[1] |= 0x00000040u;
}
inline void LayerTreeSettings::clear_has_use_occlusion_for_tile_prioritization() {
_has_bits_[1] &= ~0x00000040u;
}
inline void LayerTreeSettings::clear_use_occlusion_for_tile_prioritization() {
use_occlusion_for_tile_prioritization_ = false;
clear_has_use_occlusion_for_tile_prioritization();
}
inline bool LayerTreeSettings::use_occlusion_for_tile_prioritization() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.use_occlusion_for_tile_prioritization)
return use_occlusion_for_tile_prioritization_;
}
inline void LayerTreeSettings::set_use_occlusion_for_tile_prioritization(bool value) {
set_has_use_occlusion_for_tile_prioritization();
use_occlusion_for_tile_prioritization_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.use_occlusion_for_tile_prioritization)
}

// optional bool image_decode_tasks_enabled = 44;
inline bool LayerTreeSettings::has_image_decode_tasks_enabled() const {
return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void LayerTreeSettings::set_has_image_decode_tasks_enabled() {
_has_bits_[1] |= 0x00000080u;
}
inline void LayerTreeSettings::clear_has_image_decode_tasks_enabled() {
_has_bits_[1] &= ~0x00000080u;
}
inline void LayerTreeSettings::clear_image_decode_tasks_enabled() {
image_decode_tasks_enabled_ = false;
clear_has_image_decode_tasks_enabled();
}
inline bool LayerTreeSettings::image_decode_tasks_enabled() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.image_decode_tasks_enabled)
return image_decode_tasks_enabled_;
}
inline void LayerTreeSettings::set_image_decode_tasks_enabled(bool value) {
set_has_image_decode_tasks_enabled();
image_decode_tasks_enabled_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.image_decode_tasks_enabled)
}

// optional bool use_compositor_animation_timelines = 45;
inline bool LayerTreeSettings::has_use_compositor_animation_timelines() const {
return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void LayerTreeSettings::set_has_use_compositor_animation_timelines() {
_has_bits_[1] |= 0x00000100u;
}
inline void LayerTreeSettings::clear_has_use_compositor_animation_timelines() {
_has_bits_[1] &= ~0x00000100u;
}
inline void LayerTreeSettings::clear_use_compositor_animation_timelines() {
use_compositor_animation_timelines_ = false;
clear_has_use_compositor_animation_timelines();
}
inline bool LayerTreeSettings::use_compositor_animation_timelines() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.use_compositor_animation_timelines)
return use_compositor_animation_timelines_;
}
inline void LayerTreeSettings::set_use_compositor_animation_timelines(bool value) {
set_has_use_compositor_animation_timelines();
use_compositor_animation_timelines_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.use_compositor_animation_timelines)
}

// optional bool wait_for_beginframe_interval = 46;
inline bool LayerTreeSettings::has_wait_for_beginframe_interval() const {
return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void LayerTreeSettings::set_has_wait_for_beginframe_interval() {
_has_bits_[1] |= 0x00000200u;
}
inline void LayerTreeSettings::clear_has_wait_for_beginframe_interval() {
_has_bits_[1] &= ~0x00000200u;
}
inline void LayerTreeSettings::clear_wait_for_beginframe_interval() {
wait_for_beginframe_interval_ = false;
clear_has_wait_for_beginframe_interval();
}
inline bool LayerTreeSettings::wait_for_beginframe_interval() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.wait_for_beginframe_interval)
return wait_for_beginframe_interval_;
}
inline void LayerTreeSettings::set_wait_for_beginframe_interval(bool value) {
set_has_wait_for_beginframe_interval();
wait_for_beginframe_interval_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.wait_for_beginframe_interval)
}

// optional int32 max_staging_buffer_usage_in_bytes = 47;
inline bool LayerTreeSettings::has_max_staging_buffer_usage_in_bytes() const {
return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void LayerTreeSettings::set_has_max_staging_buffer_usage_in_bytes() {
_has_bits_[1] |= 0x00000400u;
}
inline void LayerTreeSettings::clear_has_max_staging_buffer_usage_in_bytes() {
_has_bits_[1] &= ~0x00000400u;
}
inline void LayerTreeSettings::clear_max_staging_buffer_usage_in_bytes() {
max_staging_buffer_usage_in_bytes_ = 0;
clear_has_max_staging_buffer_usage_in_bytes();
}
inline ::google::protobuf::int32 LayerTreeSettings::max_staging_buffer_usage_in_bytes() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.max_staging_buffer_usage_in_bytes)
return max_staging_buffer_usage_in_bytes_;
}
inline void LayerTreeSettings::set_max_staging_buffer_usage_in_bytes(::google::protobuf::int32 value) {
set_has_max_staging_buffer_usage_in_bytes();
max_staging_buffer_usage_in_bytes_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.max_staging_buffer_usage_in_bytes)
}

// optional .cc.proto.ManagedMemoryPolicy memory_policy = 48;
inline bool LayerTreeSettings::has_memory_policy() const {
return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void LayerTreeSettings::set_has_memory_policy() {
_has_bits_[1] |= 0x00000800u;
}
inline void LayerTreeSettings::clear_has_memory_policy() {
_has_bits_[1] &= ~0x00000800u;
}
inline void LayerTreeSettings::clear_memory_policy() {
if (memory_policy_ != NULL) memory_policy_->::cc::proto::ManagedMemoryPolicy::Clear();
clear_has_memory_policy();
}
inline const ::cc::proto::ManagedMemoryPolicy& LayerTreeSettings::memory_policy() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.memory_policy)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return memory_policy_ != NULL ? *memory_policy_ : *default_instance().memory_policy_;
#else
return memory_policy_ != NULL ? *memory_policy_ : *default_instance_->memory_policy_;
#endif
}
inline ::cc::proto::ManagedMemoryPolicy* LayerTreeSettings::mutable_memory_policy() {
set_has_memory_policy();
if (memory_policy_ == NULL) {
memory_policy_ = new ::cc::proto::ManagedMemoryPolicy;
}
// @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeSettings.memory_policy)
return memory_policy_;
}
inline ::cc::proto::ManagedMemoryPolicy* LayerTreeSettings::release_memory_policy() {
// @@protoc_insertion_point(field_release:cc.proto.LayerTreeSettings.memory_policy)
clear_has_memory_policy();
::cc::proto::ManagedMemoryPolicy* temp = memory_policy_;
memory_policy_ = NULL;
return temp;
}
inline void LayerTreeSettings::set_allocated_memory_policy(::cc::proto::ManagedMemoryPolicy* memory_policy) {
delete memory_policy_;
memory_policy_ = memory_policy;
if (memory_policy) {
set_has_memory_policy();
} else {
clear_has_memory_policy();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeSettings.memory_policy)
}

// optional .cc.proto.LayerTreeDebugState initial_debug_state = 49;
inline bool LayerTreeSettings::has_initial_debug_state() const {
return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void LayerTreeSettings::set_has_initial_debug_state() {
_has_bits_[1] |= 0x00001000u;
}
inline void LayerTreeSettings::clear_has_initial_debug_state() {
_has_bits_[1] &= ~0x00001000u;
}
inline void LayerTreeSettings::clear_initial_debug_state() {
if (initial_debug_state_ != NULL) initial_debug_state_->::cc::proto::LayerTreeDebugState::Clear();
clear_has_initial_debug_state();
}
inline const ::cc::proto::LayerTreeDebugState& LayerTreeSettings::initial_debug_state() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.initial_debug_state)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return initial_debug_state_ != NULL ? *initial_debug_state_ : *default_instance().initial_debug_state_;
#else
return initial_debug_state_ != NULL ? *initial_debug_state_ : *default_instance_->initial_debug_state_;
#endif
}
inline ::cc::proto::LayerTreeDebugState* LayerTreeSettings::mutable_initial_debug_state() {
set_has_initial_debug_state();
if (initial_debug_state_ == NULL) {
initial_debug_state_ = new ::cc::proto::LayerTreeDebugState;
}
// @@protoc_insertion_point(field_mutable:cc.proto.LayerTreeSettings.initial_debug_state)
return initial_debug_state_;
}
inline ::cc::proto::LayerTreeDebugState* LayerTreeSettings::release_initial_debug_state() {
// @@protoc_insertion_point(field_release:cc.proto.LayerTreeSettings.initial_debug_state)
clear_has_initial_debug_state();
::cc::proto::LayerTreeDebugState* temp = initial_debug_state_;
initial_debug_state_ = NULL;
return temp;
}
inline void LayerTreeSettings::set_allocated_initial_debug_state(::cc::proto::LayerTreeDebugState* initial_debug_state) {
delete initial_debug_state_;
initial_debug_state_ = initial_debug_state;
if (initial_debug_state) {
set_has_initial_debug_state();
} else {
clear_has_initial_debug_state();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.LayerTreeSettings.initial_debug_state)
}

// optional bool use_cached_picture_raster = 51;
inline bool LayerTreeSettings::has_use_cached_picture_raster() const {
return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void LayerTreeSettings::set_has_use_cached_picture_raster() {
_has_bits_[1] |= 0x00002000u;
}
inline void LayerTreeSettings::clear_has_use_cached_picture_raster() {
_has_bits_[1] &= ~0x00002000u;
}
inline void LayerTreeSettings::clear_use_cached_picture_raster() {
use_cached_picture_raster_ = false;
clear_has_use_cached_picture_raster();
}
inline bool LayerTreeSettings::use_cached_picture_raster() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.use_cached_picture_raster)
return use_cached_picture_raster_;
}
inline void LayerTreeSettings::set_use_cached_picture_raster(bool value) {
set_has_use_cached_picture_raster();
use_cached_picture_raster_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.use_cached_picture_raster)
}

// optional bool async_worker_context_enabled = 52;
inline bool LayerTreeSettings::has_async_worker_context_enabled() const {
return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void LayerTreeSettings::set_has_async_worker_context_enabled() {
_has_bits_[1] |= 0x00004000u;
}
inline void LayerTreeSettings::clear_has_async_worker_context_enabled() {
_has_bits_[1] &= ~0x00004000u;
}
inline void LayerTreeSettings::clear_async_worker_context_enabled() {
async_worker_context_enabled_ = false;
clear_has_async_worker_context_enabled();
}
inline bool LayerTreeSettings::async_worker_context_enabled() const {
// @@protoc_insertion_point(field_get:cc.proto.LayerTreeSettings.async_worker_context_enabled)
return async_worker_context_enabled_;
}
inline void LayerTreeSettings::set_async_worker_context_enabled(bool value) {
set_has_async_worker_context_enabled();
async_worker_context_enabled_ = value;
// @@protoc_insertion_point(field_set:cc.proto.LayerTreeSettings.async_worker_context_enabled)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cc::proto::LayerTreeSettings_ScrollbarAnimator> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_layer_5ftree_5fsettings_2eproto__INCLUDED
