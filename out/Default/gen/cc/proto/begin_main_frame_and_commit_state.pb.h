// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: begin_main_frame_and_commit_state.proto

#ifndef PROTOBUF_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto__INCLUDED
#define PROTOBUF_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
#include "vector2d.pb.h"
#include "vector2df.pb.h"
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

// Internal implementation detail -- do not call these.
void CC_PROTO_EXPORT protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
void protobuf_AssignDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
void protobuf_ShutdownFile_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();

class BeginFrameArgs;
class BeginMainFrameAndCommitState;
class ScrollAndScaleSet;
class ScrollUpdateInfo;

enum BeginFrameArgs_BeginFrameArgsType {
BeginFrameArgs_BeginFrameArgsType_INVALID = 1,
BeginFrameArgs_BeginFrameArgsType_NORMAL = 2,
BeginFrameArgs_BeginFrameArgsType_MISSED = 3,
BeginFrameArgs_BeginFrameArgsType_BEGIN_FRAME_ARGS_TYPE_MAX = 100
};
CC_PROTO_EXPORT bool BeginFrameArgs_BeginFrameArgsType_IsValid(int value);
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs_BeginFrameArgsType_BeginFrameArgsType_MIN = BeginFrameArgs_BeginFrameArgsType_INVALID;
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs_BeginFrameArgsType_BeginFrameArgsType_MAX = BeginFrameArgs_BeginFrameArgsType_BEGIN_FRAME_ARGS_TYPE_MAX;
const int BeginFrameArgs_BeginFrameArgsType_BeginFrameArgsType_ARRAYSIZE = BeginFrameArgs_BeginFrameArgsType_BeginFrameArgsType_MAX + 1;

// ===================================================================

class CC_PROTO_EXPORT ScrollUpdateInfo : public ::google::protobuf::MessageLite {
public:
ScrollUpdateInfo();
virtual ~ScrollUpdateInfo();

ScrollUpdateInfo(const ScrollUpdateInfo& from);

inline ScrollUpdateInfo& operator=(const ScrollUpdateInfo& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const ScrollUpdateInfo& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const ScrollUpdateInfo* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(ScrollUpdateInfo* other);

// implements Message ----------------------------------------------

inline ScrollUpdateInfo* New() const { return New(NULL); }

ScrollUpdateInfo* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const ScrollUpdateInfo& from);
void MergeFrom(const ScrollUpdateInfo& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ScrollUpdateInfo* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional int64 layer_id = 1;
bool has_layer_id() const;
void clear_layer_id();
static const int kLayerIdFieldNumber = 1;
::google::protobuf::int64 layer_id() const;
void set_layer_id(::google::protobuf::int64 value);

// optional .cc.proto.Vector2d scroll_delta = 2;
bool has_scroll_delta() const;
void clear_scroll_delta();
static const int kScrollDeltaFieldNumber = 2;
const ::cc::proto::Vector2d& scroll_delta() const;
::cc::proto::Vector2d* mutable_scroll_delta();
::cc::proto::Vector2d* release_scroll_delta();
void set_allocated_scroll_delta(::cc::proto::Vector2d* scroll_delta);

// @@protoc_insertion_point(class_scope:cc.proto.ScrollUpdateInfo)
private:
inline void set_has_layer_id();
inline void clear_has_layer_id();
inline void set_has_scroll_delta();
inline void clear_has_scroll_delta();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::google::protobuf::int64 layer_id_;
::cc::proto::Vector2d* scroll_delta_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#endif
friend void protobuf_AssignDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
friend void protobuf_ShutdownFile_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();

void InitAsDefaultInstance();
static ScrollUpdateInfo* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT ScrollAndScaleSet : public ::google::protobuf::MessageLite {
public:
ScrollAndScaleSet();
virtual ~ScrollAndScaleSet();

ScrollAndScaleSet(const ScrollAndScaleSet& from);

inline ScrollAndScaleSet& operator=(const ScrollAndScaleSet& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const ScrollAndScaleSet& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const ScrollAndScaleSet* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(ScrollAndScaleSet* other);

// implements Message ----------------------------------------------

inline ScrollAndScaleSet* New() const { return New(NULL); }

ScrollAndScaleSet* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const ScrollAndScaleSet& from);
void MergeFrom(const ScrollAndScaleSet& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ScrollAndScaleSet* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// repeated .cc.proto.ScrollUpdateInfo scrolls = 1;
int scrolls_size() const;
void clear_scrolls();
static const int kScrollsFieldNumber = 1;
const ::cc::proto::ScrollUpdateInfo& scrolls(int index) const;
::cc::proto::ScrollUpdateInfo* mutable_scrolls(int index);
::cc::proto::ScrollUpdateInfo* add_scrolls();
::google::protobuf::RepeatedPtrField< ::cc::proto::ScrollUpdateInfo >*
mutable_scrolls();
const ::google::protobuf::RepeatedPtrField< ::cc::proto::ScrollUpdateInfo >&
scrolls() const;

// optional float page_scale_delta = 2;
bool has_page_scale_delta() const;
void clear_page_scale_delta();
static const int kPageScaleDeltaFieldNumber = 2;
float page_scale_delta() const;
void set_page_scale_delta(float value);

// optional .cc.proto.Vector2dF elastic_overscroll_delta = 3;
bool has_elastic_overscroll_delta() const;
void clear_elastic_overscroll_delta();
static const int kElasticOverscrollDeltaFieldNumber = 3;
const ::cc::proto::Vector2dF& elastic_overscroll_delta() const;
::cc::proto::Vector2dF* mutable_elastic_overscroll_delta();
::cc::proto::Vector2dF* release_elastic_overscroll_delta();
void set_allocated_elastic_overscroll_delta(::cc::proto::Vector2dF* elastic_overscroll_delta);

// optional float top_controls_delta = 4;
bool has_top_controls_delta() const;
void clear_top_controls_delta();
static const int kTopControlsDeltaFieldNumber = 4;
float top_controls_delta() const;
void set_top_controls_delta(float value);

// @@protoc_insertion_point(class_scope:cc.proto.ScrollAndScaleSet)
private:
inline void set_has_page_scale_delta();
inline void clear_has_page_scale_delta();
inline void set_has_elastic_overscroll_delta();
inline void clear_has_elastic_overscroll_delta();
inline void set_has_top_controls_delta();
inline void clear_has_top_controls_delta();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::google::protobuf::RepeatedPtrField< ::cc::proto::ScrollUpdateInfo > scrolls_;
::cc::proto::Vector2dF* elastic_overscroll_delta_;
float page_scale_delta_;
float top_controls_delta_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#endif
friend void protobuf_AssignDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
friend void protobuf_ShutdownFile_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();

void InitAsDefaultInstance();
static ScrollAndScaleSet* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT BeginFrameArgs : public ::google::protobuf::MessageLite {
public:
BeginFrameArgs();
virtual ~BeginFrameArgs();

BeginFrameArgs(const BeginFrameArgs& from);

inline BeginFrameArgs& operator=(const BeginFrameArgs& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const BeginFrameArgs& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const BeginFrameArgs* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(BeginFrameArgs* other);

// implements Message ----------------------------------------------

inline BeginFrameArgs* New() const { return New(NULL); }

BeginFrameArgs* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const BeginFrameArgs& from);
void MergeFrom(const BeginFrameArgs& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(BeginFrameArgs* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

typedef BeginFrameArgs_BeginFrameArgsType BeginFrameArgsType;
static const BeginFrameArgsType INVALID =
BeginFrameArgs_BeginFrameArgsType_INVALID;
static const BeginFrameArgsType NORMAL =
BeginFrameArgs_BeginFrameArgsType_NORMAL;
static const BeginFrameArgsType MISSED =
BeginFrameArgs_BeginFrameArgsType_MISSED;
static const BeginFrameArgsType BEGIN_FRAME_ARGS_TYPE_MAX =
BeginFrameArgs_BeginFrameArgsType_BEGIN_FRAME_ARGS_TYPE_MAX;
static inline bool BeginFrameArgsType_IsValid(int value) {
return BeginFrameArgs_BeginFrameArgsType_IsValid(value);
}
static const BeginFrameArgsType BeginFrameArgsType_MIN =
BeginFrameArgs_BeginFrameArgsType_BeginFrameArgsType_MIN;
static const BeginFrameArgsType BeginFrameArgsType_MAX =
BeginFrameArgs_BeginFrameArgsType_BeginFrameArgsType_MAX;
static const int BeginFrameArgsType_ARRAYSIZE =
BeginFrameArgs_BeginFrameArgsType_BeginFrameArgsType_ARRAYSIZE;

// accessors -------------------------------------------------------

// optional int64 frame_time = 1;
bool has_frame_time() const;
void clear_frame_time();
static const int kFrameTimeFieldNumber = 1;
::google::protobuf::int64 frame_time() const;
void set_frame_time(::google::protobuf::int64 value);

// optional int64 deadline = 2;
bool has_deadline() const;
void clear_deadline();
static const int kDeadlineFieldNumber = 2;
::google::protobuf::int64 deadline() const;
void set_deadline(::google::protobuf::int64 value);

// optional int64 interval = 3;
bool has_interval() const;
void clear_interval();
static const int kIntervalFieldNumber = 3;
::google::protobuf::int64 interval() const;
void set_interval(::google::protobuf::int64 value);

// optional .cc.proto.BeginFrameArgs.BeginFrameArgsType type = 4;
bool has_type() const;
void clear_type();
static const int kTypeFieldNumber = 4;
::cc::proto::BeginFrameArgs_BeginFrameArgsType type() const;
void set_type(::cc::proto::BeginFrameArgs_BeginFrameArgsType value);

// optional bool on_critical_path = 5;
bool has_on_critical_path() const;
void clear_on_critical_path();
static const int kOnCriticalPathFieldNumber = 5;
bool on_critical_path() const;
void set_on_critical_path(bool value);

// @@protoc_insertion_point(class_scope:cc.proto.BeginFrameArgs)
private:
inline void set_has_frame_time();
inline void clear_has_frame_time();
inline void set_has_deadline();
inline void clear_has_deadline();
inline void set_has_interval();
inline void clear_has_interval();
inline void set_has_type();
inline void clear_has_type();
inline void set_has_on_critical_path();
inline void clear_has_on_critical_path();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::google::protobuf::int64 frame_time_;
::google::protobuf::int64 deadline_;
::google::protobuf::int64 interval_;
int type_;
bool on_critical_path_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#endif
friend void protobuf_AssignDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
friend void protobuf_ShutdownFile_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();

void InitAsDefaultInstance();
static BeginFrameArgs* default_instance_;
};
// -------------------------------------------------------------------

class CC_PROTO_EXPORT BeginMainFrameAndCommitState : public ::google::protobuf::MessageLite {
public:
BeginMainFrameAndCommitState();
virtual ~BeginMainFrameAndCommitState();

BeginMainFrameAndCommitState(const BeginMainFrameAndCommitState& from);

inline BeginMainFrameAndCommitState& operator=(const BeginMainFrameAndCommitState& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const BeginMainFrameAndCommitState& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const BeginMainFrameAndCommitState* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(BeginMainFrameAndCommitState* other);

// implements Message ----------------------------------------------

inline BeginMainFrameAndCommitState* New() const { return New(NULL); }

BeginMainFrameAndCommitState* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const BeginMainFrameAndCommitState& from);
void MergeFrom(const BeginMainFrameAndCommitState& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(BeginMainFrameAndCommitState* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional int64 begin_frame_id = 1;
bool has_begin_frame_id() const;
void clear_begin_frame_id();
static const int kBeginFrameIdFieldNumber = 1;
::google::protobuf::int64 begin_frame_id() const;
void set_begin_frame_id(::google::protobuf::int64 value);

// optional .cc.proto.BeginFrameArgs begin_frame_args = 2;
bool has_begin_frame_args() const;
void clear_begin_frame_args();
static const int kBeginFrameArgsFieldNumber = 2;
const ::cc::proto::BeginFrameArgs& begin_frame_args() const;
::cc::proto::BeginFrameArgs* mutable_begin_frame_args();
::cc::proto::BeginFrameArgs* release_begin_frame_args();
void set_allocated_begin_frame_args(::cc::proto::BeginFrameArgs* begin_frame_args);

// optional .cc.proto.ScrollAndScaleSet scroll_info = 3;
bool has_scroll_info() const;
void clear_scroll_info();
static const int kScrollInfoFieldNumber = 3;
const ::cc::proto::ScrollAndScaleSet& scroll_info() const;
::cc::proto::ScrollAndScaleSet* mutable_scroll_info();
::cc::proto::ScrollAndScaleSet* release_scroll_info();
void set_allocated_scroll_info(::cc::proto::ScrollAndScaleSet* scroll_info);

// optional int64 memory_allocation_limit_bytes = 4;
bool has_memory_allocation_limit_bytes() const;
void clear_memory_allocation_limit_bytes();
static const int kMemoryAllocationLimitBytesFieldNumber = 4;
::google::protobuf::int64 memory_allocation_limit_bytes() const;
void set_memory_allocation_limit_bytes(::google::protobuf::int64 value);

// optional bool evicted_ui_resources = 5;
bool has_evicted_ui_resources() const;
void clear_evicted_ui_resources();
static const int kEvictedUiResourcesFieldNumber = 5;
bool evicted_ui_resources() const;
void set_evicted_ui_resources(bool value);

// @@protoc_insertion_point(class_scope:cc.proto.BeginMainFrameAndCommitState)
private:
inline void set_has_begin_frame_id();
inline void clear_has_begin_frame_id();
inline void set_has_begin_frame_args();
inline void clear_has_begin_frame_args();
inline void set_has_scroll_info();
inline void clear_has_scroll_info();
inline void set_has_memory_allocation_limit_bytes();
inline void clear_has_memory_allocation_limit_bytes();
inline void set_has_evicted_ui_resources();
inline void clear_has_evicted_ui_resources();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::google::protobuf::int64 begin_frame_id_;
::cc::proto::BeginFrameArgs* begin_frame_args_;
::cc::proto::ScrollAndScaleSet* scroll_info_;
::google::protobuf::int64 memory_allocation_limit_bytes_;
bool evicted_ui_resources_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#endif
friend void protobuf_AssignDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
friend void protobuf_ShutdownFile_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();

void InitAsDefaultInstance();
static BeginMainFrameAndCommitState* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ScrollUpdateInfo

// optional int64 layer_id = 1;
inline bool ScrollUpdateInfo::has_layer_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScrollUpdateInfo::set_has_layer_id() {
_has_bits_[0] |= 0x00000001u;
}
inline void ScrollUpdateInfo::clear_has_layer_id() {
_has_bits_[0] &= ~0x00000001u;
}
inline void ScrollUpdateInfo::clear_layer_id() {
layer_id_ = GOOGLE_LONGLONG(0);
clear_has_layer_id();
}
inline ::google::protobuf::int64 ScrollUpdateInfo::layer_id() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollUpdateInfo.layer_id)
return layer_id_;
}
inline void ScrollUpdateInfo::set_layer_id(::google::protobuf::int64 value) {
set_has_layer_id();
layer_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollUpdateInfo.layer_id)
}

// optional .cc.proto.Vector2d scroll_delta = 2;
inline bool ScrollUpdateInfo::has_scroll_delta() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScrollUpdateInfo::set_has_scroll_delta() {
_has_bits_[0] |= 0x00000002u;
}
inline void ScrollUpdateInfo::clear_has_scroll_delta() {
_has_bits_[0] &= ~0x00000002u;
}
inline void ScrollUpdateInfo::clear_scroll_delta() {
if (scroll_delta_ != NULL) scroll_delta_->::cc::proto::Vector2d::Clear();
clear_has_scroll_delta();
}
inline const ::cc::proto::Vector2d& ScrollUpdateInfo::scroll_delta() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollUpdateInfo.scroll_delta)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return scroll_delta_ != NULL ? *scroll_delta_ : *default_instance().scroll_delta_;
#else
return scroll_delta_ != NULL ? *scroll_delta_ : *default_instance_->scroll_delta_;
#endif
}
inline ::cc::proto::Vector2d* ScrollUpdateInfo::mutable_scroll_delta() {
set_has_scroll_delta();
if (scroll_delta_ == NULL) {
scroll_delta_ = new ::cc::proto::Vector2d;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollUpdateInfo.scroll_delta)
return scroll_delta_;
}
inline ::cc::proto::Vector2d* ScrollUpdateInfo::release_scroll_delta() {
// @@protoc_insertion_point(field_release:cc.proto.ScrollUpdateInfo.scroll_delta)
clear_has_scroll_delta();
::cc::proto::Vector2d* temp = scroll_delta_;
scroll_delta_ = NULL;
return temp;
}
inline void ScrollUpdateInfo::set_allocated_scroll_delta(::cc::proto::Vector2d* scroll_delta) {
delete scroll_delta_;
scroll_delta_ = scroll_delta;
if (scroll_delta) {
set_has_scroll_delta();
} else {
clear_has_scroll_delta();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollUpdateInfo.scroll_delta)
}

// -------------------------------------------------------------------

// ScrollAndScaleSet

// repeated .cc.proto.ScrollUpdateInfo scrolls = 1;
inline int ScrollAndScaleSet::scrolls_size() const {
return scrolls_.size();
}
inline void ScrollAndScaleSet::clear_scrolls() {
scrolls_.Clear();
}
inline const ::cc::proto::ScrollUpdateInfo& ScrollAndScaleSet::scrolls(int index) const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollAndScaleSet.scrolls)
return scrolls_.Get(index);
}
inline ::cc::proto::ScrollUpdateInfo* ScrollAndScaleSet::mutable_scrolls(int index) {
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollAndScaleSet.scrolls)
return scrolls_.Mutable(index);
}
inline ::cc::proto::ScrollUpdateInfo* ScrollAndScaleSet::add_scrolls() {
// @@protoc_insertion_point(field_add:cc.proto.ScrollAndScaleSet.scrolls)
return scrolls_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cc::proto::ScrollUpdateInfo >*
ScrollAndScaleSet::mutable_scrolls() {
// @@protoc_insertion_point(field_mutable_list:cc.proto.ScrollAndScaleSet.scrolls)
return &scrolls_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cc::proto::ScrollUpdateInfo >&
ScrollAndScaleSet::scrolls() const {
// @@protoc_insertion_point(field_list:cc.proto.ScrollAndScaleSet.scrolls)
return scrolls_;
}

// optional float page_scale_delta = 2;
inline bool ScrollAndScaleSet::has_page_scale_delta() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScrollAndScaleSet::set_has_page_scale_delta() {
_has_bits_[0] |= 0x00000002u;
}
inline void ScrollAndScaleSet::clear_has_page_scale_delta() {
_has_bits_[0] &= ~0x00000002u;
}
inline void ScrollAndScaleSet::clear_page_scale_delta() {
page_scale_delta_ = 0;
clear_has_page_scale_delta();
}
inline float ScrollAndScaleSet::page_scale_delta() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollAndScaleSet.page_scale_delta)
return page_scale_delta_;
}
inline void ScrollAndScaleSet::set_page_scale_delta(float value) {
set_has_page_scale_delta();
page_scale_delta_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollAndScaleSet.page_scale_delta)
}

// optional .cc.proto.Vector2dF elastic_overscroll_delta = 3;
inline bool ScrollAndScaleSet::has_elastic_overscroll_delta() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScrollAndScaleSet::set_has_elastic_overscroll_delta() {
_has_bits_[0] |= 0x00000004u;
}
inline void ScrollAndScaleSet::clear_has_elastic_overscroll_delta() {
_has_bits_[0] &= ~0x00000004u;
}
inline void ScrollAndScaleSet::clear_elastic_overscroll_delta() {
if (elastic_overscroll_delta_ != NULL) elastic_overscroll_delta_->::cc::proto::Vector2dF::Clear();
clear_has_elastic_overscroll_delta();
}
inline const ::cc::proto::Vector2dF& ScrollAndScaleSet::elastic_overscroll_delta() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollAndScaleSet.elastic_overscroll_delta)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return elastic_overscroll_delta_ != NULL ? *elastic_overscroll_delta_ : *default_instance().elastic_overscroll_delta_;
#else
return elastic_overscroll_delta_ != NULL ? *elastic_overscroll_delta_ : *default_instance_->elastic_overscroll_delta_;
#endif
}
inline ::cc::proto::Vector2dF* ScrollAndScaleSet::mutable_elastic_overscroll_delta() {
set_has_elastic_overscroll_delta();
if (elastic_overscroll_delta_ == NULL) {
elastic_overscroll_delta_ = new ::cc::proto::Vector2dF;
}
// @@protoc_insertion_point(field_mutable:cc.proto.ScrollAndScaleSet.elastic_overscroll_delta)
return elastic_overscroll_delta_;
}
inline ::cc::proto::Vector2dF* ScrollAndScaleSet::release_elastic_overscroll_delta() {
// @@protoc_insertion_point(field_release:cc.proto.ScrollAndScaleSet.elastic_overscroll_delta)
clear_has_elastic_overscroll_delta();
::cc::proto::Vector2dF* temp = elastic_overscroll_delta_;
elastic_overscroll_delta_ = NULL;
return temp;
}
inline void ScrollAndScaleSet::set_allocated_elastic_overscroll_delta(::cc::proto::Vector2dF* elastic_overscroll_delta) {
delete elastic_overscroll_delta_;
elastic_overscroll_delta_ = elastic_overscroll_delta;
if (elastic_overscroll_delta) {
set_has_elastic_overscroll_delta();
} else {
clear_has_elastic_overscroll_delta();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollAndScaleSet.elastic_overscroll_delta)
}

// optional float top_controls_delta = 4;
inline bool ScrollAndScaleSet::has_top_controls_delta() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScrollAndScaleSet::set_has_top_controls_delta() {
_has_bits_[0] |= 0x00000008u;
}
inline void ScrollAndScaleSet::clear_has_top_controls_delta() {
_has_bits_[0] &= ~0x00000008u;
}
inline void ScrollAndScaleSet::clear_top_controls_delta() {
top_controls_delta_ = 0;
clear_has_top_controls_delta();
}
inline float ScrollAndScaleSet::top_controls_delta() const {
// @@protoc_insertion_point(field_get:cc.proto.ScrollAndScaleSet.top_controls_delta)
return top_controls_delta_;
}
inline void ScrollAndScaleSet::set_top_controls_delta(float value) {
set_has_top_controls_delta();
top_controls_delta_ = value;
// @@protoc_insertion_point(field_set:cc.proto.ScrollAndScaleSet.top_controls_delta)
}

// -------------------------------------------------------------------

// BeginFrameArgs

// optional int64 frame_time = 1;
inline bool BeginFrameArgs::has_frame_time() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BeginFrameArgs::set_has_frame_time() {
_has_bits_[0] |= 0x00000001u;
}
inline void BeginFrameArgs::clear_has_frame_time() {
_has_bits_[0] &= ~0x00000001u;
}
inline void BeginFrameArgs::clear_frame_time() {
frame_time_ = GOOGLE_LONGLONG(0);
clear_has_frame_time();
}
inline ::google::protobuf::int64 BeginFrameArgs::frame_time() const {
// @@protoc_insertion_point(field_get:cc.proto.BeginFrameArgs.frame_time)
return frame_time_;
}
inline void BeginFrameArgs::set_frame_time(::google::protobuf::int64 value) {
set_has_frame_time();
frame_time_ = value;
// @@protoc_insertion_point(field_set:cc.proto.BeginFrameArgs.frame_time)
}

// optional int64 deadline = 2;
inline bool BeginFrameArgs::has_deadline() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BeginFrameArgs::set_has_deadline() {
_has_bits_[0] |= 0x00000002u;
}
inline void BeginFrameArgs::clear_has_deadline() {
_has_bits_[0] &= ~0x00000002u;
}
inline void BeginFrameArgs::clear_deadline() {
deadline_ = GOOGLE_LONGLONG(0);
clear_has_deadline();
}
inline ::google::protobuf::int64 BeginFrameArgs::deadline() const {
// @@protoc_insertion_point(field_get:cc.proto.BeginFrameArgs.deadline)
return deadline_;
}
inline void BeginFrameArgs::set_deadline(::google::protobuf::int64 value) {
set_has_deadline();
deadline_ = value;
// @@protoc_insertion_point(field_set:cc.proto.BeginFrameArgs.deadline)
}

// optional int64 interval = 3;
inline bool BeginFrameArgs::has_interval() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BeginFrameArgs::set_has_interval() {
_has_bits_[0] |= 0x00000004u;
}
inline void BeginFrameArgs::clear_has_interval() {
_has_bits_[0] &= ~0x00000004u;
}
inline void BeginFrameArgs::clear_interval() {
interval_ = GOOGLE_LONGLONG(0);
clear_has_interval();
}
inline ::google::protobuf::int64 BeginFrameArgs::interval() const {
// @@protoc_insertion_point(field_get:cc.proto.BeginFrameArgs.interval)
return interval_;
}
inline void BeginFrameArgs::set_interval(::google::protobuf::int64 value) {
set_has_interval();
interval_ = value;
// @@protoc_insertion_point(field_set:cc.proto.BeginFrameArgs.interval)
}

// optional .cc.proto.BeginFrameArgs.BeginFrameArgsType type = 4;
inline bool BeginFrameArgs::has_type() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BeginFrameArgs::set_has_type() {
_has_bits_[0] |= 0x00000008u;
}
inline void BeginFrameArgs::clear_has_type() {
_has_bits_[0] &= ~0x00000008u;
}
inline void BeginFrameArgs::clear_type() {
type_ = 1;
clear_has_type();
}
inline ::cc::proto::BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::type() const {
// @@protoc_insertion_point(field_get:cc.proto.BeginFrameArgs.type)
return static_cast< ::cc::proto::BeginFrameArgs_BeginFrameArgsType >(type_);
}
inline void BeginFrameArgs::set_type(::cc::proto::BeginFrameArgs_BeginFrameArgsType value) {
assert(::cc::proto::BeginFrameArgs_BeginFrameArgsType_IsValid(value));
set_has_type();
type_ = value;
// @@protoc_insertion_point(field_set:cc.proto.BeginFrameArgs.type)
}

// optional bool on_critical_path = 5;
inline bool BeginFrameArgs::has_on_critical_path() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BeginFrameArgs::set_has_on_critical_path() {
_has_bits_[0] |= 0x00000010u;
}
inline void BeginFrameArgs::clear_has_on_critical_path() {
_has_bits_[0] &= ~0x00000010u;
}
inline void BeginFrameArgs::clear_on_critical_path() {
on_critical_path_ = false;
clear_has_on_critical_path();
}
inline bool BeginFrameArgs::on_critical_path() const {
// @@protoc_insertion_point(field_get:cc.proto.BeginFrameArgs.on_critical_path)
return on_critical_path_;
}
inline void BeginFrameArgs::set_on_critical_path(bool value) {
set_has_on_critical_path();
on_critical_path_ = value;
// @@protoc_insertion_point(field_set:cc.proto.BeginFrameArgs.on_critical_path)
}

// -------------------------------------------------------------------

// BeginMainFrameAndCommitState

// optional int64 begin_frame_id = 1;
inline bool BeginMainFrameAndCommitState::has_begin_frame_id() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BeginMainFrameAndCommitState::set_has_begin_frame_id() {
_has_bits_[0] |= 0x00000001u;
}
inline void BeginMainFrameAndCommitState::clear_has_begin_frame_id() {
_has_bits_[0] &= ~0x00000001u;
}
inline void BeginMainFrameAndCommitState::clear_begin_frame_id() {
begin_frame_id_ = GOOGLE_LONGLONG(0);
clear_has_begin_frame_id();
}
inline ::google::protobuf::int64 BeginMainFrameAndCommitState::begin_frame_id() const {
// @@protoc_insertion_point(field_get:cc.proto.BeginMainFrameAndCommitState.begin_frame_id)
return begin_frame_id_;
}
inline void BeginMainFrameAndCommitState::set_begin_frame_id(::google::protobuf::int64 value) {
set_has_begin_frame_id();
begin_frame_id_ = value;
// @@protoc_insertion_point(field_set:cc.proto.BeginMainFrameAndCommitState.begin_frame_id)
}

// optional .cc.proto.BeginFrameArgs begin_frame_args = 2;
inline bool BeginMainFrameAndCommitState::has_begin_frame_args() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BeginMainFrameAndCommitState::set_has_begin_frame_args() {
_has_bits_[0] |= 0x00000002u;
}
inline void BeginMainFrameAndCommitState::clear_has_begin_frame_args() {
_has_bits_[0] &= ~0x00000002u;
}
inline void BeginMainFrameAndCommitState::clear_begin_frame_args() {
if (begin_frame_args_ != NULL) begin_frame_args_->::cc::proto::BeginFrameArgs::Clear();
clear_has_begin_frame_args();
}
inline const ::cc::proto::BeginFrameArgs& BeginMainFrameAndCommitState::begin_frame_args() const {
// @@protoc_insertion_point(field_get:cc.proto.BeginMainFrameAndCommitState.begin_frame_args)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return begin_frame_args_ != NULL ? *begin_frame_args_ : *default_instance().begin_frame_args_;
#else
return begin_frame_args_ != NULL ? *begin_frame_args_ : *default_instance_->begin_frame_args_;
#endif
}
inline ::cc::proto::BeginFrameArgs* BeginMainFrameAndCommitState::mutable_begin_frame_args() {
set_has_begin_frame_args();
if (begin_frame_args_ == NULL) {
begin_frame_args_ = new ::cc::proto::BeginFrameArgs;
}
// @@protoc_insertion_point(field_mutable:cc.proto.BeginMainFrameAndCommitState.begin_frame_args)
return begin_frame_args_;
}
inline ::cc::proto::BeginFrameArgs* BeginMainFrameAndCommitState::release_begin_frame_args() {
// @@protoc_insertion_point(field_release:cc.proto.BeginMainFrameAndCommitState.begin_frame_args)
clear_has_begin_frame_args();
::cc::proto::BeginFrameArgs* temp = begin_frame_args_;
begin_frame_args_ = NULL;
return temp;
}
inline void BeginMainFrameAndCommitState::set_allocated_begin_frame_args(::cc::proto::BeginFrameArgs* begin_frame_args) {
delete begin_frame_args_;
begin_frame_args_ = begin_frame_args;
if (begin_frame_args) {
set_has_begin_frame_args();
} else {
clear_has_begin_frame_args();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.BeginMainFrameAndCommitState.begin_frame_args)
}

// optional .cc.proto.ScrollAndScaleSet scroll_info = 3;
inline bool BeginMainFrameAndCommitState::has_scroll_info() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BeginMainFrameAndCommitState::set_has_scroll_info() {
_has_bits_[0] |= 0x00000004u;
}
inline void BeginMainFrameAndCommitState::clear_has_scroll_info() {
_has_bits_[0] &= ~0x00000004u;
}
inline void BeginMainFrameAndCommitState::clear_scroll_info() {
if (scroll_info_ != NULL) scroll_info_->::cc::proto::ScrollAndScaleSet::Clear();
clear_has_scroll_info();
}
inline const ::cc::proto::ScrollAndScaleSet& BeginMainFrameAndCommitState::scroll_info() const {
// @@protoc_insertion_point(field_get:cc.proto.BeginMainFrameAndCommitState.scroll_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return scroll_info_ != NULL ? *scroll_info_ : *default_instance().scroll_info_;
#else
return scroll_info_ != NULL ? *scroll_info_ : *default_instance_->scroll_info_;
#endif
}
inline ::cc::proto::ScrollAndScaleSet* BeginMainFrameAndCommitState::mutable_scroll_info() {
set_has_scroll_info();
if (scroll_info_ == NULL) {
scroll_info_ = new ::cc::proto::ScrollAndScaleSet;
}
// @@protoc_insertion_point(field_mutable:cc.proto.BeginMainFrameAndCommitState.scroll_info)
return scroll_info_;
}
inline ::cc::proto::ScrollAndScaleSet* BeginMainFrameAndCommitState::release_scroll_info() {
// @@protoc_insertion_point(field_release:cc.proto.BeginMainFrameAndCommitState.scroll_info)
clear_has_scroll_info();
::cc::proto::ScrollAndScaleSet* temp = scroll_info_;
scroll_info_ = NULL;
return temp;
}
inline void BeginMainFrameAndCommitState::set_allocated_scroll_info(::cc::proto::ScrollAndScaleSet* scroll_info) {
delete scroll_info_;
scroll_info_ = scroll_info;
if (scroll_info) {
set_has_scroll_info();
} else {
clear_has_scroll_info();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.BeginMainFrameAndCommitState.scroll_info)
}

// optional int64 memory_allocation_limit_bytes = 4;
inline bool BeginMainFrameAndCommitState::has_memory_allocation_limit_bytes() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BeginMainFrameAndCommitState::set_has_memory_allocation_limit_bytes() {
_has_bits_[0] |= 0x00000008u;
}
inline void BeginMainFrameAndCommitState::clear_has_memory_allocation_limit_bytes() {
_has_bits_[0] &= ~0x00000008u;
}
inline void BeginMainFrameAndCommitState::clear_memory_allocation_limit_bytes() {
memory_allocation_limit_bytes_ = GOOGLE_LONGLONG(0);
clear_has_memory_allocation_limit_bytes();
}
inline ::google::protobuf::int64 BeginMainFrameAndCommitState::memory_allocation_limit_bytes() const {
// @@protoc_insertion_point(field_get:cc.proto.BeginMainFrameAndCommitState.memory_allocation_limit_bytes)
return memory_allocation_limit_bytes_;
}
inline void BeginMainFrameAndCommitState::set_memory_allocation_limit_bytes(::google::protobuf::int64 value) {
set_has_memory_allocation_limit_bytes();
memory_allocation_limit_bytes_ = value;
// @@protoc_insertion_point(field_set:cc.proto.BeginMainFrameAndCommitState.memory_allocation_limit_bytes)
}

// optional bool evicted_ui_resources = 5;
inline bool BeginMainFrameAndCommitState::has_evicted_ui_resources() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BeginMainFrameAndCommitState::set_has_evicted_ui_resources() {
_has_bits_[0] |= 0x00000010u;
}
inline void BeginMainFrameAndCommitState::clear_has_evicted_ui_resources() {
_has_bits_[0] &= ~0x00000010u;
}
inline void BeginMainFrameAndCommitState::clear_evicted_ui_resources() {
evicted_ui_resources_ = false;
clear_has_evicted_ui_resources();
}
inline bool BeginMainFrameAndCommitState::evicted_ui_resources() const {
// @@protoc_insertion_point(field_get:cc.proto.BeginMainFrameAndCommitState.evicted_ui_resources)
return evicted_ui_resources_;
}
inline void BeginMainFrameAndCommitState::set_evicted_ui_resources(bool value) {
set_has_evicted_ui_resources();
evicted_ui_resources_ = value;
// @@protoc_insertion_point(field_set:cc.proto.BeginMainFrameAndCommitState.evicted_ui_resources)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cc::proto::BeginFrameArgs_BeginFrameArgsType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto__INCLUDED
