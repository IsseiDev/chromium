// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: recording_source.proto

#ifndef PROTOBUF_recording_5fsource_2eproto__INCLUDED
#define PROTOBUF_recording_5fsource_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "size.pb.h"
// @@protoc_insertion_point(includes)
#include "cc/proto/cc_proto_export.h"

namespace cc {
namespace proto {

// Internal implementation detail -- do not call these.
void CC_PROTO_EXPORT protobuf_AddDesc_recording_5fsource_2eproto();
void protobuf_AssignDesc_recording_5fsource_2eproto();
void protobuf_ShutdownFile_recording_5fsource_2eproto();

class RecordingSource;

// ===================================================================

class CC_PROTO_EXPORT RecordingSource : public ::google::protobuf::MessageLite {
public:
RecordingSource();
virtual ~RecordingSource();

RecordingSource(const RecordingSource& from);

inline RecordingSource& operator=(const RecordingSource& from) {
CopyFrom(from);
return *this;
}

inline const ::std::string& unknown_fields() const {
return _unknown_fields_.GetNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

inline ::std::string* mutable_unknown_fields() {
return _unknown_fields_.MutableNoArena(
&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

static const RecordingSource& default_instance();

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
// Returns the internal default instance pointer. This function can
// return NULL thus should not be used by the user. This is intended
// for Protobuf internal code. Please use default_instance() declared
// above instead.
static inline const RecordingSource* internal_default_instance() {
return default_instance_;
}
#endif

GOOGLE_ATTRIBUTE_NOINLINE void Swap(RecordingSource* other);

// implements Message ----------------------------------------------

inline RecordingSource* New() const { return New(NULL); }

RecordingSource* New(::google::protobuf::Arena* arena) const;
void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
void CopyFrom(const RecordingSource& from);
void MergeFrom(const RecordingSource& from);
void Clear();
bool IsInitialized() const;

int ByteSize() const;
bool MergePartialFromCodedStream(
::google::protobuf::io::CodedInputStream* input);
void SerializeWithCachedSizes(
::google::protobuf::io::CodedOutputStream* output) const;
void DiscardUnknownFields();
int GetCachedSize() const { return _cached_size_; }
private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(RecordingSource* other);
private:
inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
return _arena_ptr_;
}
inline ::google::protobuf::Arena* MaybeArenaPtr() const {
return _arena_ptr_;
}
public:

::std::string GetTypeName() const;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// optional .cc.proto.Size size = 1;
bool has_size() const;
void clear_size();
static const int kSizeFieldNumber = 1;
const ::cc::proto::Size& size() const;
::cc::proto::Size* mutable_size();
::cc::proto::Size* release_size();
void set_allocated_size(::cc::proto::Size* size);

// optional int64 slow_down_raster_scale_factor_for_debug = 2;
bool has_slow_down_raster_scale_factor_for_debug() const;
void clear_slow_down_raster_scale_factor_for_debug();
static const int kSlowDownRasterScaleFactorForDebugFieldNumber = 2;
::google::protobuf::int64 slow_down_raster_scale_factor_for_debug() const;
void set_slow_down_raster_scale_factor_for_debug(::google::protobuf::int64 value);

// optional bool generate_discardable_images_metadata = 3;
bool has_generate_discardable_images_metadata() const;
void clear_generate_discardable_images_metadata();
static const int kGenerateDiscardableImagesMetadataFieldNumber = 3;
bool generate_discardable_images_metadata() const;
void set_generate_discardable_images_metadata(bool value);

// optional bool requires_clear = 4;
bool has_requires_clear() const;
void clear_requires_clear();
static const int kRequiresClearFieldNumber = 4;
bool requires_clear() const;
void set_requires_clear(bool value);

// optional bool is_solid_color = 5;
bool has_is_solid_color() const;
void clear_is_solid_color();
static const int kIsSolidColorFieldNumber = 5;
bool is_solid_color() const;
void set_is_solid_color(bool value);

// optional bool clear_canvas_with_debug_color = 6;
bool has_clear_canvas_with_debug_color() const;
void clear_clear_canvas_with_debug_color();
static const int kClearCanvasWithDebugColorFieldNumber = 6;
bool clear_canvas_with_debug_color() const;
void set_clear_canvas_with_debug_color(bool value);

// optional uint64 solid_color = 7;
bool has_solid_color() const;
void clear_solid_color();
static const int kSolidColorFieldNumber = 7;
::google::protobuf::uint64 solid_color() const;
void set_solid_color(::google::protobuf::uint64 value);

// optional uint64 background_color = 8;
bool has_background_color() const;
void clear_background_color();
static const int kBackgroundColorFieldNumber = 8;
::google::protobuf::uint64 background_color() const;
void set_background_color(::google::protobuf::uint64 value);

// @@protoc_insertion_point(class_scope:cc.proto.RecordingSource)
private:
inline void set_has_size();
inline void clear_has_size();
inline void set_has_slow_down_raster_scale_factor_for_debug();
inline void clear_has_slow_down_raster_scale_factor_for_debug();
inline void set_has_generate_discardable_images_metadata();
inline void clear_has_generate_discardable_images_metadata();
inline void set_has_requires_clear();
inline void clear_has_requires_clear();
inline void set_has_is_solid_color();
inline void clear_has_is_solid_color();
inline void set_has_clear_canvas_with_debug_color();
inline void clear_has_clear_canvas_with_debug_color();
inline void set_has_solid_color();
inline void clear_has_solid_color();
inline void set_has_background_color();
inline void clear_has_background_color();

::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
::google::protobuf::Arena* _arena_ptr_;

::google::protobuf::uint32 _has_bits_[1];
mutable int _cached_size_;
::cc::proto::Size* size_;
::google::protobuf::int64 slow_down_raster_scale_factor_for_debug_;
::google::protobuf::uint64 solid_color_;
::google::protobuf::uint64 background_color_;
bool generate_discardable_images_metadata_;
bool requires_clear_;
bool is_solid_color_;
bool clear_canvas_with_debug_color_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
friend void CC_PROTO_EXPORT protobuf_AddDesc_recording_5fsource_2eproto_impl();
#else
friend void CC_PROTO_EXPORT protobuf_AddDesc_recording_5fsource_2eproto();
#endif
friend void protobuf_AssignDesc_recording_5fsource_2eproto();
friend void protobuf_ShutdownFile_recording_5fsource_2eproto();

void InitAsDefaultInstance();
static RecordingSource* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RecordingSource

// optional .cc.proto.Size size = 1;
inline bool RecordingSource::has_size() const {
return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordingSource::set_has_size() {
_has_bits_[0] |= 0x00000001u;
}
inline void RecordingSource::clear_has_size() {
_has_bits_[0] &= ~0x00000001u;
}
inline void RecordingSource::clear_size() {
if (size_ != NULL) size_->::cc::proto::Size::Clear();
clear_has_size();
}
inline const ::cc::proto::Size& RecordingSource::size() const {
// @@protoc_insertion_point(field_get:cc.proto.RecordingSource.size)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
return size_ != NULL ? *size_ : *default_instance().size_;
#else
return size_ != NULL ? *size_ : *default_instance_->size_;
#endif
}
inline ::cc::proto::Size* RecordingSource::mutable_size() {
set_has_size();
if (size_ == NULL) {
size_ = new ::cc::proto::Size;
}
// @@protoc_insertion_point(field_mutable:cc.proto.RecordingSource.size)
return size_;
}
inline ::cc::proto::Size* RecordingSource::release_size() {
// @@protoc_insertion_point(field_release:cc.proto.RecordingSource.size)
clear_has_size();
::cc::proto::Size* temp = size_;
size_ = NULL;
return temp;
}
inline void RecordingSource::set_allocated_size(::cc::proto::Size* size) {
delete size_;
size_ = size;
if (size) {
set_has_size();
} else {
clear_has_size();
}
// @@protoc_insertion_point(field_set_allocated:cc.proto.RecordingSource.size)
}

// optional int64 slow_down_raster_scale_factor_for_debug = 2;
inline bool RecordingSource::has_slow_down_raster_scale_factor_for_debug() const {
return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecordingSource::set_has_slow_down_raster_scale_factor_for_debug() {
_has_bits_[0] |= 0x00000002u;
}
inline void RecordingSource::clear_has_slow_down_raster_scale_factor_for_debug() {
_has_bits_[0] &= ~0x00000002u;
}
inline void RecordingSource::clear_slow_down_raster_scale_factor_for_debug() {
slow_down_raster_scale_factor_for_debug_ = GOOGLE_LONGLONG(0);
clear_has_slow_down_raster_scale_factor_for_debug();
}
inline ::google::protobuf::int64 RecordingSource::slow_down_raster_scale_factor_for_debug() const {
// @@protoc_insertion_point(field_get:cc.proto.RecordingSource.slow_down_raster_scale_factor_for_debug)
return slow_down_raster_scale_factor_for_debug_;
}
inline void RecordingSource::set_slow_down_raster_scale_factor_for_debug(::google::protobuf::int64 value) {
set_has_slow_down_raster_scale_factor_for_debug();
slow_down_raster_scale_factor_for_debug_ = value;
// @@protoc_insertion_point(field_set:cc.proto.RecordingSource.slow_down_raster_scale_factor_for_debug)
}

// optional bool generate_discardable_images_metadata = 3;
inline bool RecordingSource::has_generate_discardable_images_metadata() const {
return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecordingSource::set_has_generate_discardable_images_metadata() {
_has_bits_[0] |= 0x00000004u;
}
inline void RecordingSource::clear_has_generate_discardable_images_metadata() {
_has_bits_[0] &= ~0x00000004u;
}
inline void RecordingSource::clear_generate_discardable_images_metadata() {
generate_discardable_images_metadata_ = false;
clear_has_generate_discardable_images_metadata();
}
inline bool RecordingSource::generate_discardable_images_metadata() const {
// @@protoc_insertion_point(field_get:cc.proto.RecordingSource.generate_discardable_images_metadata)
return generate_discardable_images_metadata_;
}
inline void RecordingSource::set_generate_discardable_images_metadata(bool value) {
set_has_generate_discardable_images_metadata();
generate_discardable_images_metadata_ = value;
// @@protoc_insertion_point(field_set:cc.proto.RecordingSource.generate_discardable_images_metadata)
}

// optional bool requires_clear = 4;
inline bool RecordingSource::has_requires_clear() const {
return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecordingSource::set_has_requires_clear() {
_has_bits_[0] |= 0x00000008u;
}
inline void RecordingSource::clear_has_requires_clear() {
_has_bits_[0] &= ~0x00000008u;
}
inline void RecordingSource::clear_requires_clear() {
requires_clear_ = false;
clear_has_requires_clear();
}
inline bool RecordingSource::requires_clear() const {
// @@protoc_insertion_point(field_get:cc.proto.RecordingSource.requires_clear)
return requires_clear_;
}
inline void RecordingSource::set_requires_clear(bool value) {
set_has_requires_clear();
requires_clear_ = value;
// @@protoc_insertion_point(field_set:cc.proto.RecordingSource.requires_clear)
}

// optional bool is_solid_color = 5;
inline bool RecordingSource::has_is_solid_color() const {
return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecordingSource::set_has_is_solid_color() {
_has_bits_[0] |= 0x00000010u;
}
inline void RecordingSource::clear_has_is_solid_color() {
_has_bits_[0] &= ~0x00000010u;
}
inline void RecordingSource::clear_is_solid_color() {
is_solid_color_ = false;
clear_has_is_solid_color();
}
inline bool RecordingSource::is_solid_color() const {
// @@protoc_insertion_point(field_get:cc.proto.RecordingSource.is_solid_color)
return is_solid_color_;
}
inline void RecordingSource::set_is_solid_color(bool value) {
set_has_is_solid_color();
is_solid_color_ = value;
// @@protoc_insertion_point(field_set:cc.proto.RecordingSource.is_solid_color)
}

// optional bool clear_canvas_with_debug_color = 6;
inline bool RecordingSource::has_clear_canvas_with_debug_color() const {
return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RecordingSource::set_has_clear_canvas_with_debug_color() {
_has_bits_[0] |= 0x00000020u;
}
inline void RecordingSource::clear_has_clear_canvas_with_debug_color() {
_has_bits_[0] &= ~0x00000020u;
}
inline void RecordingSource::clear_clear_canvas_with_debug_color() {
clear_canvas_with_debug_color_ = false;
clear_has_clear_canvas_with_debug_color();
}
inline bool RecordingSource::clear_canvas_with_debug_color() const {
// @@protoc_insertion_point(field_get:cc.proto.RecordingSource.clear_canvas_with_debug_color)
return clear_canvas_with_debug_color_;
}
inline void RecordingSource::set_clear_canvas_with_debug_color(bool value) {
set_has_clear_canvas_with_debug_color();
clear_canvas_with_debug_color_ = value;
// @@protoc_insertion_point(field_set:cc.proto.RecordingSource.clear_canvas_with_debug_color)
}

// optional uint64 solid_color = 7;
inline bool RecordingSource::has_solid_color() const {
return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RecordingSource::set_has_solid_color() {
_has_bits_[0] |= 0x00000040u;
}
inline void RecordingSource::clear_has_solid_color() {
_has_bits_[0] &= ~0x00000040u;
}
inline void RecordingSource::clear_solid_color() {
solid_color_ = GOOGLE_ULONGLONG(0);
clear_has_solid_color();
}
inline ::google::protobuf::uint64 RecordingSource::solid_color() const {
// @@protoc_insertion_point(field_get:cc.proto.RecordingSource.solid_color)
return solid_color_;
}
inline void RecordingSource::set_solid_color(::google::protobuf::uint64 value) {
set_has_solid_color();
solid_color_ = value;
// @@protoc_insertion_point(field_set:cc.proto.RecordingSource.solid_color)
}

// optional uint64 background_color = 8;
inline bool RecordingSource::has_background_color() const {
return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RecordingSource::set_has_background_color() {
_has_bits_[0] |= 0x00000080u;
}
inline void RecordingSource::clear_has_background_color() {
_has_bits_[0] &= ~0x00000080u;
}
inline void RecordingSource::clear_background_color() {
background_color_ = GOOGLE_ULONGLONG(0);
clear_has_background_color();
}
inline ::google::protobuf::uint64 RecordingSource::background_color() const {
// @@protoc_insertion_point(field_get:cc.proto.RecordingSource.background_color)
return background_color_;
}
inline void RecordingSource::set_background_color(::google::protobuf::uint64 value) {
set_has_background_color();
background_color_ = value;
// @@protoc_insertion_point(field_set:cc.proto.RecordingSource.background_color)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_recording_5fsource_2eproto__INCLUDED
