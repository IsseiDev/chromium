// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: begin_main_frame_and_commit_state.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "begin_main_frame_and_commit_state.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace cc {
namespace proto {

void protobuf_ShutdownFile_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto() {
  delete ScrollUpdateInfo::default_instance_;
  delete ScrollAndScaleSet::default_instance_;
  delete BeginFrameArgs::default_instance_;
  delete BeginMainFrameAndCommitState::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::cc::proto::protobuf_AddDesc_vector2d_2eproto();
  ::cc::proto::protobuf_AddDesc_vector2df_2eproto();
  ScrollUpdateInfo::default_instance_ = new ScrollUpdateInfo();
  ScrollAndScaleSet::default_instance_ = new ScrollAndScaleSet();
  BeginFrameArgs::default_instance_ = new BeginFrameArgs();
  BeginMainFrameAndCommitState::default_instance_ = new BeginMainFrameAndCommitState();
  ScrollUpdateInfo::default_instance_->InitAsDefaultInstance();
  ScrollAndScaleSet::default_instance_->InitAsDefaultInstance();
  BeginFrameArgs::default_instance_->InitAsDefaultInstance();
  BeginMainFrameAndCommitState::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_once_);
void protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_once_,
                 &protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto {
  StaticDescriptorInitializer_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto() {
    protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
  }
} static_descriptor_initializer_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto_;
#endif

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForScrollUpdateInfo(
    ScrollUpdateInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScrollUpdateInfo::kLayerIdFieldNumber;
const int ScrollUpdateInfo::kScrollDeltaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScrollUpdateInfo::ScrollUpdateInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cc.proto.ScrollUpdateInfo)
}

void ScrollUpdateInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  scroll_delta_ = const_cast< ::cc::proto::Vector2d*>(
      ::cc::proto::Vector2d::internal_default_instance());
#else
  scroll_delta_ = const_cast< ::cc::proto::Vector2d*>(&::cc::proto::Vector2d::default_instance());
#endif
}

ScrollUpdateInfo::ScrollUpdateInfo(const ScrollUpdateInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cc.proto.ScrollUpdateInfo)
}

void ScrollUpdateInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  layer_id_ = GOOGLE_LONGLONG(0);
  scroll_delta_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScrollUpdateInfo::~ScrollUpdateInfo() {
  // @@protoc_insertion_point(destructor:cc.proto.ScrollUpdateInfo)
  SharedDtor();
}

void ScrollUpdateInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete scroll_delta_;
  }
}

void ScrollUpdateInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ScrollUpdateInfo& ScrollUpdateInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#endif
  return *default_instance_;
}

ScrollUpdateInfo* ScrollUpdateInfo::default_instance_ = NULL;

ScrollUpdateInfo* ScrollUpdateInfo::New(::google::protobuf::Arena* arena) const {
  ScrollUpdateInfo* n = new ScrollUpdateInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScrollUpdateInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:cc.proto.ScrollUpdateInfo)
  if (_has_bits_[0 / 32] & 3u) {
    layer_id_ = GOOGLE_LONGLONG(0);
    if (has_scroll_delta()) {
      if (scroll_delta_ != NULL) scroll_delta_->::cc::proto::Vector2d::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ScrollUpdateInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForScrollUpdateInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cc.proto.ScrollUpdateInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 layer_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &layer_id_)));
          set_has_layer_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_scroll_delta;
        break;
      }

      // optional .cc.proto.Vector2d scroll_delta = 2;
      case 2: {
        if (tag == 18) {
         parse_scroll_delta:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scroll_delta()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cc.proto.ScrollUpdateInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cc.proto.ScrollUpdateInfo)
  return false;
#undef DO_
}

void ScrollUpdateInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cc.proto.ScrollUpdateInfo)
  // optional int64 layer_id = 1;
  if (has_layer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->layer_id(), output);
  }

  // optional .cc.proto.Vector2d scroll_delta = 2;
  if (has_scroll_delta()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->scroll_delta_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cc.proto.ScrollUpdateInfo)
}

int ScrollUpdateInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cc.proto.ScrollUpdateInfo)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional int64 layer_id = 1;
    if (has_layer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->layer_id());
    }

    // optional .cc.proto.Vector2d scroll_delta = 2;
    if (has_scroll_delta()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->scroll_delta_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScrollUpdateInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ScrollUpdateInfo*>(&from));
}

void ScrollUpdateInfo::MergeFrom(const ScrollUpdateInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.ScrollUpdateInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_layer_id()) {
      set_layer_id(from.layer_id());
    }
    if (from.has_scroll_delta()) {
      mutable_scroll_delta()->::cc::proto::Vector2d::MergeFrom(from.scroll_delta());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ScrollUpdateInfo::CopyFrom(const ScrollUpdateInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.ScrollUpdateInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScrollUpdateInfo::IsInitialized() const {

  return true;
}

void ScrollUpdateInfo::Swap(ScrollUpdateInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScrollUpdateInfo::InternalSwap(ScrollUpdateInfo* other) {
  std::swap(layer_id_, other->layer_id_);
  std::swap(scroll_delta_, other->scroll_delta_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ScrollUpdateInfo::GetTypeName() const {
  return "cc.proto.ScrollUpdateInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScrollUpdateInfo

// optional int64 layer_id = 1;
bool ScrollUpdateInfo::has_layer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ScrollUpdateInfo::set_has_layer_id() {
  _has_bits_[0] |= 0x00000001u;
}
void ScrollUpdateInfo::clear_has_layer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void ScrollUpdateInfo::clear_layer_id() {
  layer_id_ = GOOGLE_LONGLONG(0);
  clear_has_layer_id();
}
 ::google::protobuf::int64 ScrollUpdateInfo::layer_id() const {
  // @@protoc_insertion_point(field_get:cc.proto.ScrollUpdateInfo.layer_id)
  return layer_id_;
}
 void ScrollUpdateInfo::set_layer_id(::google::protobuf::int64 value) {
  set_has_layer_id();
  layer_id_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.ScrollUpdateInfo.layer_id)
}

// optional .cc.proto.Vector2d scroll_delta = 2;
bool ScrollUpdateInfo::has_scroll_delta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScrollUpdateInfo::set_has_scroll_delta() {
  _has_bits_[0] |= 0x00000002u;
}
void ScrollUpdateInfo::clear_has_scroll_delta() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScrollUpdateInfo::clear_scroll_delta() {
  if (scroll_delta_ != NULL) scroll_delta_->::cc::proto::Vector2d::Clear();
  clear_has_scroll_delta();
}
const ::cc::proto::Vector2d& ScrollUpdateInfo::scroll_delta() const {
  // @@protoc_insertion_point(field_get:cc.proto.ScrollUpdateInfo.scroll_delta)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scroll_delta_ != NULL ? *scroll_delta_ : *default_instance().scroll_delta_;
#else
  return scroll_delta_ != NULL ? *scroll_delta_ : *default_instance_->scroll_delta_;
#endif
}
::cc::proto::Vector2d* ScrollUpdateInfo::mutable_scroll_delta() {
  set_has_scroll_delta();
  if (scroll_delta_ == NULL) {
    scroll_delta_ = new ::cc::proto::Vector2d;
  }
  // @@protoc_insertion_point(field_mutable:cc.proto.ScrollUpdateInfo.scroll_delta)
  return scroll_delta_;
}
::cc::proto::Vector2d* ScrollUpdateInfo::release_scroll_delta() {
  // @@protoc_insertion_point(field_release:cc.proto.ScrollUpdateInfo.scroll_delta)
  clear_has_scroll_delta();
  ::cc::proto::Vector2d* temp = scroll_delta_;
  scroll_delta_ = NULL;
  return temp;
}
void ScrollUpdateInfo::set_allocated_scroll_delta(::cc::proto::Vector2d* scroll_delta) {
  delete scroll_delta_;
  scroll_delta_ = scroll_delta;
  if (scroll_delta) {
    set_has_scroll_delta();
  } else {
    clear_has_scroll_delta();
  }
  // @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollUpdateInfo.scroll_delta)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForScrollAndScaleSet(
    ScrollAndScaleSet* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ScrollAndScaleSet::kScrollsFieldNumber;
const int ScrollAndScaleSet::kPageScaleDeltaFieldNumber;
const int ScrollAndScaleSet::kElasticOverscrollDeltaFieldNumber;
const int ScrollAndScaleSet::kTopControlsDeltaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ScrollAndScaleSet::ScrollAndScaleSet()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cc.proto.ScrollAndScaleSet)
}

void ScrollAndScaleSet::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  elastic_overscroll_delta_ = const_cast< ::cc::proto::Vector2dF*>(
      ::cc::proto::Vector2dF::internal_default_instance());
#else
  elastic_overscroll_delta_ = const_cast< ::cc::proto::Vector2dF*>(&::cc::proto::Vector2dF::default_instance());
#endif
}

ScrollAndScaleSet::ScrollAndScaleSet(const ScrollAndScaleSet& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cc.proto.ScrollAndScaleSet)
}

void ScrollAndScaleSet::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  page_scale_delta_ = 0;
  elastic_overscroll_delta_ = NULL;
  top_controls_delta_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScrollAndScaleSet::~ScrollAndScaleSet() {
  // @@protoc_insertion_point(destructor:cc.proto.ScrollAndScaleSet)
  SharedDtor();
}

void ScrollAndScaleSet::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete elastic_overscroll_delta_;
  }
}

void ScrollAndScaleSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ScrollAndScaleSet& ScrollAndScaleSet::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#endif
  return *default_instance_;
}

ScrollAndScaleSet* ScrollAndScaleSet::default_instance_ = NULL;

ScrollAndScaleSet* ScrollAndScaleSet::New(::google::protobuf::Arena* arena) const {
  ScrollAndScaleSet* n = new ScrollAndScaleSet;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ScrollAndScaleSet::Clear() {
// @@protoc_insertion_point(message_clear_start:cc.proto.ScrollAndScaleSet)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ScrollAndScaleSet, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ScrollAndScaleSet*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 14u) {
    ZR_(page_scale_delta_, top_controls_delta_);
    if (has_elastic_overscroll_delta()) {
      if (elastic_overscroll_delta_ != NULL) elastic_overscroll_delta_->::cc::proto::Vector2dF::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  scrolls_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ScrollAndScaleSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForScrollAndScaleSet, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cc.proto.ScrollAndScaleSet)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .cc.proto.ScrollUpdateInfo scrolls = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_scrolls:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_scrolls()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_scrolls;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(21)) goto parse_page_scale_delta;
        break;
      }

      // optional float page_scale_delta = 2;
      case 2: {
        if (tag == 21) {
         parse_page_scale_delta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &page_scale_delta_)));
          set_has_page_scale_delta();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_elastic_overscroll_delta;
        break;
      }

      // optional .cc.proto.Vector2dF elastic_overscroll_delta = 3;
      case 3: {
        if (tag == 26) {
         parse_elastic_overscroll_delta:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_elastic_overscroll_delta()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_top_controls_delta;
        break;
      }

      // optional float top_controls_delta = 4;
      case 4: {
        if (tag == 37) {
         parse_top_controls_delta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &top_controls_delta_)));
          set_has_top_controls_delta();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cc.proto.ScrollAndScaleSet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cc.proto.ScrollAndScaleSet)
  return false;
#undef DO_
}

void ScrollAndScaleSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cc.proto.ScrollAndScaleSet)
  // repeated .cc.proto.ScrollUpdateInfo scrolls = 1;
  for (unsigned int i = 0, n = this->scrolls_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->scrolls(i), output);
  }

  // optional float page_scale_delta = 2;
  if (has_page_scale_delta()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->page_scale_delta(), output);
  }

  // optional .cc.proto.Vector2dF elastic_overscroll_delta = 3;
  if (has_elastic_overscroll_delta()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->elastic_overscroll_delta_, output);
  }

  // optional float top_controls_delta = 4;
  if (has_top_controls_delta()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->top_controls_delta(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cc.proto.ScrollAndScaleSet)
}

int ScrollAndScaleSet::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cc.proto.ScrollAndScaleSet)
  int total_size = 0;

  if (_has_bits_[1 / 32] & 14u) {
    // optional float page_scale_delta = 2;
    if (has_page_scale_delta()) {
      total_size += 1 + 4;
    }

    // optional .cc.proto.Vector2dF elastic_overscroll_delta = 3;
    if (has_elastic_overscroll_delta()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->elastic_overscroll_delta_);
    }

    // optional float top_controls_delta = 4;
    if (has_top_controls_delta()) {
      total_size += 1 + 4;
    }

  }
  // repeated .cc.proto.ScrollUpdateInfo scrolls = 1;
  total_size += 1 * this->scrolls_size();
  for (int i = 0; i < this->scrolls_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->scrolls(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScrollAndScaleSet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ScrollAndScaleSet*>(&from));
}

void ScrollAndScaleSet::MergeFrom(const ScrollAndScaleSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.ScrollAndScaleSet)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  scrolls_.MergeFrom(from.scrolls_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_page_scale_delta()) {
      set_page_scale_delta(from.page_scale_delta());
    }
    if (from.has_elastic_overscroll_delta()) {
      mutable_elastic_overscroll_delta()->::cc::proto::Vector2dF::MergeFrom(from.elastic_overscroll_delta());
    }
    if (from.has_top_controls_delta()) {
      set_top_controls_delta(from.top_controls_delta());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ScrollAndScaleSet::CopyFrom(const ScrollAndScaleSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.ScrollAndScaleSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScrollAndScaleSet::IsInitialized() const {

  return true;
}

void ScrollAndScaleSet::Swap(ScrollAndScaleSet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ScrollAndScaleSet::InternalSwap(ScrollAndScaleSet* other) {
  scrolls_.UnsafeArenaSwap(&other->scrolls_);
  std::swap(page_scale_delta_, other->page_scale_delta_);
  std::swap(elastic_overscroll_delta_, other->elastic_overscroll_delta_);
  std::swap(top_controls_delta_, other->top_controls_delta_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ScrollAndScaleSet::GetTypeName() const {
  return "cc.proto.ScrollAndScaleSet";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ScrollAndScaleSet

// repeated .cc.proto.ScrollUpdateInfo scrolls = 1;
int ScrollAndScaleSet::scrolls_size() const {
  return scrolls_.size();
}
void ScrollAndScaleSet::clear_scrolls() {
  scrolls_.Clear();
}
const ::cc::proto::ScrollUpdateInfo& ScrollAndScaleSet::scrolls(int index) const {
  // @@protoc_insertion_point(field_get:cc.proto.ScrollAndScaleSet.scrolls)
  return scrolls_.Get(index);
}
::cc::proto::ScrollUpdateInfo* ScrollAndScaleSet::mutable_scrolls(int index) {
  // @@protoc_insertion_point(field_mutable:cc.proto.ScrollAndScaleSet.scrolls)
  return scrolls_.Mutable(index);
}
::cc::proto::ScrollUpdateInfo* ScrollAndScaleSet::add_scrolls() {
  // @@protoc_insertion_point(field_add:cc.proto.ScrollAndScaleSet.scrolls)
  return scrolls_.Add();
}
::google::protobuf::RepeatedPtrField< ::cc::proto::ScrollUpdateInfo >*
ScrollAndScaleSet::mutable_scrolls() {
  // @@protoc_insertion_point(field_mutable_list:cc.proto.ScrollAndScaleSet.scrolls)
  return &scrolls_;
}
const ::google::protobuf::RepeatedPtrField< ::cc::proto::ScrollUpdateInfo >&
ScrollAndScaleSet::scrolls() const {
  // @@protoc_insertion_point(field_list:cc.proto.ScrollAndScaleSet.scrolls)
  return scrolls_;
}

// optional float page_scale_delta = 2;
bool ScrollAndScaleSet::has_page_scale_delta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ScrollAndScaleSet::set_has_page_scale_delta() {
  _has_bits_[0] |= 0x00000002u;
}
void ScrollAndScaleSet::clear_has_page_scale_delta() {
  _has_bits_[0] &= ~0x00000002u;
}
void ScrollAndScaleSet::clear_page_scale_delta() {
  page_scale_delta_ = 0;
  clear_has_page_scale_delta();
}
 float ScrollAndScaleSet::page_scale_delta() const {
  // @@protoc_insertion_point(field_get:cc.proto.ScrollAndScaleSet.page_scale_delta)
  return page_scale_delta_;
}
 void ScrollAndScaleSet::set_page_scale_delta(float value) {
  set_has_page_scale_delta();
  page_scale_delta_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.ScrollAndScaleSet.page_scale_delta)
}

// optional .cc.proto.Vector2dF elastic_overscroll_delta = 3;
bool ScrollAndScaleSet::has_elastic_overscroll_delta() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ScrollAndScaleSet::set_has_elastic_overscroll_delta() {
  _has_bits_[0] |= 0x00000004u;
}
void ScrollAndScaleSet::clear_has_elastic_overscroll_delta() {
  _has_bits_[0] &= ~0x00000004u;
}
void ScrollAndScaleSet::clear_elastic_overscroll_delta() {
  if (elastic_overscroll_delta_ != NULL) elastic_overscroll_delta_->::cc::proto::Vector2dF::Clear();
  clear_has_elastic_overscroll_delta();
}
const ::cc::proto::Vector2dF& ScrollAndScaleSet::elastic_overscroll_delta() const {
  // @@protoc_insertion_point(field_get:cc.proto.ScrollAndScaleSet.elastic_overscroll_delta)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return elastic_overscroll_delta_ != NULL ? *elastic_overscroll_delta_ : *default_instance().elastic_overscroll_delta_;
#else
  return elastic_overscroll_delta_ != NULL ? *elastic_overscroll_delta_ : *default_instance_->elastic_overscroll_delta_;
#endif
}
::cc::proto::Vector2dF* ScrollAndScaleSet::mutable_elastic_overscroll_delta() {
  set_has_elastic_overscroll_delta();
  if (elastic_overscroll_delta_ == NULL) {
    elastic_overscroll_delta_ = new ::cc::proto::Vector2dF;
  }
  // @@protoc_insertion_point(field_mutable:cc.proto.ScrollAndScaleSet.elastic_overscroll_delta)
  return elastic_overscroll_delta_;
}
::cc::proto::Vector2dF* ScrollAndScaleSet::release_elastic_overscroll_delta() {
  // @@protoc_insertion_point(field_release:cc.proto.ScrollAndScaleSet.elastic_overscroll_delta)
  clear_has_elastic_overscroll_delta();
  ::cc::proto::Vector2dF* temp = elastic_overscroll_delta_;
  elastic_overscroll_delta_ = NULL;
  return temp;
}
void ScrollAndScaleSet::set_allocated_elastic_overscroll_delta(::cc::proto::Vector2dF* elastic_overscroll_delta) {
  delete elastic_overscroll_delta_;
  elastic_overscroll_delta_ = elastic_overscroll_delta;
  if (elastic_overscroll_delta) {
    set_has_elastic_overscroll_delta();
  } else {
    clear_has_elastic_overscroll_delta();
  }
  // @@protoc_insertion_point(field_set_allocated:cc.proto.ScrollAndScaleSet.elastic_overscroll_delta)
}

// optional float top_controls_delta = 4;
bool ScrollAndScaleSet::has_top_controls_delta() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ScrollAndScaleSet::set_has_top_controls_delta() {
  _has_bits_[0] |= 0x00000008u;
}
void ScrollAndScaleSet::clear_has_top_controls_delta() {
  _has_bits_[0] &= ~0x00000008u;
}
void ScrollAndScaleSet::clear_top_controls_delta() {
  top_controls_delta_ = 0;
  clear_has_top_controls_delta();
}
 float ScrollAndScaleSet::top_controls_delta() const {
  // @@protoc_insertion_point(field_get:cc.proto.ScrollAndScaleSet.top_controls_delta)
  return top_controls_delta_;
}
 void ScrollAndScaleSet::set_top_controls_delta(float value) {
  set_has_top_controls_delta();
  top_controls_delta_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.ScrollAndScaleSet.top_controls_delta)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForBeginFrameArgs(
    BeginFrameArgs* ptr) {
  return ptr->mutable_unknown_fields();
}

bool BeginFrameArgs_BeginFrameArgsType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 100:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::INVALID;
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::NORMAL;
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::MISSED;
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::BEGIN_FRAME_ARGS_TYPE_MAX;
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::BeginFrameArgsType_MIN;
const BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::BeginFrameArgsType_MAX;
const int BeginFrameArgs::BeginFrameArgsType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BeginFrameArgs::kFrameTimeFieldNumber;
const int BeginFrameArgs::kDeadlineFieldNumber;
const int BeginFrameArgs::kIntervalFieldNumber;
const int BeginFrameArgs::kTypeFieldNumber;
const int BeginFrameArgs::kOnCriticalPathFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BeginFrameArgs::BeginFrameArgs()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cc.proto.BeginFrameArgs)
}

void BeginFrameArgs::InitAsDefaultInstance() {
}

BeginFrameArgs::BeginFrameArgs(const BeginFrameArgs& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cc.proto.BeginFrameArgs)
}

void BeginFrameArgs::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  frame_time_ = GOOGLE_LONGLONG(0);
  deadline_ = GOOGLE_LONGLONG(0);
  interval_ = GOOGLE_LONGLONG(0);
  type_ = 1;
  on_critical_path_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BeginFrameArgs::~BeginFrameArgs() {
  // @@protoc_insertion_point(destructor:cc.proto.BeginFrameArgs)
  SharedDtor();
}

void BeginFrameArgs::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void BeginFrameArgs::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BeginFrameArgs& BeginFrameArgs::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#endif
  return *default_instance_;
}

BeginFrameArgs* BeginFrameArgs::default_instance_ = NULL;

BeginFrameArgs* BeginFrameArgs::New(::google::protobuf::Arena* arena) const {
  BeginFrameArgs* n = new BeginFrameArgs;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BeginFrameArgs::Clear() {
// @@protoc_insertion_point(message_clear_start:cc.proto.BeginFrameArgs)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(BeginFrameArgs, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<BeginFrameArgs*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(frame_time_, interval_);
    type_ = 1;
    on_critical_path_ = false;
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool BeginFrameArgs::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForBeginFrameArgs, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cc.proto.BeginFrameArgs)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 frame_time = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &frame_time_)));
          set_has_frame_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_deadline;
        break;
      }

      // optional int64 deadline = 2;
      case 2: {
        if (tag == 16) {
         parse_deadline:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &deadline_)));
          set_has_deadline();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_interval;
        break;
      }

      // optional int64 interval = 3;
      case 3: {
        if (tag == 24) {
         parse_interval:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &interval_)));
          set_has_interval();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // optional .cc.proto.BeginFrameArgs.BeginFrameArgsType type = 4;
      case 4: {
        if (tag == 32) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cc::proto::BeginFrameArgs_BeginFrameArgsType_IsValid(value)) {
            set_type(static_cast< ::cc::proto::BeginFrameArgs_BeginFrameArgsType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_on_critical_path;
        break;
      }

      // optional bool on_critical_path = 5;
      case 5: {
        if (tag == 40) {
         parse_on_critical_path:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &on_critical_path_)));
          set_has_on_critical_path();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cc.proto.BeginFrameArgs)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cc.proto.BeginFrameArgs)
  return false;
#undef DO_
}

void BeginFrameArgs::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cc.proto.BeginFrameArgs)
  // optional int64 frame_time = 1;
  if (has_frame_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->frame_time(), output);
  }

  // optional int64 deadline = 2;
  if (has_deadline()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->deadline(), output);
  }

  // optional int64 interval = 3;
  if (has_interval()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->interval(), output);
  }

  // optional .cc.proto.BeginFrameArgs.BeginFrameArgsType type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // optional bool on_critical_path = 5;
  if (has_on_critical_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->on_critical_path(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cc.proto.BeginFrameArgs)
}

int BeginFrameArgs::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cc.proto.BeginFrameArgs)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional int64 frame_time = 1;
    if (has_frame_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->frame_time());
    }

    // optional int64 deadline = 2;
    if (has_deadline()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->deadline());
    }

    // optional int64 interval = 3;
    if (has_interval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->interval());
    }

    // optional .cc.proto.BeginFrameArgs.BeginFrameArgsType type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional bool on_critical_path = 5;
    if (has_on_critical_path()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BeginFrameArgs::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BeginFrameArgs*>(&from));
}

void BeginFrameArgs::MergeFrom(const BeginFrameArgs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.BeginFrameArgs)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_frame_time()) {
      set_frame_time(from.frame_time());
    }
    if (from.has_deadline()) {
      set_deadline(from.deadline());
    }
    if (from.has_interval()) {
      set_interval(from.interval());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_on_critical_path()) {
      set_on_critical_path(from.on_critical_path());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void BeginFrameArgs::CopyFrom(const BeginFrameArgs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.BeginFrameArgs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeginFrameArgs::IsInitialized() const {

  return true;
}

void BeginFrameArgs::Swap(BeginFrameArgs* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BeginFrameArgs::InternalSwap(BeginFrameArgs* other) {
  std::swap(frame_time_, other->frame_time_);
  std::swap(deadline_, other->deadline_);
  std::swap(interval_, other->interval_);
  std::swap(type_, other->type_);
  std::swap(on_critical_path_, other->on_critical_path_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string BeginFrameArgs::GetTypeName() const {
  return "cc.proto.BeginFrameArgs";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BeginFrameArgs

// optional int64 frame_time = 1;
bool BeginFrameArgs::has_frame_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BeginFrameArgs::set_has_frame_time() {
  _has_bits_[0] |= 0x00000001u;
}
void BeginFrameArgs::clear_has_frame_time() {
  _has_bits_[0] &= ~0x00000001u;
}
void BeginFrameArgs::clear_frame_time() {
  frame_time_ = GOOGLE_LONGLONG(0);
  clear_has_frame_time();
}
 ::google::protobuf::int64 BeginFrameArgs::frame_time() const {
  // @@protoc_insertion_point(field_get:cc.proto.BeginFrameArgs.frame_time)
  return frame_time_;
}
 void BeginFrameArgs::set_frame_time(::google::protobuf::int64 value) {
  set_has_frame_time();
  frame_time_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.BeginFrameArgs.frame_time)
}

// optional int64 deadline = 2;
bool BeginFrameArgs::has_deadline() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void BeginFrameArgs::set_has_deadline() {
  _has_bits_[0] |= 0x00000002u;
}
void BeginFrameArgs::clear_has_deadline() {
  _has_bits_[0] &= ~0x00000002u;
}
void BeginFrameArgs::clear_deadline() {
  deadline_ = GOOGLE_LONGLONG(0);
  clear_has_deadline();
}
 ::google::protobuf::int64 BeginFrameArgs::deadline() const {
  // @@protoc_insertion_point(field_get:cc.proto.BeginFrameArgs.deadline)
  return deadline_;
}
 void BeginFrameArgs::set_deadline(::google::protobuf::int64 value) {
  set_has_deadline();
  deadline_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.BeginFrameArgs.deadline)
}

// optional int64 interval = 3;
bool BeginFrameArgs::has_interval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void BeginFrameArgs::set_has_interval() {
  _has_bits_[0] |= 0x00000004u;
}
void BeginFrameArgs::clear_has_interval() {
  _has_bits_[0] &= ~0x00000004u;
}
void BeginFrameArgs::clear_interval() {
  interval_ = GOOGLE_LONGLONG(0);
  clear_has_interval();
}
 ::google::protobuf::int64 BeginFrameArgs::interval() const {
  // @@protoc_insertion_point(field_get:cc.proto.BeginFrameArgs.interval)
  return interval_;
}
 void BeginFrameArgs::set_interval(::google::protobuf::int64 value) {
  set_has_interval();
  interval_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.BeginFrameArgs.interval)
}

// optional .cc.proto.BeginFrameArgs.BeginFrameArgsType type = 4;
bool BeginFrameArgs::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void BeginFrameArgs::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
void BeginFrameArgs::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void BeginFrameArgs::clear_type() {
  type_ = 1;
  clear_has_type();
}
 ::cc::proto::BeginFrameArgs_BeginFrameArgsType BeginFrameArgs::type() const {
  // @@protoc_insertion_point(field_get:cc.proto.BeginFrameArgs.type)
  return static_cast< ::cc::proto::BeginFrameArgs_BeginFrameArgsType >(type_);
}
 void BeginFrameArgs::set_type(::cc::proto::BeginFrameArgs_BeginFrameArgsType value) {
  assert(::cc::proto::BeginFrameArgs_BeginFrameArgsType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.BeginFrameArgs.type)
}

// optional bool on_critical_path = 5;
bool BeginFrameArgs::has_on_critical_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void BeginFrameArgs::set_has_on_critical_path() {
  _has_bits_[0] |= 0x00000010u;
}
void BeginFrameArgs::clear_has_on_critical_path() {
  _has_bits_[0] &= ~0x00000010u;
}
void BeginFrameArgs::clear_on_critical_path() {
  on_critical_path_ = false;
  clear_has_on_critical_path();
}
 bool BeginFrameArgs::on_critical_path() const {
  // @@protoc_insertion_point(field_get:cc.proto.BeginFrameArgs.on_critical_path)
  return on_critical_path_;
}
 void BeginFrameArgs::set_on_critical_path(bool value) {
  set_has_on_critical_path();
  on_critical_path_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.BeginFrameArgs.on_critical_path)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForBeginMainFrameAndCommitState(
    BeginMainFrameAndCommitState* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BeginMainFrameAndCommitState::kBeginFrameIdFieldNumber;
const int BeginMainFrameAndCommitState::kBeginFrameArgsFieldNumber;
const int BeginMainFrameAndCommitState::kScrollInfoFieldNumber;
const int BeginMainFrameAndCommitState::kMemoryAllocationLimitBytesFieldNumber;
const int BeginMainFrameAndCommitState::kEvictedUiResourcesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BeginMainFrameAndCommitState::BeginMainFrameAndCommitState()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cc.proto.BeginMainFrameAndCommitState)
}

void BeginMainFrameAndCommitState::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  begin_frame_args_ = const_cast< ::cc::proto::BeginFrameArgs*>(
      ::cc::proto::BeginFrameArgs::internal_default_instance());
#else
  begin_frame_args_ = const_cast< ::cc::proto::BeginFrameArgs*>(&::cc::proto::BeginFrameArgs::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  scroll_info_ = const_cast< ::cc::proto::ScrollAndScaleSet*>(
      ::cc::proto::ScrollAndScaleSet::internal_default_instance());
#else
  scroll_info_ = const_cast< ::cc::proto::ScrollAndScaleSet*>(&::cc::proto::ScrollAndScaleSet::default_instance());
#endif
}

BeginMainFrameAndCommitState::BeginMainFrameAndCommitState(const BeginMainFrameAndCommitState& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cc.proto.BeginMainFrameAndCommitState)
}

void BeginMainFrameAndCommitState::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  begin_frame_id_ = GOOGLE_LONGLONG(0);
  begin_frame_args_ = NULL;
  scroll_info_ = NULL;
  memory_allocation_limit_bytes_ = GOOGLE_LONGLONG(0);
  evicted_ui_resources_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BeginMainFrameAndCommitState::~BeginMainFrameAndCommitState() {
  // @@protoc_insertion_point(destructor:cc.proto.BeginMainFrameAndCommitState)
  SharedDtor();
}

void BeginMainFrameAndCommitState::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete begin_frame_args_;
    delete scroll_info_;
  }
}

void BeginMainFrameAndCommitState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const BeginMainFrameAndCommitState& BeginMainFrameAndCommitState::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_begin_5fmain_5fframe_5fand_5fcommit_5fstate_2eproto();
#endif
  return *default_instance_;
}

BeginMainFrameAndCommitState* BeginMainFrameAndCommitState::default_instance_ = NULL;

BeginMainFrameAndCommitState* BeginMainFrameAndCommitState::New(::google::protobuf::Arena* arena) const {
  BeginMainFrameAndCommitState* n = new BeginMainFrameAndCommitState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BeginMainFrameAndCommitState::Clear() {
// @@protoc_insertion_point(message_clear_start:cc.proto.BeginMainFrameAndCommitState)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(BeginMainFrameAndCommitState, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<BeginMainFrameAndCommitState*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(memory_allocation_limit_bytes_, evicted_ui_resources_);
    begin_frame_id_ = GOOGLE_LONGLONG(0);
    if (has_begin_frame_args()) {
      if (begin_frame_args_ != NULL) begin_frame_args_->::cc::proto::BeginFrameArgs::Clear();
    }
    if (has_scroll_info()) {
      if (scroll_info_ != NULL) scroll_info_->::cc::proto::ScrollAndScaleSet::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool BeginMainFrameAndCommitState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForBeginMainFrameAndCommitState, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cc.proto.BeginMainFrameAndCommitState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 begin_frame_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &begin_frame_id_)));
          set_has_begin_frame_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_begin_frame_args;
        break;
      }

      // optional .cc.proto.BeginFrameArgs begin_frame_args = 2;
      case 2: {
        if (tag == 18) {
         parse_begin_frame_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_begin_frame_args()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_scroll_info;
        break;
      }

      // optional .cc.proto.ScrollAndScaleSet scroll_info = 3;
      case 3: {
        if (tag == 26) {
         parse_scroll_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scroll_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_memory_allocation_limit_bytes;
        break;
      }

      // optional int64 memory_allocation_limit_bytes = 4;
      case 4: {
        if (tag == 32) {
         parse_memory_allocation_limit_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &memory_allocation_limit_bytes_)));
          set_has_memory_allocation_limit_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_evicted_ui_resources;
        break;
      }

      // optional bool evicted_ui_resources = 5;
      case 5: {
        if (tag == 40) {
         parse_evicted_ui_resources:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &evicted_ui_resources_)));
          set_has_evicted_ui_resources();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cc.proto.BeginMainFrameAndCommitState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cc.proto.BeginMainFrameAndCommitState)
  return false;
#undef DO_
}

void BeginMainFrameAndCommitState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cc.proto.BeginMainFrameAndCommitState)
  // optional int64 begin_frame_id = 1;
  if (has_begin_frame_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->begin_frame_id(), output);
  }

  // optional .cc.proto.BeginFrameArgs begin_frame_args = 2;
  if (has_begin_frame_args()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->begin_frame_args_, output);
  }

  // optional .cc.proto.ScrollAndScaleSet scroll_info = 3;
  if (has_scroll_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->scroll_info_, output);
  }

  // optional int64 memory_allocation_limit_bytes = 4;
  if (has_memory_allocation_limit_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->memory_allocation_limit_bytes(), output);
  }

  // optional bool evicted_ui_resources = 5;
  if (has_evicted_ui_resources()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->evicted_ui_resources(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cc.proto.BeginMainFrameAndCommitState)
}

int BeginMainFrameAndCommitState::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cc.proto.BeginMainFrameAndCommitState)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional int64 begin_frame_id = 1;
    if (has_begin_frame_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->begin_frame_id());
    }

    // optional .cc.proto.BeginFrameArgs begin_frame_args = 2;
    if (has_begin_frame_args()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->begin_frame_args_);
    }

    // optional .cc.proto.ScrollAndScaleSet scroll_info = 3;
    if (has_scroll_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->scroll_info_);
    }

    // optional int64 memory_allocation_limit_bytes = 4;
    if (has_memory_allocation_limit_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->memory_allocation_limit_bytes());
    }

    // optional bool evicted_ui_resources = 5;
    if (has_evicted_ui_resources()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BeginMainFrameAndCommitState::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const BeginMainFrameAndCommitState*>(&from));
}

void BeginMainFrameAndCommitState::MergeFrom(const BeginMainFrameAndCommitState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cc.proto.BeginMainFrameAndCommitState)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_begin_frame_id()) {
      set_begin_frame_id(from.begin_frame_id());
    }
    if (from.has_begin_frame_args()) {
      mutable_begin_frame_args()->::cc::proto::BeginFrameArgs::MergeFrom(from.begin_frame_args());
    }
    if (from.has_scroll_info()) {
      mutable_scroll_info()->::cc::proto::ScrollAndScaleSet::MergeFrom(from.scroll_info());
    }
    if (from.has_memory_allocation_limit_bytes()) {
      set_memory_allocation_limit_bytes(from.memory_allocation_limit_bytes());
    }
    if (from.has_evicted_ui_resources()) {
      set_evicted_ui_resources(from.evicted_ui_resources());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void BeginMainFrameAndCommitState::CopyFrom(const BeginMainFrameAndCommitState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cc.proto.BeginMainFrameAndCommitState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BeginMainFrameAndCommitState::IsInitialized() const {

  return true;
}

void BeginMainFrameAndCommitState::Swap(BeginMainFrameAndCommitState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BeginMainFrameAndCommitState::InternalSwap(BeginMainFrameAndCommitState* other) {
  std::swap(begin_frame_id_, other->begin_frame_id_);
  std::swap(begin_frame_args_, other->begin_frame_args_);
  std::swap(scroll_info_, other->scroll_info_);
  std::swap(memory_allocation_limit_bytes_, other->memory_allocation_limit_bytes_);
  std::swap(evicted_ui_resources_, other->evicted_ui_resources_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string BeginMainFrameAndCommitState::GetTypeName() const {
  return "cc.proto.BeginMainFrameAndCommitState";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BeginMainFrameAndCommitState

// optional int64 begin_frame_id = 1;
bool BeginMainFrameAndCommitState::has_begin_frame_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void BeginMainFrameAndCommitState::set_has_begin_frame_id() {
  _has_bits_[0] |= 0x00000001u;
}
void BeginMainFrameAndCommitState::clear_has_begin_frame_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void BeginMainFrameAndCommitState::clear_begin_frame_id() {
  begin_frame_id_ = GOOGLE_LONGLONG(0);
  clear_has_begin_frame_id();
}
 ::google::protobuf::int64 BeginMainFrameAndCommitState::begin_frame_id() const {
  // @@protoc_insertion_point(field_get:cc.proto.BeginMainFrameAndCommitState.begin_frame_id)
  return begin_frame_id_;
}
 void BeginMainFrameAndCommitState::set_begin_frame_id(::google::protobuf::int64 value) {
  set_has_begin_frame_id();
  begin_frame_id_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.BeginMainFrameAndCommitState.begin_frame_id)
}

// optional .cc.proto.BeginFrameArgs begin_frame_args = 2;
bool BeginMainFrameAndCommitState::has_begin_frame_args() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void BeginMainFrameAndCommitState::set_has_begin_frame_args() {
  _has_bits_[0] |= 0x00000002u;
}
void BeginMainFrameAndCommitState::clear_has_begin_frame_args() {
  _has_bits_[0] &= ~0x00000002u;
}
void BeginMainFrameAndCommitState::clear_begin_frame_args() {
  if (begin_frame_args_ != NULL) begin_frame_args_->::cc::proto::BeginFrameArgs::Clear();
  clear_has_begin_frame_args();
}
const ::cc::proto::BeginFrameArgs& BeginMainFrameAndCommitState::begin_frame_args() const {
  // @@protoc_insertion_point(field_get:cc.proto.BeginMainFrameAndCommitState.begin_frame_args)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return begin_frame_args_ != NULL ? *begin_frame_args_ : *default_instance().begin_frame_args_;
#else
  return begin_frame_args_ != NULL ? *begin_frame_args_ : *default_instance_->begin_frame_args_;
#endif
}
::cc::proto::BeginFrameArgs* BeginMainFrameAndCommitState::mutable_begin_frame_args() {
  set_has_begin_frame_args();
  if (begin_frame_args_ == NULL) {
    begin_frame_args_ = new ::cc::proto::BeginFrameArgs;
  }
  // @@protoc_insertion_point(field_mutable:cc.proto.BeginMainFrameAndCommitState.begin_frame_args)
  return begin_frame_args_;
}
::cc::proto::BeginFrameArgs* BeginMainFrameAndCommitState::release_begin_frame_args() {
  // @@protoc_insertion_point(field_release:cc.proto.BeginMainFrameAndCommitState.begin_frame_args)
  clear_has_begin_frame_args();
  ::cc::proto::BeginFrameArgs* temp = begin_frame_args_;
  begin_frame_args_ = NULL;
  return temp;
}
void BeginMainFrameAndCommitState::set_allocated_begin_frame_args(::cc::proto::BeginFrameArgs* begin_frame_args) {
  delete begin_frame_args_;
  begin_frame_args_ = begin_frame_args;
  if (begin_frame_args) {
    set_has_begin_frame_args();
  } else {
    clear_has_begin_frame_args();
  }
  // @@protoc_insertion_point(field_set_allocated:cc.proto.BeginMainFrameAndCommitState.begin_frame_args)
}

// optional .cc.proto.ScrollAndScaleSet scroll_info = 3;
bool BeginMainFrameAndCommitState::has_scroll_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void BeginMainFrameAndCommitState::set_has_scroll_info() {
  _has_bits_[0] |= 0x00000004u;
}
void BeginMainFrameAndCommitState::clear_has_scroll_info() {
  _has_bits_[0] &= ~0x00000004u;
}
void BeginMainFrameAndCommitState::clear_scroll_info() {
  if (scroll_info_ != NULL) scroll_info_->::cc::proto::ScrollAndScaleSet::Clear();
  clear_has_scroll_info();
}
const ::cc::proto::ScrollAndScaleSet& BeginMainFrameAndCommitState::scroll_info() const {
  // @@protoc_insertion_point(field_get:cc.proto.BeginMainFrameAndCommitState.scroll_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scroll_info_ != NULL ? *scroll_info_ : *default_instance().scroll_info_;
#else
  return scroll_info_ != NULL ? *scroll_info_ : *default_instance_->scroll_info_;
#endif
}
::cc::proto::ScrollAndScaleSet* BeginMainFrameAndCommitState::mutable_scroll_info() {
  set_has_scroll_info();
  if (scroll_info_ == NULL) {
    scroll_info_ = new ::cc::proto::ScrollAndScaleSet;
  }
  // @@protoc_insertion_point(field_mutable:cc.proto.BeginMainFrameAndCommitState.scroll_info)
  return scroll_info_;
}
::cc::proto::ScrollAndScaleSet* BeginMainFrameAndCommitState::release_scroll_info() {
  // @@protoc_insertion_point(field_release:cc.proto.BeginMainFrameAndCommitState.scroll_info)
  clear_has_scroll_info();
  ::cc::proto::ScrollAndScaleSet* temp = scroll_info_;
  scroll_info_ = NULL;
  return temp;
}
void BeginMainFrameAndCommitState::set_allocated_scroll_info(::cc::proto::ScrollAndScaleSet* scroll_info) {
  delete scroll_info_;
  scroll_info_ = scroll_info;
  if (scroll_info) {
    set_has_scroll_info();
  } else {
    clear_has_scroll_info();
  }
  // @@protoc_insertion_point(field_set_allocated:cc.proto.BeginMainFrameAndCommitState.scroll_info)
}

// optional int64 memory_allocation_limit_bytes = 4;
bool BeginMainFrameAndCommitState::has_memory_allocation_limit_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void BeginMainFrameAndCommitState::set_has_memory_allocation_limit_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
void BeginMainFrameAndCommitState::clear_has_memory_allocation_limit_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
void BeginMainFrameAndCommitState::clear_memory_allocation_limit_bytes() {
  memory_allocation_limit_bytes_ = GOOGLE_LONGLONG(0);
  clear_has_memory_allocation_limit_bytes();
}
 ::google::protobuf::int64 BeginMainFrameAndCommitState::memory_allocation_limit_bytes() const {
  // @@protoc_insertion_point(field_get:cc.proto.BeginMainFrameAndCommitState.memory_allocation_limit_bytes)
  return memory_allocation_limit_bytes_;
}
 void BeginMainFrameAndCommitState::set_memory_allocation_limit_bytes(::google::protobuf::int64 value) {
  set_has_memory_allocation_limit_bytes();
  memory_allocation_limit_bytes_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.BeginMainFrameAndCommitState.memory_allocation_limit_bytes)
}

// optional bool evicted_ui_resources = 5;
bool BeginMainFrameAndCommitState::has_evicted_ui_resources() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void BeginMainFrameAndCommitState::set_has_evicted_ui_resources() {
  _has_bits_[0] |= 0x00000010u;
}
void BeginMainFrameAndCommitState::clear_has_evicted_ui_resources() {
  _has_bits_[0] &= ~0x00000010u;
}
void BeginMainFrameAndCommitState::clear_evicted_ui_resources() {
  evicted_ui_resources_ = false;
  clear_has_evicted_ui_resources();
}
 bool BeginMainFrameAndCommitState::evicted_ui_resources() const {
  // @@protoc_insertion_point(field_get:cc.proto.BeginMainFrameAndCommitState.evicted_ui_resources)
  return evicted_ui_resources_;
}
 void BeginMainFrameAndCommitState::set_evicted_ui_resources(bool value) {
  set_has_evicted_ui_resources();
  evicted_ui_resources_ = value;
  // @@protoc_insertion_point(field_set:cc.proto.BeginMainFrameAndCommitState.evicted_ui_resources)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace cc

// @@protoc_insertion_point(global_scope)
