// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cryptauth_api.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "cryptauth_api.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace cryptauth {

void protobuf_ShutdownFile_cryptauth_5fapi_2eproto() {
  delete DeviceClassifier::default_instance_;
  delete ExternalDeviceInfo::default_instance_;
  delete FindEligibleForPromotionRequest::default_instance_;
  delete FindEligibleForPromotionResponse::default_instance_;
  delete FindEligibleUnlockDevicesRequest::default_instance_;
  delete FindEligibleUnlockDevicesResponse::default_instance_;
  delete FinishEnrollmentRequest::default_instance_;
  delete FinishEnrollmentResponse::default_instance_;
  delete GcmDeviceInfo::default_instance_;
  delete GcmMetadata::default_instance_;
  delete GetMyDevicesRequest::default_instance_;
  delete GetMyDevicesResponse::default_instance_;
  delete IneligibleDevice::default_instance_;
  delete SendDeviceSyncTickleRequest::default_instance_;
  delete SendDeviceSyncTickleResponse::default_instance_;
  delete SetupEnrollmentInfo::default_instance_;
  delete SetupEnrollmentRequest::default_instance_;
  delete SetupEnrollmentResponse::default_instance_;
  delete ToggleEasyUnlockRequest::default_instance_;
  delete ToggleEasyUnlockResponse::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_cryptauth_5fapi_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_cryptauth_5fapi_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  DeviceClassifier::default_instance_ = new DeviceClassifier();
  ExternalDeviceInfo::default_instance_ = new ExternalDeviceInfo();
  FindEligibleForPromotionRequest::default_instance_ = new FindEligibleForPromotionRequest();
  FindEligibleForPromotionResponse::default_instance_ = new FindEligibleForPromotionResponse();
  FindEligibleUnlockDevicesRequest::default_instance_ = new FindEligibleUnlockDevicesRequest();
  FindEligibleUnlockDevicesResponse::default_instance_ = new FindEligibleUnlockDevicesResponse();
  FinishEnrollmentRequest::default_instance_ = new FinishEnrollmentRequest();
  FinishEnrollmentResponse::default_instance_ = new FinishEnrollmentResponse();
  GcmDeviceInfo::default_instance_ = new GcmDeviceInfo();
  GcmMetadata::default_instance_ = new GcmMetadata();
  GetMyDevicesRequest::default_instance_ = new GetMyDevicesRequest();
  GetMyDevicesResponse::default_instance_ = new GetMyDevicesResponse();
  IneligibleDevice::default_instance_ = new IneligibleDevice();
  SendDeviceSyncTickleRequest::default_instance_ = new SendDeviceSyncTickleRequest();
  SendDeviceSyncTickleResponse::default_instance_ = new SendDeviceSyncTickleResponse();
  SetupEnrollmentInfo::default_instance_ = new SetupEnrollmentInfo();
  SetupEnrollmentRequest::default_instance_ = new SetupEnrollmentRequest();
  SetupEnrollmentResponse::default_instance_ = new SetupEnrollmentResponse();
  ToggleEasyUnlockRequest::default_instance_ = new ToggleEasyUnlockRequest();
  ToggleEasyUnlockResponse::default_instance_ = new ToggleEasyUnlockResponse();
  DeviceClassifier::default_instance_->InitAsDefaultInstance();
  ExternalDeviceInfo::default_instance_->InitAsDefaultInstance();
  FindEligibleForPromotionRequest::default_instance_->InitAsDefaultInstance();
  FindEligibleForPromotionResponse::default_instance_->InitAsDefaultInstance();
  FindEligibleUnlockDevicesRequest::default_instance_->InitAsDefaultInstance();
  FindEligibleUnlockDevicesResponse::default_instance_->InitAsDefaultInstance();
  FinishEnrollmentRequest::default_instance_->InitAsDefaultInstance();
  FinishEnrollmentResponse::default_instance_->InitAsDefaultInstance();
  GcmDeviceInfo::default_instance_->InitAsDefaultInstance();
  GcmMetadata::default_instance_->InitAsDefaultInstance();
  GetMyDevicesRequest::default_instance_->InitAsDefaultInstance();
  GetMyDevicesResponse::default_instance_->InitAsDefaultInstance();
  IneligibleDevice::default_instance_->InitAsDefaultInstance();
  SendDeviceSyncTickleRequest::default_instance_->InitAsDefaultInstance();
  SendDeviceSyncTickleResponse::default_instance_->InitAsDefaultInstance();
  SetupEnrollmentInfo::default_instance_->InitAsDefaultInstance();
  SetupEnrollmentRequest::default_instance_->InitAsDefaultInstance();
  SetupEnrollmentResponse::default_instance_->InitAsDefaultInstance();
  ToggleEasyUnlockRequest::default_instance_->InitAsDefaultInstance();
  ToggleEasyUnlockResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_cryptauth_5fapi_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_cryptauth_5fapi_2eproto_once_);
void protobuf_AddDesc_cryptauth_5fapi_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_cryptauth_5fapi_2eproto_once_,
                 &protobuf_AddDesc_cryptauth_5fapi_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_cryptauth_5fapi_2eproto {
  StaticDescriptorInitializer_cryptauth_5fapi_2eproto() {
    protobuf_AddDesc_cryptauth_5fapi_2eproto();
  }
} static_descriptor_initializer_cryptauth_5fapi_2eproto_;
#endif
bool DeviceType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

bool InvocationReason_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

bool MessageType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      return true;
    default:
      return false;
  }
}

bool RegistrationTickleType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForDeviceClassifier(
    DeviceClassifier* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeviceClassifier::kDeviceOsVersionCodeFieldNumber;
const int DeviceClassifier::kDeviceSoftwareVersionCodeFieldNumber;
const int DeviceClassifier::kDeviceSoftwarePackageFieldNumber;
const int DeviceClassifier::kDeviceTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeviceClassifier::DeviceClassifier()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.DeviceClassifier)
}

void DeviceClassifier::InitAsDefaultInstance() {
}

DeviceClassifier::DeviceClassifier(const DeviceClassifier& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.DeviceClassifier)
}

void DeviceClassifier::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_os_version_code_ = GOOGLE_LONGLONG(0);
  device_software_version_code_ = GOOGLE_LONGLONG(0);
  device_software_package_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceClassifier::~DeviceClassifier() {
  // @@protoc_insertion_point(destructor:cryptauth.DeviceClassifier)
  SharedDtor();
}

void DeviceClassifier::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_software_package_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DeviceClassifier::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceClassifier& DeviceClassifier::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

DeviceClassifier* DeviceClassifier::default_instance_ = NULL;

DeviceClassifier* DeviceClassifier::New(::google::protobuf::Arena* arena) const {
  DeviceClassifier* n = new DeviceClassifier;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeviceClassifier::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.DeviceClassifier)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(DeviceClassifier, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DeviceClassifier*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(device_os_version_code_, device_software_version_code_);
    if (has_device_software_package()) {
      device_software_package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    device_type_ = 0;
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DeviceClassifier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDeviceClassifier, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.DeviceClassifier)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 device_os_version_code = 14;
      case 14: {
        if (tag == 112) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &device_os_version_code_)));
          set_has_device_os_version_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_device_software_version_code;
        break;
      }

      // optional int64 device_software_version_code = 18;
      case 18: {
        if (tag == 144) {
         parse_device_software_version_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &device_software_version_code_)));
          set_has_device_software_version_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_device_software_package;
        break;
      }

      // optional string device_software_package = 19;
      case 19: {
        if (tag == 154) {
         parse_device_software_package:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_software_package()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(256)) goto parse_device_type;
        break;
      }

      // optional .cryptauth.DeviceType device_type = 32 [default = UNKNOWN];
      case 32: {
        if (tag == 256) {
         parse_device_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cryptauth::DeviceType_IsValid(value)) {
            set_device_type(static_cast< ::cryptauth::DeviceType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(256);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.DeviceClassifier)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.DeviceClassifier)
  return false;
#undef DO_
}

void DeviceClassifier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.DeviceClassifier)
  // optional int64 device_os_version_code = 14;
  if (has_device_os_version_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(14, this->device_os_version_code(), output);
  }

  // optional int64 device_software_version_code = 18;
  if (has_device_software_version_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(18, this->device_software_version_code(), output);
  }

  // optional string device_software_package = 19;
  if (has_device_software_package()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      19, this->device_software_package(), output);
  }

  // optional .cryptauth.DeviceType device_type = 32 [default = UNKNOWN];
  if (has_device_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      32, this->device_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.DeviceClassifier)
}

int DeviceClassifier::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.DeviceClassifier)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional int64 device_os_version_code = 14;
    if (has_device_os_version_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->device_os_version_code());
    }

    // optional int64 device_software_version_code = 18;
    if (has_device_software_version_code()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->device_software_version_code());
    }

    // optional string device_software_package = 19;
    if (has_device_software_package()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_software_package());
    }

    // optional .cryptauth.DeviceType device_type = 32 [default = UNKNOWN];
    if (has_device_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->device_type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceClassifier::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DeviceClassifier*>(&from));
}

void DeviceClassifier::MergeFrom(const DeviceClassifier& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.DeviceClassifier)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_device_os_version_code()) {
      set_device_os_version_code(from.device_os_version_code());
    }
    if (from.has_device_software_version_code()) {
      set_device_software_version_code(from.device_software_version_code());
    }
    if (from.has_device_software_package()) {
      set_has_device_software_package();
      device_software_package_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_software_package_);
    }
    if (from.has_device_type()) {
      set_device_type(from.device_type());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DeviceClassifier::CopyFrom(const DeviceClassifier& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.DeviceClassifier)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceClassifier::IsInitialized() const {

  return true;
}

void DeviceClassifier::Swap(DeviceClassifier* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeviceClassifier::InternalSwap(DeviceClassifier* other) {
  std::swap(device_os_version_code_, other->device_os_version_code_);
  std::swap(device_software_version_code_, other->device_software_version_code_);
  device_software_package_.Swap(&other->device_software_package_);
  std::swap(device_type_, other->device_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DeviceClassifier::GetTypeName() const {
  return "cryptauth.DeviceClassifier";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeviceClassifier

// optional int64 device_os_version_code = 14;
bool DeviceClassifier::has_device_os_version_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeviceClassifier::set_has_device_os_version_code() {
  _has_bits_[0] |= 0x00000001u;
}
void DeviceClassifier::clear_has_device_os_version_code() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeviceClassifier::clear_device_os_version_code() {
  device_os_version_code_ = GOOGLE_LONGLONG(0);
  clear_has_device_os_version_code();
}
 ::google::protobuf::int64 DeviceClassifier::device_os_version_code() const {
  // @@protoc_insertion_point(field_get:cryptauth.DeviceClassifier.device_os_version_code)
  return device_os_version_code_;
}
 void DeviceClassifier::set_device_os_version_code(::google::protobuf::int64 value) {
  set_has_device_os_version_code();
  device_os_version_code_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.DeviceClassifier.device_os_version_code)
}

// optional int64 device_software_version_code = 18;
bool DeviceClassifier::has_device_software_version_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DeviceClassifier::set_has_device_software_version_code() {
  _has_bits_[0] |= 0x00000002u;
}
void DeviceClassifier::clear_has_device_software_version_code() {
  _has_bits_[0] &= ~0x00000002u;
}
void DeviceClassifier::clear_device_software_version_code() {
  device_software_version_code_ = GOOGLE_LONGLONG(0);
  clear_has_device_software_version_code();
}
 ::google::protobuf::int64 DeviceClassifier::device_software_version_code() const {
  // @@protoc_insertion_point(field_get:cryptauth.DeviceClassifier.device_software_version_code)
  return device_software_version_code_;
}
 void DeviceClassifier::set_device_software_version_code(::google::protobuf::int64 value) {
  set_has_device_software_version_code();
  device_software_version_code_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.DeviceClassifier.device_software_version_code)
}

// optional string device_software_package = 19;
bool DeviceClassifier::has_device_software_package() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DeviceClassifier::set_has_device_software_package() {
  _has_bits_[0] |= 0x00000004u;
}
void DeviceClassifier::clear_has_device_software_package() {
  _has_bits_[0] &= ~0x00000004u;
}
void DeviceClassifier::clear_device_software_package() {
  device_software_package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_software_package();
}
 const ::std::string& DeviceClassifier::device_software_package() const {
  // @@protoc_insertion_point(field_get:cryptauth.DeviceClassifier.device_software_package)
  return device_software_package_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceClassifier::set_device_software_package(const ::std::string& value) {
  set_has_device_software_package();
  device_software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.DeviceClassifier.device_software_package)
}
 void DeviceClassifier::set_device_software_package(const char* value) {
  set_has_device_software_package();
  device_software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.DeviceClassifier.device_software_package)
}
 void DeviceClassifier::set_device_software_package(const char* value, size_t size) {
  set_has_device_software_package();
  device_software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.DeviceClassifier.device_software_package)
}
 ::std::string* DeviceClassifier::mutable_device_software_package() {
  set_has_device_software_package();
  // @@protoc_insertion_point(field_mutable:cryptauth.DeviceClassifier.device_software_package)
  return device_software_package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DeviceClassifier::release_device_software_package() {
  // @@protoc_insertion_point(field_release:cryptauth.DeviceClassifier.device_software_package)
  clear_has_device_software_package();
  return device_software_package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceClassifier::set_allocated_device_software_package(::std::string* device_software_package) {
  if (device_software_package != NULL) {
    set_has_device_software_package();
  } else {
    clear_has_device_software_package();
  }
  device_software_package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_software_package);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.DeviceClassifier.device_software_package)
}

// optional .cryptauth.DeviceType device_type = 32 [default = UNKNOWN];
bool DeviceClassifier::has_device_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DeviceClassifier::set_has_device_type() {
  _has_bits_[0] |= 0x00000008u;
}
void DeviceClassifier::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void DeviceClassifier::clear_device_type() {
  device_type_ = 0;
  clear_has_device_type();
}
 ::cryptauth::DeviceType DeviceClassifier::device_type() const {
  // @@protoc_insertion_point(field_get:cryptauth.DeviceClassifier.device_type)
  return static_cast< ::cryptauth::DeviceType >(device_type_);
}
 void DeviceClassifier::set_device_type(::cryptauth::DeviceType value) {
  assert(::cryptauth::DeviceType_IsValid(value));
  set_has_device_type();
  device_type_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.DeviceClassifier.device_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForExternalDeviceInfo(
    ExternalDeviceInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ExternalDeviceInfo::kPublicKeyFieldNumber;
const int ExternalDeviceInfo::kFriendlyDeviceNameFieldNumber;
const int ExternalDeviceInfo::kBluetoothAddressFieldNumber;
const int ExternalDeviceInfo::kUnlockKeyFieldNumber;
const int ExternalDeviceInfo::kUnlockableFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ExternalDeviceInfo::ExternalDeviceInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.ExternalDeviceInfo)
}

void ExternalDeviceInfo::InitAsDefaultInstance() {
}

ExternalDeviceInfo::ExternalDeviceInfo(const ExternalDeviceInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.ExternalDeviceInfo)
}

void ExternalDeviceInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  friendly_device_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bluetooth_address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  unlock_key_ = false;
  unlockable_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExternalDeviceInfo::~ExternalDeviceInfo() {
  // @@protoc_insertion_point(destructor:cryptauth.ExternalDeviceInfo)
  SharedDtor();
}

void ExternalDeviceInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  friendly_device_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bluetooth_address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ExternalDeviceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ExternalDeviceInfo& ExternalDeviceInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

ExternalDeviceInfo* ExternalDeviceInfo::default_instance_ = NULL;

ExternalDeviceInfo* ExternalDeviceInfo::New(::google::protobuf::Arena* arena) const {
  ExternalDeviceInfo* n = new ExternalDeviceInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ExternalDeviceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.ExternalDeviceInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ExternalDeviceInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ExternalDeviceInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(unlock_key_, unlockable_);
    if (has_public_key()) {
      public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_friendly_device_name()) {
      friendly_device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_bluetooth_address()) {
      bluetooth_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ExternalDeviceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForExternalDeviceInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.ExternalDeviceInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes public_key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_friendly_device_name;
        break;
      }

      // optional string friendly_device_name = 2;
      case 2: {
        if (tag == 18) {
         parse_friendly_device_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_friendly_device_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_bluetooth_address;
        break;
      }

      // optional string bluetooth_address = 3;
      case 3: {
        if (tag == 26) {
         parse_bluetooth_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bluetooth_address()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_unlock_key;
        break;
      }

      // optional bool unlock_key = 4;
      case 4: {
        if (tag == 32) {
         parse_unlock_key:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &unlock_key_)));
          set_has_unlock_key();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_unlockable;
        break;
      }

      // optional bool unlockable = 5;
      case 5: {
        if (tag == 40) {
         parse_unlockable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &unlockable_)));
          set_has_unlockable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.ExternalDeviceInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.ExternalDeviceInfo)
  return false;
#undef DO_
}

void ExternalDeviceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.ExternalDeviceInfo)
  // optional bytes public_key = 1;
  if (has_public_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->public_key(), output);
  }

  // optional string friendly_device_name = 2;
  if (has_friendly_device_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->friendly_device_name(), output);
  }

  // optional string bluetooth_address = 3;
  if (has_bluetooth_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->bluetooth_address(), output);
  }

  // optional bool unlock_key = 4;
  if (has_unlock_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->unlock_key(), output);
  }

  // optional bool unlockable = 5;
  if (has_unlockable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->unlockable(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.ExternalDeviceInfo)
}

int ExternalDeviceInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.ExternalDeviceInfo)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional bytes public_key = 1;
    if (has_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_key());
    }

    // optional string friendly_device_name = 2;
    if (has_friendly_device_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->friendly_device_name());
    }

    // optional string bluetooth_address = 3;
    if (has_bluetooth_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bluetooth_address());
    }

    // optional bool unlock_key = 4;
    if (has_unlock_key()) {
      total_size += 1 + 1;
    }

    // optional bool unlockable = 5;
    if (has_unlockable()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExternalDeviceInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ExternalDeviceInfo*>(&from));
}

void ExternalDeviceInfo::MergeFrom(const ExternalDeviceInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.ExternalDeviceInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_public_key()) {
      set_has_public_key();
      public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
    }
    if (from.has_friendly_device_name()) {
      set_has_friendly_device_name();
      friendly_device_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.friendly_device_name_);
    }
    if (from.has_bluetooth_address()) {
      set_has_bluetooth_address();
      bluetooth_address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bluetooth_address_);
    }
    if (from.has_unlock_key()) {
      set_unlock_key(from.unlock_key());
    }
    if (from.has_unlockable()) {
      set_unlockable(from.unlockable());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ExternalDeviceInfo::CopyFrom(const ExternalDeviceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.ExternalDeviceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExternalDeviceInfo::IsInitialized() const {

  return true;
}

void ExternalDeviceInfo::Swap(ExternalDeviceInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ExternalDeviceInfo::InternalSwap(ExternalDeviceInfo* other) {
  public_key_.Swap(&other->public_key_);
  friendly_device_name_.Swap(&other->friendly_device_name_);
  bluetooth_address_.Swap(&other->bluetooth_address_);
  std::swap(unlock_key_, other->unlock_key_);
  std::swap(unlockable_, other->unlockable_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ExternalDeviceInfo::GetTypeName() const {
  return "cryptauth.ExternalDeviceInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ExternalDeviceInfo

// optional bytes public_key = 1;
bool ExternalDeviceInfo::has_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ExternalDeviceInfo::set_has_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
void ExternalDeviceInfo::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void ExternalDeviceInfo::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
 const ::std::string& ExternalDeviceInfo::public_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.ExternalDeviceInfo.public_key)
  return public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExternalDeviceInfo::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.ExternalDeviceInfo.public_key)
}
 void ExternalDeviceInfo::set_public_key(const char* value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.ExternalDeviceInfo.public_key)
}
 void ExternalDeviceInfo::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.ExternalDeviceInfo.public_key)
}
 ::std::string* ExternalDeviceInfo::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:cryptauth.ExternalDeviceInfo.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ExternalDeviceInfo::release_public_key() {
  // @@protoc_insertion_point(field_release:cryptauth.ExternalDeviceInfo.public_key)
  clear_has_public_key();
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExternalDeviceInfo::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.ExternalDeviceInfo.public_key)
}

// optional string friendly_device_name = 2;
bool ExternalDeviceInfo::has_friendly_device_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ExternalDeviceInfo::set_has_friendly_device_name() {
  _has_bits_[0] |= 0x00000002u;
}
void ExternalDeviceInfo::clear_has_friendly_device_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void ExternalDeviceInfo::clear_friendly_device_name() {
  friendly_device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_friendly_device_name();
}
 const ::std::string& ExternalDeviceInfo::friendly_device_name() const {
  // @@protoc_insertion_point(field_get:cryptauth.ExternalDeviceInfo.friendly_device_name)
  return friendly_device_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExternalDeviceInfo::set_friendly_device_name(const ::std::string& value) {
  set_has_friendly_device_name();
  friendly_device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.ExternalDeviceInfo.friendly_device_name)
}
 void ExternalDeviceInfo::set_friendly_device_name(const char* value) {
  set_has_friendly_device_name();
  friendly_device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.ExternalDeviceInfo.friendly_device_name)
}
 void ExternalDeviceInfo::set_friendly_device_name(const char* value, size_t size) {
  set_has_friendly_device_name();
  friendly_device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.ExternalDeviceInfo.friendly_device_name)
}
 ::std::string* ExternalDeviceInfo::mutable_friendly_device_name() {
  set_has_friendly_device_name();
  // @@protoc_insertion_point(field_mutable:cryptauth.ExternalDeviceInfo.friendly_device_name)
  return friendly_device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ExternalDeviceInfo::release_friendly_device_name() {
  // @@protoc_insertion_point(field_release:cryptauth.ExternalDeviceInfo.friendly_device_name)
  clear_has_friendly_device_name();
  return friendly_device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExternalDeviceInfo::set_allocated_friendly_device_name(::std::string* friendly_device_name) {
  if (friendly_device_name != NULL) {
    set_has_friendly_device_name();
  } else {
    clear_has_friendly_device_name();
  }
  friendly_device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), friendly_device_name);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.ExternalDeviceInfo.friendly_device_name)
}

// optional string bluetooth_address = 3;
bool ExternalDeviceInfo::has_bluetooth_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ExternalDeviceInfo::set_has_bluetooth_address() {
  _has_bits_[0] |= 0x00000004u;
}
void ExternalDeviceInfo::clear_has_bluetooth_address() {
  _has_bits_[0] &= ~0x00000004u;
}
void ExternalDeviceInfo::clear_bluetooth_address() {
  bluetooth_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bluetooth_address();
}
 const ::std::string& ExternalDeviceInfo::bluetooth_address() const {
  // @@protoc_insertion_point(field_get:cryptauth.ExternalDeviceInfo.bluetooth_address)
  return bluetooth_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExternalDeviceInfo::set_bluetooth_address(const ::std::string& value) {
  set_has_bluetooth_address();
  bluetooth_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.ExternalDeviceInfo.bluetooth_address)
}
 void ExternalDeviceInfo::set_bluetooth_address(const char* value) {
  set_has_bluetooth_address();
  bluetooth_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.ExternalDeviceInfo.bluetooth_address)
}
 void ExternalDeviceInfo::set_bluetooth_address(const char* value, size_t size) {
  set_has_bluetooth_address();
  bluetooth_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.ExternalDeviceInfo.bluetooth_address)
}
 ::std::string* ExternalDeviceInfo::mutable_bluetooth_address() {
  set_has_bluetooth_address();
  // @@protoc_insertion_point(field_mutable:cryptauth.ExternalDeviceInfo.bluetooth_address)
  return bluetooth_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ExternalDeviceInfo::release_bluetooth_address() {
  // @@protoc_insertion_point(field_release:cryptauth.ExternalDeviceInfo.bluetooth_address)
  clear_has_bluetooth_address();
  return bluetooth_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExternalDeviceInfo::set_allocated_bluetooth_address(::std::string* bluetooth_address) {
  if (bluetooth_address != NULL) {
    set_has_bluetooth_address();
  } else {
    clear_has_bluetooth_address();
  }
  bluetooth_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bluetooth_address);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.ExternalDeviceInfo.bluetooth_address)
}

// optional bool unlock_key = 4;
bool ExternalDeviceInfo::has_unlock_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ExternalDeviceInfo::set_has_unlock_key() {
  _has_bits_[0] |= 0x00000008u;
}
void ExternalDeviceInfo::clear_has_unlock_key() {
  _has_bits_[0] &= ~0x00000008u;
}
void ExternalDeviceInfo::clear_unlock_key() {
  unlock_key_ = false;
  clear_has_unlock_key();
}
 bool ExternalDeviceInfo::unlock_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.ExternalDeviceInfo.unlock_key)
  return unlock_key_;
}
 void ExternalDeviceInfo::set_unlock_key(bool value) {
  set_has_unlock_key();
  unlock_key_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.ExternalDeviceInfo.unlock_key)
}

// optional bool unlockable = 5;
bool ExternalDeviceInfo::has_unlockable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ExternalDeviceInfo::set_has_unlockable() {
  _has_bits_[0] |= 0x00000010u;
}
void ExternalDeviceInfo::clear_has_unlockable() {
  _has_bits_[0] &= ~0x00000010u;
}
void ExternalDeviceInfo::clear_unlockable() {
  unlockable_ = false;
  clear_has_unlockable();
}
 bool ExternalDeviceInfo::unlockable() const {
  // @@protoc_insertion_point(field_get:cryptauth.ExternalDeviceInfo.unlockable)
  return unlockable_;
}
 void ExternalDeviceInfo::set_unlockable(bool value) {
  set_has_unlockable();
  unlockable_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.ExternalDeviceInfo.unlockable)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFindEligibleForPromotionRequest(
    FindEligibleForPromotionRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FindEligibleForPromotionRequest::kPromoterPublicKeyFieldNumber;
const int FindEligibleForPromotionRequest::kDeviceClassifierFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FindEligibleForPromotionRequest::FindEligibleForPromotionRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.FindEligibleForPromotionRequest)
}

void FindEligibleForPromotionRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(
      ::cryptauth::DeviceClassifier::internal_default_instance());
#else
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(&::cryptauth::DeviceClassifier::default_instance());
#endif
}

FindEligibleForPromotionRequest::FindEligibleForPromotionRequest(const FindEligibleForPromotionRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.FindEligibleForPromotionRequest)
}

void FindEligibleForPromotionRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  promoter_public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_classifier_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FindEligibleForPromotionRequest::~FindEligibleForPromotionRequest() {
  // @@protoc_insertion_point(destructor:cryptauth.FindEligibleForPromotionRequest)
  SharedDtor();
}

void FindEligibleForPromotionRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  promoter_public_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete device_classifier_;
  }
}

void FindEligibleForPromotionRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindEligibleForPromotionRequest& FindEligibleForPromotionRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

FindEligibleForPromotionRequest* FindEligibleForPromotionRequest::default_instance_ = NULL;

FindEligibleForPromotionRequest* FindEligibleForPromotionRequest::New(::google::protobuf::Arena* arena) const {
  FindEligibleForPromotionRequest* n = new FindEligibleForPromotionRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FindEligibleForPromotionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.FindEligibleForPromotionRequest)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_promoter_public_key()) {
      promoter_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_device_classifier()) {
      if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FindEligibleForPromotionRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFindEligibleForPromotionRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.FindEligibleForPromotionRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes promoter_public_key = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_promoter_public_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_device_classifier;
        break;
      }

      // optional .cryptauth.DeviceClassifier device_classifier = 3;
      case 3: {
        if (tag == 26) {
         parse_device_classifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_device_classifier()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.FindEligibleForPromotionRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.FindEligibleForPromotionRequest)
  return false;
#undef DO_
}

void FindEligibleForPromotionRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.FindEligibleForPromotionRequest)
  // optional bytes promoter_public_key = 2;
  if (has_promoter_public_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->promoter_public_key(), output);
  }

  // optional .cryptauth.DeviceClassifier device_classifier = 3;
  if (has_device_classifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->device_classifier_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.FindEligibleForPromotionRequest)
}

int FindEligibleForPromotionRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.FindEligibleForPromotionRequest)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes promoter_public_key = 2;
    if (has_promoter_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->promoter_public_key());
    }

    // optional .cryptauth.DeviceClassifier device_classifier = 3;
    if (has_device_classifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->device_classifier_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FindEligibleForPromotionRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FindEligibleForPromotionRequest*>(&from));
}

void FindEligibleForPromotionRequest::MergeFrom(const FindEligibleForPromotionRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.FindEligibleForPromotionRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_promoter_public_key()) {
      set_has_promoter_public_key();
      promoter_public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.promoter_public_key_);
    }
    if (from.has_device_classifier()) {
      mutable_device_classifier()->::cryptauth::DeviceClassifier::MergeFrom(from.device_classifier());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FindEligibleForPromotionRequest::CopyFrom(const FindEligibleForPromotionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.FindEligibleForPromotionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindEligibleForPromotionRequest::IsInitialized() const {

  return true;
}

void FindEligibleForPromotionRequest::Swap(FindEligibleForPromotionRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FindEligibleForPromotionRequest::InternalSwap(FindEligibleForPromotionRequest* other) {
  promoter_public_key_.Swap(&other->promoter_public_key_);
  std::swap(device_classifier_, other->device_classifier_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FindEligibleForPromotionRequest::GetTypeName() const {
  return "cryptauth.FindEligibleForPromotionRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FindEligibleForPromotionRequest

// optional bytes promoter_public_key = 2;
bool FindEligibleForPromotionRequest::has_promoter_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FindEligibleForPromotionRequest::set_has_promoter_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
void FindEligibleForPromotionRequest::clear_has_promoter_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void FindEligibleForPromotionRequest::clear_promoter_public_key() {
  promoter_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_promoter_public_key();
}
 const ::std::string& FindEligibleForPromotionRequest::promoter_public_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
  return promoter_public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FindEligibleForPromotionRequest::set_promoter_public_key(const ::std::string& value) {
  set_has_promoter_public_key();
  promoter_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
}
 void FindEligibleForPromotionRequest::set_promoter_public_key(const char* value) {
  set_has_promoter_public_key();
  promoter_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
}
 void FindEligibleForPromotionRequest::set_promoter_public_key(const void* value, size_t size) {
  set_has_promoter_public_key();
  promoter_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
}
 ::std::string* FindEligibleForPromotionRequest::mutable_promoter_public_key() {
  set_has_promoter_public_key();
  // @@protoc_insertion_point(field_mutable:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
  return promoter_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FindEligibleForPromotionRequest::release_promoter_public_key() {
  // @@protoc_insertion_point(field_release:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
  clear_has_promoter_public_key();
  return promoter_public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FindEligibleForPromotionRequest::set_allocated_promoter_public_key(::std::string* promoter_public_key) {
  if (promoter_public_key != NULL) {
    set_has_promoter_public_key();
  } else {
    clear_has_promoter_public_key();
  }
  promoter_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), promoter_public_key);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
}

// optional .cryptauth.DeviceClassifier device_classifier = 3;
bool FindEligibleForPromotionRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FindEligibleForPromotionRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000002u;
}
void FindEligibleForPromotionRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000002u;
}
void FindEligibleForPromotionRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
const ::cryptauth::DeviceClassifier& FindEligibleForPromotionRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleForPromotionRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
::cryptauth::DeviceClassifier* FindEligibleForPromotionRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.FindEligibleForPromotionRequest.device_classifier)
  return device_classifier_;
}
::cryptauth::DeviceClassifier* FindEligibleForPromotionRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.FindEligibleForPromotionRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
void FindEligibleForPromotionRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FindEligibleForPromotionRequest.device_classifier)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFindEligibleForPromotionResponse(
    FindEligibleForPromotionResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FindEligibleForPromotionResponse::kMayShowPromoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FindEligibleForPromotionResponse::FindEligibleForPromotionResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.FindEligibleForPromotionResponse)
}

void FindEligibleForPromotionResponse::InitAsDefaultInstance() {
}

FindEligibleForPromotionResponse::FindEligibleForPromotionResponse(const FindEligibleForPromotionResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.FindEligibleForPromotionResponse)
}

void FindEligibleForPromotionResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  may_show_promo_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FindEligibleForPromotionResponse::~FindEligibleForPromotionResponse() {
  // @@protoc_insertion_point(destructor:cryptauth.FindEligibleForPromotionResponse)
  SharedDtor();
}

void FindEligibleForPromotionResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FindEligibleForPromotionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindEligibleForPromotionResponse& FindEligibleForPromotionResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

FindEligibleForPromotionResponse* FindEligibleForPromotionResponse::default_instance_ = NULL;

FindEligibleForPromotionResponse* FindEligibleForPromotionResponse::New(::google::protobuf::Arena* arena) const {
  FindEligibleForPromotionResponse* n = new FindEligibleForPromotionResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FindEligibleForPromotionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.FindEligibleForPromotionResponse)
  may_show_promo_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FindEligibleForPromotionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFindEligibleForPromotionResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.FindEligibleForPromotionResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool may_show_promo = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &may_show_promo_)));
          set_has_may_show_promo();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.FindEligibleForPromotionResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.FindEligibleForPromotionResponse)
  return false;
#undef DO_
}

void FindEligibleForPromotionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.FindEligibleForPromotionResponse)
  // optional bool may_show_promo = 1;
  if (has_may_show_promo()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->may_show_promo(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.FindEligibleForPromotionResponse)
}

int FindEligibleForPromotionResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.FindEligibleForPromotionResponse)
  int total_size = 0;

  // optional bool may_show_promo = 1;
  if (has_may_show_promo()) {
    total_size += 1 + 1;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FindEligibleForPromotionResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FindEligibleForPromotionResponse*>(&from));
}

void FindEligibleForPromotionResponse::MergeFrom(const FindEligibleForPromotionResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.FindEligibleForPromotionResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_may_show_promo()) {
      set_may_show_promo(from.may_show_promo());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FindEligibleForPromotionResponse::CopyFrom(const FindEligibleForPromotionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.FindEligibleForPromotionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindEligibleForPromotionResponse::IsInitialized() const {

  return true;
}

void FindEligibleForPromotionResponse::Swap(FindEligibleForPromotionResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FindEligibleForPromotionResponse::InternalSwap(FindEligibleForPromotionResponse* other) {
  std::swap(may_show_promo_, other->may_show_promo_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FindEligibleForPromotionResponse::GetTypeName() const {
  return "cryptauth.FindEligibleForPromotionResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FindEligibleForPromotionResponse

// optional bool may_show_promo = 1;
bool FindEligibleForPromotionResponse::has_may_show_promo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FindEligibleForPromotionResponse::set_has_may_show_promo() {
  _has_bits_[0] |= 0x00000001u;
}
void FindEligibleForPromotionResponse::clear_has_may_show_promo() {
  _has_bits_[0] &= ~0x00000001u;
}
void FindEligibleForPromotionResponse::clear_may_show_promo() {
  may_show_promo_ = false;
  clear_has_may_show_promo();
}
 bool FindEligibleForPromotionResponse::may_show_promo() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleForPromotionResponse.may_show_promo)
  return may_show_promo_;
}
 void FindEligibleForPromotionResponse::set_may_show_promo(bool value) {
  set_has_may_show_promo();
  may_show_promo_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.FindEligibleForPromotionResponse.may_show_promo)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFindEligibleUnlockDevicesRequest(
    FindEligibleUnlockDevicesRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FindEligibleUnlockDevicesRequest::kCallbackBluetoothAddressFieldNumber;
const int FindEligibleUnlockDevicesRequest::kRetryCountFieldNumber;
const int FindEligibleUnlockDevicesRequest::kMaxLastUpdateTimeDeltaMillisFieldNumber;
const int FindEligibleUnlockDevicesRequest::kOfflineAllowedFieldNumber;
const int FindEligibleUnlockDevicesRequest::kDeviceClassifierFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FindEligibleUnlockDevicesRequest::FindEligibleUnlockDevicesRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.FindEligibleUnlockDevicesRequest)
}

void FindEligibleUnlockDevicesRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(
      ::cryptauth::DeviceClassifier::internal_default_instance());
#else
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(&::cryptauth::DeviceClassifier::default_instance());
#endif
}

FindEligibleUnlockDevicesRequest::FindEligibleUnlockDevicesRequest(const FindEligibleUnlockDevicesRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.FindEligibleUnlockDevicesRequest)
}

void FindEligibleUnlockDevicesRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  callback_bluetooth_address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  retry_count_ = 0;
  max_last_update_time_delta_millis_ = GOOGLE_LONGLONG(0);
  offline_allowed_ = false;
  device_classifier_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FindEligibleUnlockDevicesRequest::~FindEligibleUnlockDevicesRequest() {
  // @@protoc_insertion_point(destructor:cryptauth.FindEligibleUnlockDevicesRequest)
  SharedDtor();
}

void FindEligibleUnlockDevicesRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  callback_bluetooth_address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete device_classifier_;
  }
}

void FindEligibleUnlockDevicesRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindEligibleUnlockDevicesRequest& FindEligibleUnlockDevicesRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

FindEligibleUnlockDevicesRequest* FindEligibleUnlockDevicesRequest::default_instance_ = NULL;

FindEligibleUnlockDevicesRequest* FindEligibleUnlockDevicesRequest::New(::google::protobuf::Arena* arena) const {
  FindEligibleUnlockDevicesRequest* n = new FindEligibleUnlockDevicesRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FindEligibleUnlockDevicesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.FindEligibleUnlockDevicesRequest)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(FindEligibleUnlockDevicesRequest, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<FindEligibleUnlockDevicesRequest*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(max_last_update_time_delta_millis_, offline_allowed_);
    if (has_callback_bluetooth_address()) {
      callback_bluetooth_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_device_classifier()) {
      if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FindEligibleUnlockDevicesRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFindEligibleUnlockDevicesRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.FindEligibleUnlockDevicesRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string callback_bluetooth_address = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_callback_bluetooth_address()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_retry_count;
        break;
      }

      // optional int32 retry_count = 3;
      case 3: {
        if (tag == 24) {
         parse_retry_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &retry_count_)));
          set_has_retry_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_max_last_update_time_delta_millis;
        break;
      }

      // optional int64 max_last_update_time_delta_millis = 4;
      case 4: {
        if (tag == 32) {
         parse_max_last_update_time_delta_millis:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_last_update_time_delta_millis_)));
          set_has_max_last_update_time_delta_millis();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_offline_allowed;
        break;
      }

      // optional bool offline_allowed = 5 [default = false];
      case 5: {
        if (tag == 40) {
         parse_offline_allowed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &offline_allowed_)));
          set_has_offline_allowed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_device_classifier;
        break;
      }

      // optional .cryptauth.DeviceClassifier device_classifier = 6;
      case 6: {
        if (tag == 50) {
         parse_device_classifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_device_classifier()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.FindEligibleUnlockDevicesRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.FindEligibleUnlockDevicesRequest)
  return false;
#undef DO_
}

void FindEligibleUnlockDevicesRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.FindEligibleUnlockDevicesRequest)
  // optional string callback_bluetooth_address = 2;
  if (has_callback_bluetooth_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->callback_bluetooth_address(), output);
  }

  // optional int32 retry_count = 3;
  if (has_retry_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->retry_count(), output);
  }

  // optional int64 max_last_update_time_delta_millis = 4;
  if (has_max_last_update_time_delta_millis()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->max_last_update_time_delta_millis(), output);
  }

  // optional bool offline_allowed = 5 [default = false];
  if (has_offline_allowed()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->offline_allowed(), output);
  }

  // optional .cryptauth.DeviceClassifier device_classifier = 6;
  if (has_device_classifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->device_classifier_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.FindEligibleUnlockDevicesRequest)
}

int FindEligibleUnlockDevicesRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.FindEligibleUnlockDevicesRequest)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional string callback_bluetooth_address = 2;
    if (has_callback_bluetooth_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->callback_bluetooth_address());
    }

    // optional int32 retry_count = 3;
    if (has_retry_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->retry_count());
    }

    // optional int64 max_last_update_time_delta_millis = 4;
    if (has_max_last_update_time_delta_millis()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->max_last_update_time_delta_millis());
    }

    // optional bool offline_allowed = 5 [default = false];
    if (has_offline_allowed()) {
      total_size += 1 + 1;
    }

    // optional .cryptauth.DeviceClassifier device_classifier = 6;
    if (has_device_classifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->device_classifier_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FindEligibleUnlockDevicesRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FindEligibleUnlockDevicesRequest*>(&from));
}

void FindEligibleUnlockDevicesRequest::MergeFrom(const FindEligibleUnlockDevicesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.FindEligibleUnlockDevicesRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_callback_bluetooth_address()) {
      set_has_callback_bluetooth_address();
      callback_bluetooth_address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.callback_bluetooth_address_);
    }
    if (from.has_retry_count()) {
      set_retry_count(from.retry_count());
    }
    if (from.has_max_last_update_time_delta_millis()) {
      set_max_last_update_time_delta_millis(from.max_last_update_time_delta_millis());
    }
    if (from.has_offline_allowed()) {
      set_offline_allowed(from.offline_allowed());
    }
    if (from.has_device_classifier()) {
      mutable_device_classifier()->::cryptauth::DeviceClassifier::MergeFrom(from.device_classifier());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FindEligibleUnlockDevicesRequest::CopyFrom(const FindEligibleUnlockDevicesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.FindEligibleUnlockDevicesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindEligibleUnlockDevicesRequest::IsInitialized() const {

  return true;
}

void FindEligibleUnlockDevicesRequest::Swap(FindEligibleUnlockDevicesRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FindEligibleUnlockDevicesRequest::InternalSwap(FindEligibleUnlockDevicesRequest* other) {
  callback_bluetooth_address_.Swap(&other->callback_bluetooth_address_);
  std::swap(retry_count_, other->retry_count_);
  std::swap(max_last_update_time_delta_millis_, other->max_last_update_time_delta_millis_);
  std::swap(offline_allowed_, other->offline_allowed_);
  std::swap(device_classifier_, other->device_classifier_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FindEligibleUnlockDevicesRequest::GetTypeName() const {
  return "cryptauth.FindEligibleUnlockDevicesRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FindEligibleUnlockDevicesRequest

// optional string callback_bluetooth_address = 2;
bool FindEligibleUnlockDevicesRequest::has_callback_bluetooth_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FindEligibleUnlockDevicesRequest::set_has_callback_bluetooth_address() {
  _has_bits_[0] |= 0x00000001u;
}
void FindEligibleUnlockDevicesRequest::clear_has_callback_bluetooth_address() {
  _has_bits_[0] &= ~0x00000001u;
}
void FindEligibleUnlockDevicesRequest::clear_callback_bluetooth_address() {
  callback_bluetooth_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_callback_bluetooth_address();
}
 const ::std::string& FindEligibleUnlockDevicesRequest::callback_bluetooth_address() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
  return callback_bluetooth_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FindEligibleUnlockDevicesRequest::set_callback_bluetooth_address(const ::std::string& value) {
  set_has_callback_bluetooth_address();
  callback_bluetooth_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
}
 void FindEligibleUnlockDevicesRequest::set_callback_bluetooth_address(const char* value) {
  set_has_callback_bluetooth_address();
  callback_bluetooth_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
}
 void FindEligibleUnlockDevicesRequest::set_callback_bluetooth_address(const char* value, size_t size) {
  set_has_callback_bluetooth_address();
  callback_bluetooth_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
}
 ::std::string* FindEligibleUnlockDevicesRequest::mutable_callback_bluetooth_address() {
  set_has_callback_bluetooth_address();
  // @@protoc_insertion_point(field_mutable:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
  return callback_bluetooth_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FindEligibleUnlockDevicesRequest::release_callback_bluetooth_address() {
  // @@protoc_insertion_point(field_release:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
  clear_has_callback_bluetooth_address();
  return callback_bluetooth_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FindEligibleUnlockDevicesRequest::set_allocated_callback_bluetooth_address(::std::string* callback_bluetooth_address) {
  if (callback_bluetooth_address != NULL) {
    set_has_callback_bluetooth_address();
  } else {
    clear_has_callback_bluetooth_address();
  }
  callback_bluetooth_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), callback_bluetooth_address);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
}

// optional int32 retry_count = 3;
bool FindEligibleUnlockDevicesRequest::has_retry_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FindEligibleUnlockDevicesRequest::set_has_retry_count() {
  _has_bits_[0] |= 0x00000002u;
}
void FindEligibleUnlockDevicesRequest::clear_has_retry_count() {
  _has_bits_[0] &= ~0x00000002u;
}
void FindEligibleUnlockDevicesRequest::clear_retry_count() {
  retry_count_ = 0;
  clear_has_retry_count();
}
 ::google::protobuf::int32 FindEligibleUnlockDevicesRequest::retry_count() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesRequest.retry_count)
  return retry_count_;
}
 void FindEligibleUnlockDevicesRequest::set_retry_count(::google::protobuf::int32 value) {
  set_has_retry_count();
  retry_count_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.FindEligibleUnlockDevicesRequest.retry_count)
}

// optional int64 max_last_update_time_delta_millis = 4;
bool FindEligibleUnlockDevicesRequest::has_max_last_update_time_delta_millis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void FindEligibleUnlockDevicesRequest::set_has_max_last_update_time_delta_millis() {
  _has_bits_[0] |= 0x00000004u;
}
void FindEligibleUnlockDevicesRequest::clear_has_max_last_update_time_delta_millis() {
  _has_bits_[0] &= ~0x00000004u;
}
void FindEligibleUnlockDevicesRequest::clear_max_last_update_time_delta_millis() {
  max_last_update_time_delta_millis_ = GOOGLE_LONGLONG(0);
  clear_has_max_last_update_time_delta_millis();
}
 ::google::protobuf::int64 FindEligibleUnlockDevicesRequest::max_last_update_time_delta_millis() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesRequest.max_last_update_time_delta_millis)
  return max_last_update_time_delta_millis_;
}
 void FindEligibleUnlockDevicesRequest::set_max_last_update_time_delta_millis(::google::protobuf::int64 value) {
  set_has_max_last_update_time_delta_millis();
  max_last_update_time_delta_millis_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.FindEligibleUnlockDevicesRequest.max_last_update_time_delta_millis)
}

// optional bool offline_allowed = 5 [default = false];
bool FindEligibleUnlockDevicesRequest::has_offline_allowed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void FindEligibleUnlockDevicesRequest::set_has_offline_allowed() {
  _has_bits_[0] |= 0x00000008u;
}
void FindEligibleUnlockDevicesRequest::clear_has_offline_allowed() {
  _has_bits_[0] &= ~0x00000008u;
}
void FindEligibleUnlockDevicesRequest::clear_offline_allowed() {
  offline_allowed_ = false;
  clear_has_offline_allowed();
}
 bool FindEligibleUnlockDevicesRequest::offline_allowed() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesRequest.offline_allowed)
  return offline_allowed_;
}
 void FindEligibleUnlockDevicesRequest::set_offline_allowed(bool value) {
  set_has_offline_allowed();
  offline_allowed_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.FindEligibleUnlockDevicesRequest.offline_allowed)
}

// optional .cryptauth.DeviceClassifier device_classifier = 6;
bool FindEligibleUnlockDevicesRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void FindEligibleUnlockDevicesRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000010u;
}
void FindEligibleUnlockDevicesRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000010u;
}
void FindEligibleUnlockDevicesRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
const ::cryptauth::DeviceClassifier& FindEligibleUnlockDevicesRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
::cryptauth::DeviceClassifier* FindEligibleUnlockDevicesRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.FindEligibleUnlockDevicesRequest.device_classifier)
  return device_classifier_;
}
::cryptauth::DeviceClassifier* FindEligibleUnlockDevicesRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.FindEligibleUnlockDevicesRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
void FindEligibleUnlockDevicesRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FindEligibleUnlockDevicesRequest.device_classifier)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFindEligibleUnlockDevicesResponse(
    FindEligibleUnlockDevicesResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FindEligibleUnlockDevicesResponse::kEligibleDevicesFieldNumber;
const int FindEligibleUnlockDevicesResponse::kIneligibleDevicesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FindEligibleUnlockDevicesResponse::FindEligibleUnlockDevicesResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.FindEligibleUnlockDevicesResponse)
}

void FindEligibleUnlockDevicesResponse::InitAsDefaultInstance() {
}

FindEligibleUnlockDevicesResponse::FindEligibleUnlockDevicesResponse(const FindEligibleUnlockDevicesResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.FindEligibleUnlockDevicesResponse)
}

void FindEligibleUnlockDevicesResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FindEligibleUnlockDevicesResponse::~FindEligibleUnlockDevicesResponse() {
  // @@protoc_insertion_point(destructor:cryptauth.FindEligibleUnlockDevicesResponse)
  SharedDtor();
}

void FindEligibleUnlockDevicesResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FindEligibleUnlockDevicesResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FindEligibleUnlockDevicesResponse& FindEligibleUnlockDevicesResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

FindEligibleUnlockDevicesResponse* FindEligibleUnlockDevicesResponse::default_instance_ = NULL;

FindEligibleUnlockDevicesResponse* FindEligibleUnlockDevicesResponse::New(::google::protobuf::Arena* arena) const {
  FindEligibleUnlockDevicesResponse* n = new FindEligibleUnlockDevicesResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FindEligibleUnlockDevicesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.FindEligibleUnlockDevicesResponse)
  eligible_devices_.Clear();
  ineligible_devices_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FindEligibleUnlockDevicesResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFindEligibleUnlockDevicesResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.FindEligibleUnlockDevicesResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .cryptauth.ExternalDeviceInfo eligible_devices = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_eligible_devices:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_eligible_devices()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_eligible_devices;
        if (input->ExpectTag(18)) goto parse_loop_ineligible_devices;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .cryptauth.IneligibleDevice ineligible_devices = 2;
      case 2: {
        if (tag == 18) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_ineligible_devices:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_ineligible_devices()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_ineligible_devices;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.FindEligibleUnlockDevicesResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.FindEligibleUnlockDevicesResponse)
  return false;
#undef DO_
}

void FindEligibleUnlockDevicesResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.FindEligibleUnlockDevicesResponse)
  // repeated .cryptauth.ExternalDeviceInfo eligible_devices = 1;
  for (unsigned int i = 0, n = this->eligible_devices_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->eligible_devices(i), output);
  }

  // repeated .cryptauth.IneligibleDevice ineligible_devices = 2;
  for (unsigned int i = 0, n = this->ineligible_devices_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->ineligible_devices(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.FindEligibleUnlockDevicesResponse)
}

int FindEligibleUnlockDevicesResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.FindEligibleUnlockDevicesResponse)
  int total_size = 0;

  // repeated .cryptauth.ExternalDeviceInfo eligible_devices = 1;
  total_size += 1 * this->eligible_devices_size();
  for (int i = 0; i < this->eligible_devices_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->eligible_devices(i));
  }

  // repeated .cryptauth.IneligibleDevice ineligible_devices = 2;
  total_size += 1 * this->ineligible_devices_size();
  for (int i = 0; i < this->ineligible_devices_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ineligible_devices(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FindEligibleUnlockDevicesResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FindEligibleUnlockDevicesResponse*>(&from));
}

void FindEligibleUnlockDevicesResponse::MergeFrom(const FindEligibleUnlockDevicesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.FindEligibleUnlockDevicesResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  eligible_devices_.MergeFrom(from.eligible_devices_);
  ineligible_devices_.MergeFrom(from.ineligible_devices_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FindEligibleUnlockDevicesResponse::CopyFrom(const FindEligibleUnlockDevicesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.FindEligibleUnlockDevicesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FindEligibleUnlockDevicesResponse::IsInitialized() const {

  return true;
}

void FindEligibleUnlockDevicesResponse::Swap(FindEligibleUnlockDevicesResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FindEligibleUnlockDevicesResponse::InternalSwap(FindEligibleUnlockDevicesResponse* other) {
  eligible_devices_.UnsafeArenaSwap(&other->eligible_devices_);
  ineligible_devices_.UnsafeArenaSwap(&other->ineligible_devices_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FindEligibleUnlockDevicesResponse::GetTypeName() const {
  return "cryptauth.FindEligibleUnlockDevicesResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FindEligibleUnlockDevicesResponse

// repeated .cryptauth.ExternalDeviceInfo eligible_devices = 1;
int FindEligibleUnlockDevicesResponse::eligible_devices_size() const {
  return eligible_devices_.size();
}
void FindEligibleUnlockDevicesResponse::clear_eligible_devices() {
  eligible_devices_.Clear();
}
const ::cryptauth::ExternalDeviceInfo& FindEligibleUnlockDevicesResponse::eligible_devices(int index) const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesResponse.eligible_devices)
  return eligible_devices_.Get(index);
}
::cryptauth::ExternalDeviceInfo* FindEligibleUnlockDevicesResponse::mutable_eligible_devices(int index) {
  // @@protoc_insertion_point(field_mutable:cryptauth.FindEligibleUnlockDevicesResponse.eligible_devices)
  return eligible_devices_.Mutable(index);
}
::cryptauth::ExternalDeviceInfo* FindEligibleUnlockDevicesResponse::add_eligible_devices() {
  // @@protoc_insertion_point(field_add:cryptauth.FindEligibleUnlockDevicesResponse.eligible_devices)
  return eligible_devices_.Add();
}
::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo >*
FindEligibleUnlockDevicesResponse::mutable_eligible_devices() {
  // @@protoc_insertion_point(field_mutable_list:cryptauth.FindEligibleUnlockDevicesResponse.eligible_devices)
  return &eligible_devices_;
}
const ::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo >&
FindEligibleUnlockDevicesResponse::eligible_devices() const {
  // @@protoc_insertion_point(field_list:cryptauth.FindEligibleUnlockDevicesResponse.eligible_devices)
  return eligible_devices_;
}

// repeated .cryptauth.IneligibleDevice ineligible_devices = 2;
int FindEligibleUnlockDevicesResponse::ineligible_devices_size() const {
  return ineligible_devices_.size();
}
void FindEligibleUnlockDevicesResponse::clear_ineligible_devices() {
  ineligible_devices_.Clear();
}
const ::cryptauth::IneligibleDevice& FindEligibleUnlockDevicesResponse::ineligible_devices(int index) const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesResponse.ineligible_devices)
  return ineligible_devices_.Get(index);
}
::cryptauth::IneligibleDevice* FindEligibleUnlockDevicesResponse::mutable_ineligible_devices(int index) {
  // @@protoc_insertion_point(field_mutable:cryptauth.FindEligibleUnlockDevicesResponse.ineligible_devices)
  return ineligible_devices_.Mutable(index);
}
::cryptauth::IneligibleDevice* FindEligibleUnlockDevicesResponse::add_ineligible_devices() {
  // @@protoc_insertion_point(field_add:cryptauth.FindEligibleUnlockDevicesResponse.ineligible_devices)
  return ineligible_devices_.Add();
}
::google::protobuf::RepeatedPtrField< ::cryptauth::IneligibleDevice >*
FindEligibleUnlockDevicesResponse::mutable_ineligible_devices() {
  // @@protoc_insertion_point(field_mutable_list:cryptauth.FindEligibleUnlockDevicesResponse.ineligible_devices)
  return &ineligible_devices_;
}
const ::google::protobuf::RepeatedPtrField< ::cryptauth::IneligibleDevice >&
FindEligibleUnlockDevicesResponse::ineligible_devices() const {
  // @@protoc_insertion_point(field_list:cryptauth.FindEligibleUnlockDevicesResponse.ineligible_devices)
  return ineligible_devices_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFinishEnrollmentRequest(
    FinishEnrollmentRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FinishEnrollmentRequest::kEnrollmentSessionIdFieldNumber;
const int FinishEnrollmentRequest::kEnrollmentMessageFieldNumber;
const int FinishEnrollmentRequest::kDeviceEphemeralKeyFieldNumber;
const int FinishEnrollmentRequest::kInvocationReasonFieldNumber;
const int FinishEnrollmentRequest::kRetryCountFieldNumber;
const int FinishEnrollmentRequest::kDeviceClassifierFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FinishEnrollmentRequest::FinishEnrollmentRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.FinishEnrollmentRequest)
}

void FinishEnrollmentRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(
      ::cryptauth::DeviceClassifier::internal_default_instance());
#else
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(&::cryptauth::DeviceClassifier::default_instance());
#endif
}

FinishEnrollmentRequest::FinishEnrollmentRequest(const FinishEnrollmentRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.FinishEnrollmentRequest)
}

void FinishEnrollmentRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  enrollment_session_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  enrollment_message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_ephemeral_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  invocation_reason_ = 0;
  retry_count_ = 0;
  device_classifier_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FinishEnrollmentRequest::~FinishEnrollmentRequest() {
  // @@protoc_insertion_point(destructor:cryptauth.FinishEnrollmentRequest)
  SharedDtor();
}

void FinishEnrollmentRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  enrollment_session_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  enrollment_message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_ephemeral_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete device_classifier_;
  }
}

void FinishEnrollmentRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FinishEnrollmentRequest& FinishEnrollmentRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

FinishEnrollmentRequest* FinishEnrollmentRequest::default_instance_ = NULL;

FinishEnrollmentRequest* FinishEnrollmentRequest::New(::google::protobuf::Arena* arena) const {
  FinishEnrollmentRequest* n = new FinishEnrollmentRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FinishEnrollmentRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.FinishEnrollmentRequest)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(FinishEnrollmentRequest, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<FinishEnrollmentRequest*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(invocation_reason_, retry_count_);
    if (has_enrollment_session_id()) {
      enrollment_session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_enrollment_message()) {
      enrollment_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_device_ephemeral_key()) {
      device_ephemeral_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_device_classifier()) {
      if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FinishEnrollmentRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFinishEnrollmentRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.FinishEnrollmentRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes enrollment_session_id = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_enrollment_session_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_enrollment_message;
        break;
      }

      // optional bytes enrollment_message = 3;
      case 3: {
        if (tag == 26) {
         parse_enrollment_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_enrollment_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_device_ephemeral_key;
        break;
      }

      // optional bytes device_ephemeral_key = 4;
      case 4: {
        if (tag == 34) {
         parse_device_ephemeral_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_device_ephemeral_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_invocation_reason;
        break;
      }

      // optional int32 invocation_reason = 11 [default = 0];
      case 11: {
        if (tag == 88) {
         parse_invocation_reason:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &invocation_reason_)));
          set_has_invocation_reason();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_retry_count;
        break;
      }

      // optional int32 retry_count = 12 [default = 0];
      case 12: {
        if (tag == 96) {
         parse_retry_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &retry_count_)));
          set_has_retry_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_device_classifier;
        break;
      }

      // optional .cryptauth.DeviceClassifier device_classifier = 13;
      case 13: {
        if (tag == 106) {
         parse_device_classifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_device_classifier()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.FinishEnrollmentRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.FinishEnrollmentRequest)
  return false;
#undef DO_
}

void FinishEnrollmentRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.FinishEnrollmentRequest)
  // optional bytes enrollment_session_id = 2;
  if (has_enrollment_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->enrollment_session_id(), output);
  }

  // optional bytes enrollment_message = 3;
  if (has_enrollment_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->enrollment_message(), output);
  }

  // optional bytes device_ephemeral_key = 4;
  if (has_device_ephemeral_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->device_ephemeral_key(), output);
  }

  // optional int32 invocation_reason = 11 [default = 0];
  if (has_invocation_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->invocation_reason(), output);
  }

  // optional int32 retry_count = 12 [default = 0];
  if (has_retry_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->retry_count(), output);
  }

  // optional .cryptauth.DeviceClassifier device_classifier = 13;
  if (has_device_classifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      13, *this->device_classifier_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.FinishEnrollmentRequest)
}

int FinishEnrollmentRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.FinishEnrollmentRequest)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 63u) {
    // optional bytes enrollment_session_id = 2;
    if (has_enrollment_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->enrollment_session_id());
    }

    // optional bytes enrollment_message = 3;
    if (has_enrollment_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->enrollment_message());
    }

    // optional bytes device_ephemeral_key = 4;
    if (has_device_ephemeral_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->device_ephemeral_key());
    }

    // optional int32 invocation_reason = 11 [default = 0];
    if (has_invocation_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->invocation_reason());
    }

    // optional int32 retry_count = 12 [default = 0];
    if (has_retry_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->retry_count());
    }

    // optional .cryptauth.DeviceClassifier device_classifier = 13;
    if (has_device_classifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->device_classifier_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FinishEnrollmentRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FinishEnrollmentRequest*>(&from));
}

void FinishEnrollmentRequest::MergeFrom(const FinishEnrollmentRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.FinishEnrollmentRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enrollment_session_id()) {
      set_has_enrollment_session_id();
      enrollment_session_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.enrollment_session_id_);
    }
    if (from.has_enrollment_message()) {
      set_has_enrollment_message();
      enrollment_message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.enrollment_message_);
    }
    if (from.has_device_ephemeral_key()) {
      set_has_device_ephemeral_key();
      device_ephemeral_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_ephemeral_key_);
    }
    if (from.has_invocation_reason()) {
      set_invocation_reason(from.invocation_reason());
    }
    if (from.has_retry_count()) {
      set_retry_count(from.retry_count());
    }
    if (from.has_device_classifier()) {
      mutable_device_classifier()->::cryptauth::DeviceClassifier::MergeFrom(from.device_classifier());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FinishEnrollmentRequest::CopyFrom(const FinishEnrollmentRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.FinishEnrollmentRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FinishEnrollmentRequest::IsInitialized() const {

  return true;
}

void FinishEnrollmentRequest::Swap(FinishEnrollmentRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FinishEnrollmentRequest::InternalSwap(FinishEnrollmentRequest* other) {
  enrollment_session_id_.Swap(&other->enrollment_session_id_);
  enrollment_message_.Swap(&other->enrollment_message_);
  device_ephemeral_key_.Swap(&other->device_ephemeral_key_);
  std::swap(invocation_reason_, other->invocation_reason_);
  std::swap(retry_count_, other->retry_count_);
  std::swap(device_classifier_, other->device_classifier_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FinishEnrollmentRequest::GetTypeName() const {
  return "cryptauth.FinishEnrollmentRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FinishEnrollmentRequest

// optional bytes enrollment_session_id = 2;
bool FinishEnrollmentRequest::has_enrollment_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FinishEnrollmentRequest::set_has_enrollment_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
void FinishEnrollmentRequest::clear_has_enrollment_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void FinishEnrollmentRequest::clear_enrollment_session_id() {
  enrollment_session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_enrollment_session_id();
}
 const ::std::string& FinishEnrollmentRequest::enrollment_session_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
  return enrollment_session_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FinishEnrollmentRequest::set_enrollment_session_id(const ::std::string& value) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
}
 void FinishEnrollmentRequest::set_enrollment_session_id(const char* value) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
}
 void FinishEnrollmentRequest::set_enrollment_session_id(const void* value, size_t size) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
}
 ::std::string* FinishEnrollmentRequest::mutable_enrollment_session_id() {
  set_has_enrollment_session_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
  return enrollment_session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FinishEnrollmentRequest::release_enrollment_session_id() {
  // @@protoc_insertion_point(field_release:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
  clear_has_enrollment_session_id();
  return enrollment_session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FinishEnrollmentRequest::set_allocated_enrollment_session_id(::std::string* enrollment_session_id) {
  if (enrollment_session_id != NULL) {
    set_has_enrollment_session_id();
  } else {
    clear_has_enrollment_session_id();
  }
  enrollment_session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enrollment_session_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
}

// optional bytes enrollment_message = 3;
bool FinishEnrollmentRequest::has_enrollment_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FinishEnrollmentRequest::set_has_enrollment_message() {
  _has_bits_[0] |= 0x00000002u;
}
void FinishEnrollmentRequest::clear_has_enrollment_message() {
  _has_bits_[0] &= ~0x00000002u;
}
void FinishEnrollmentRequest::clear_enrollment_message() {
  enrollment_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_enrollment_message();
}
 const ::std::string& FinishEnrollmentRequest::enrollment_message() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentRequest.enrollment_message)
  return enrollment_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FinishEnrollmentRequest::set_enrollment_message(const ::std::string& value) {
  set_has_enrollment_message();
  enrollment_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentRequest.enrollment_message)
}
 void FinishEnrollmentRequest::set_enrollment_message(const char* value) {
  set_has_enrollment_message();
  enrollment_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FinishEnrollmentRequest.enrollment_message)
}
 void FinishEnrollmentRequest::set_enrollment_message(const void* value, size_t size) {
  set_has_enrollment_message();
  enrollment_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FinishEnrollmentRequest.enrollment_message)
}
 ::std::string* FinishEnrollmentRequest::mutable_enrollment_message() {
  set_has_enrollment_message();
  // @@protoc_insertion_point(field_mutable:cryptauth.FinishEnrollmentRequest.enrollment_message)
  return enrollment_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FinishEnrollmentRequest::release_enrollment_message() {
  // @@protoc_insertion_point(field_release:cryptauth.FinishEnrollmentRequest.enrollment_message)
  clear_has_enrollment_message();
  return enrollment_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FinishEnrollmentRequest::set_allocated_enrollment_message(::std::string* enrollment_message) {
  if (enrollment_message != NULL) {
    set_has_enrollment_message();
  } else {
    clear_has_enrollment_message();
  }
  enrollment_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enrollment_message);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FinishEnrollmentRequest.enrollment_message)
}

// optional bytes device_ephemeral_key = 4;
bool FinishEnrollmentRequest::has_device_ephemeral_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void FinishEnrollmentRequest::set_has_device_ephemeral_key() {
  _has_bits_[0] |= 0x00000004u;
}
void FinishEnrollmentRequest::clear_has_device_ephemeral_key() {
  _has_bits_[0] &= ~0x00000004u;
}
void FinishEnrollmentRequest::clear_device_ephemeral_key() {
  device_ephemeral_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_ephemeral_key();
}
 const ::std::string& FinishEnrollmentRequest::device_ephemeral_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
  return device_ephemeral_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FinishEnrollmentRequest::set_device_ephemeral_key(const ::std::string& value) {
  set_has_device_ephemeral_key();
  device_ephemeral_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
}
 void FinishEnrollmentRequest::set_device_ephemeral_key(const char* value) {
  set_has_device_ephemeral_key();
  device_ephemeral_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
}
 void FinishEnrollmentRequest::set_device_ephemeral_key(const void* value, size_t size) {
  set_has_device_ephemeral_key();
  device_ephemeral_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
}
 ::std::string* FinishEnrollmentRequest::mutable_device_ephemeral_key() {
  set_has_device_ephemeral_key();
  // @@protoc_insertion_point(field_mutable:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
  return device_ephemeral_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FinishEnrollmentRequest::release_device_ephemeral_key() {
  // @@protoc_insertion_point(field_release:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
  clear_has_device_ephemeral_key();
  return device_ephemeral_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FinishEnrollmentRequest::set_allocated_device_ephemeral_key(::std::string* device_ephemeral_key) {
  if (device_ephemeral_key != NULL) {
    set_has_device_ephemeral_key();
  } else {
    clear_has_device_ephemeral_key();
  }
  device_ephemeral_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_ephemeral_key);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
}

// optional int32 invocation_reason = 11 [default = 0];
bool FinishEnrollmentRequest::has_invocation_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void FinishEnrollmentRequest::set_has_invocation_reason() {
  _has_bits_[0] |= 0x00000008u;
}
void FinishEnrollmentRequest::clear_has_invocation_reason() {
  _has_bits_[0] &= ~0x00000008u;
}
void FinishEnrollmentRequest::clear_invocation_reason() {
  invocation_reason_ = 0;
  clear_has_invocation_reason();
}
 ::google::protobuf::int32 FinishEnrollmentRequest::invocation_reason() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentRequest.invocation_reason)
  return invocation_reason_;
}
 void FinishEnrollmentRequest::set_invocation_reason(::google::protobuf::int32 value) {
  set_has_invocation_reason();
  invocation_reason_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentRequest.invocation_reason)
}

// optional int32 retry_count = 12 [default = 0];
bool FinishEnrollmentRequest::has_retry_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void FinishEnrollmentRequest::set_has_retry_count() {
  _has_bits_[0] |= 0x00000010u;
}
void FinishEnrollmentRequest::clear_has_retry_count() {
  _has_bits_[0] &= ~0x00000010u;
}
void FinishEnrollmentRequest::clear_retry_count() {
  retry_count_ = 0;
  clear_has_retry_count();
}
 ::google::protobuf::int32 FinishEnrollmentRequest::retry_count() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentRequest.retry_count)
  return retry_count_;
}
 void FinishEnrollmentRequest::set_retry_count(::google::protobuf::int32 value) {
  set_has_retry_count();
  retry_count_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentRequest.retry_count)
}

// optional .cryptauth.DeviceClassifier device_classifier = 13;
bool FinishEnrollmentRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void FinishEnrollmentRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000020u;
}
void FinishEnrollmentRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000020u;
}
void FinishEnrollmentRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
const ::cryptauth::DeviceClassifier& FinishEnrollmentRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
::cryptauth::DeviceClassifier* FinishEnrollmentRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.FinishEnrollmentRequest.device_classifier)
  return device_classifier_;
}
::cryptauth::DeviceClassifier* FinishEnrollmentRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.FinishEnrollmentRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
void FinishEnrollmentRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FinishEnrollmentRequest.device_classifier)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFinishEnrollmentResponse(
    FinishEnrollmentResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FinishEnrollmentResponse::kStatusFieldNumber;
const int FinishEnrollmentResponse::kErrorMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FinishEnrollmentResponse::FinishEnrollmentResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.FinishEnrollmentResponse)
}

void FinishEnrollmentResponse::InitAsDefaultInstance() {
}

FinishEnrollmentResponse::FinishEnrollmentResponse(const FinishEnrollmentResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.FinishEnrollmentResponse)
}

void FinishEnrollmentResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  status_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  error_message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FinishEnrollmentResponse::~FinishEnrollmentResponse() {
  // @@protoc_insertion_point(destructor:cryptauth.FinishEnrollmentResponse)
  SharedDtor();
}

void FinishEnrollmentResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  status_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  error_message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FinishEnrollmentResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FinishEnrollmentResponse& FinishEnrollmentResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

FinishEnrollmentResponse* FinishEnrollmentResponse::default_instance_ = NULL;

FinishEnrollmentResponse* FinishEnrollmentResponse::New(::google::protobuf::Arena* arena) const {
  FinishEnrollmentResponse* n = new FinishEnrollmentResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FinishEnrollmentResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.FinishEnrollmentResponse)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_status()) {
      status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_error_message()) {
      error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FinishEnrollmentResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFinishEnrollmentResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.FinishEnrollmentResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string status = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_error_message;
        break;
      }

      // optional string error_message = 2;
      case 2: {
        if (tag == 18) {
         parse_error_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_error_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.FinishEnrollmentResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.FinishEnrollmentResponse)
  return false;
#undef DO_
}

void FinishEnrollmentResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.FinishEnrollmentResponse)
  // optional string status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->status(), output);
  }

  // optional string error_message = 2;
  if (has_error_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->error_message(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.FinishEnrollmentResponse)
}

int FinishEnrollmentResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.FinishEnrollmentResponse)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional string status = 1;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->status());
    }

    // optional string error_message = 2;
    if (has_error_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->error_message());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FinishEnrollmentResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FinishEnrollmentResponse*>(&from));
}

void FinishEnrollmentResponse::MergeFrom(const FinishEnrollmentResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.FinishEnrollmentResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_has_status();
      status_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.status_);
    }
    if (from.has_error_message()) {
      set_has_error_message();
      error_message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.error_message_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FinishEnrollmentResponse::CopyFrom(const FinishEnrollmentResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.FinishEnrollmentResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FinishEnrollmentResponse::IsInitialized() const {

  return true;
}

void FinishEnrollmentResponse::Swap(FinishEnrollmentResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FinishEnrollmentResponse::InternalSwap(FinishEnrollmentResponse* other) {
  status_.Swap(&other->status_);
  error_message_.Swap(&other->error_message_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FinishEnrollmentResponse::GetTypeName() const {
  return "cryptauth.FinishEnrollmentResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FinishEnrollmentResponse

// optional string status = 1;
bool FinishEnrollmentResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FinishEnrollmentResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
void FinishEnrollmentResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
void FinishEnrollmentResponse::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
 const ::std::string& FinishEnrollmentResponse::status() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentResponse.status)
  return status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FinishEnrollmentResponse::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentResponse.status)
}
 void FinishEnrollmentResponse::set_status(const char* value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FinishEnrollmentResponse.status)
}
 void FinishEnrollmentResponse::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FinishEnrollmentResponse.status)
}
 ::std::string* FinishEnrollmentResponse::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:cryptauth.FinishEnrollmentResponse.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FinishEnrollmentResponse::release_status() {
  // @@protoc_insertion_point(field_release:cryptauth.FinishEnrollmentResponse.status)
  clear_has_status();
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FinishEnrollmentResponse::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FinishEnrollmentResponse.status)
}

// optional string error_message = 2;
bool FinishEnrollmentResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FinishEnrollmentResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
void FinishEnrollmentResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
void FinishEnrollmentResponse::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_message();
}
 const ::std::string& FinishEnrollmentResponse::error_message() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentResponse.error_message)
  return error_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FinishEnrollmentResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentResponse.error_message)
}
 void FinishEnrollmentResponse::set_error_message(const char* value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FinishEnrollmentResponse.error_message)
}
 void FinishEnrollmentResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FinishEnrollmentResponse.error_message)
}
 ::std::string* FinishEnrollmentResponse::mutable_error_message() {
  set_has_error_message();
  // @@protoc_insertion_point(field_mutable:cryptauth.FinishEnrollmentResponse.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FinishEnrollmentResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:cryptauth.FinishEnrollmentResponse.error_message)
  clear_has_error_message();
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FinishEnrollmentResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    set_has_error_message();
  } else {
    clear_has_error_message();
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FinishEnrollmentResponse.error_message)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForGcmDeviceInfo(
    GcmDeviceInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GcmDeviceInfo::kAndroidDeviceIdFieldNumber;
const int GcmDeviceInfo::kGcmRegistrationIdFieldNumber;
const int GcmDeviceInfo::kApnRegistrationIdFieldNumber;
const int GcmDeviceInfo::kApnNotificationEnabledFieldNumber;
const int GcmDeviceInfo::kBluetoothMacAddressFieldNumber;
const int GcmDeviceInfo::kDeviceMasterKeyHashFieldNumber;
const int GcmDeviceInfo::kUserPublicKeyFieldNumber;
const int GcmDeviceInfo::kDeviceModelFieldNumber;
const int GcmDeviceInfo::kLocaleFieldNumber;
const int GcmDeviceInfo::kKeyHandleFieldNumber;
const int GcmDeviceInfo::kCounterFieldNumber;
const int GcmDeviceInfo::kDeviceOsVersionFieldNumber;
const int GcmDeviceInfo::kDeviceOsVersionCodeFieldNumber;
const int GcmDeviceInfo::kDeviceOsReleaseFieldNumber;
const int GcmDeviceInfo::kDeviceOsCodenameFieldNumber;
const int GcmDeviceInfo::kDeviceSoftwareVersionFieldNumber;
const int GcmDeviceInfo::kDeviceSoftwareVersionCodeFieldNumber;
const int GcmDeviceInfo::kDeviceSoftwarePackageFieldNumber;
const int GcmDeviceInfo::kDeviceDisplayDiagonalMilsFieldNumber;
const int GcmDeviceInfo::kDeviceAuthzenVersionFieldNumber;
const int GcmDeviceInfo::kLongDeviceIdFieldNumber;
const int GcmDeviceInfo::kDeviceManufacturerFieldNumber;
const int GcmDeviceInfo::kDeviceTypeFieldNumber;
const int GcmDeviceInfo::kUsingSecureScreenlockFieldNumber;
const int GcmDeviceInfo::kAutoUnlockScreenlockSupportedFieldNumber;
const int GcmDeviceInfo::kAutoUnlockScreenlockEnabledFieldNumber;
const int GcmDeviceInfo::kBluetoothRadioSupportedFieldNumber;
const int GcmDeviceInfo::kBluetoothRadioEnabledFieldNumber;
const int GcmDeviceInfo::kEnrollmentSessionIdFieldNumber;
const int GcmDeviceInfo::kOauthTokenFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GcmDeviceInfo::GcmDeviceInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.GcmDeviceInfo)
}

void GcmDeviceInfo::InitAsDefaultInstance() {
}

GcmDeviceInfo::GcmDeviceInfo(const GcmDeviceInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.GcmDeviceInfo)
}

void GcmDeviceInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  android_device_id_ = GOOGLE_ULONGLONG(0);
  gcm_registration_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  apn_registration_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  apn_notification_enabled_ = false;
  bluetooth_mac_address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_master_key_hash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_model_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  locale_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_handle_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  counter_ = GOOGLE_LONGLONG(0);
  device_os_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_os_version_code_ = GOOGLE_LONGLONG(0);
  device_os_release_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_os_codename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_software_version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_software_version_code_ = GOOGLE_LONGLONG(0);
  device_software_package_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_display_diagonal_mils_ = 0;
  device_authzen_version_ = 0;
  long_device_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_manufacturer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_type_ = 1;
  using_secure_screenlock_ = false;
  auto_unlock_screenlock_supported_ = false;
  auto_unlock_screenlock_enabled_ = false;
  bluetooth_radio_supported_ = false;
  bluetooth_radio_enabled_ = false;
  enrollment_session_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  oauth_token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GcmDeviceInfo::~GcmDeviceInfo() {
  // @@protoc_insertion_point(destructor:cryptauth.GcmDeviceInfo)
  SharedDtor();
}

void GcmDeviceInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gcm_registration_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  apn_registration_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  bluetooth_mac_address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_master_key_hash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_public_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_model_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  locale_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_handle_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_os_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_os_release_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_os_codename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_software_version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_software_package_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  long_device_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_manufacturer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  enrollment_session_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  oauth_token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GcmDeviceInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GcmDeviceInfo& GcmDeviceInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

GcmDeviceInfo* GcmDeviceInfo::default_instance_ = NULL;

GcmDeviceInfo* GcmDeviceInfo::New(::google::protobuf::Arena* arena) const {
  GcmDeviceInfo* n = new GcmDeviceInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GcmDeviceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.GcmDeviceInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(GcmDeviceInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<GcmDeviceInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    android_device_id_ = GOOGLE_ULONGLONG(0);
    if (has_gcm_registration_id()) {
      gcm_registration_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_apn_registration_id()) {
      apn_registration_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    apn_notification_enabled_ = false;
    if (has_bluetooth_mac_address()) {
      bluetooth_mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_device_master_key_hash()) {
      device_master_key_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_user_public_key()) {
      user_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_device_model()) {
      device_model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[8 / 32] & 65280u) {
    if (has_locale()) {
      locale_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_key_handle()) {
      key_handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    counter_ = GOOGLE_LONGLONG(0);
    if (has_device_os_version()) {
      device_os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    device_os_version_code_ = GOOGLE_LONGLONG(0);
    if (has_device_os_release()) {
      device_os_release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_device_os_codename()) {
      device_os_codename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_device_software_version()) {
      device_software_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[16 / 32] & 16711680u) {
    device_software_version_code_ = GOOGLE_LONGLONG(0);
    if (has_device_software_package()) {
      device_software_package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    device_display_diagonal_mils_ = 0;
    device_authzen_version_ = 0;
    if (has_long_device_id()) {
      long_device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_device_manufacturer()) {
      device_manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    device_type_ = 1;
    using_secure_screenlock_ = false;
  }
  if (_has_bits_[24 / 32] & 1056964608u) {
    ZR_(auto_unlock_screenlock_supported_, auto_unlock_screenlock_enabled_);
    ZR_(bluetooth_radio_supported_, bluetooth_radio_enabled_);
    if (has_enrollment_session_id()) {
      enrollment_session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_oauth_token()) {
      oauth_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GcmDeviceInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGcmDeviceInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.GcmDeviceInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 android_device_id = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &android_device_id_)));
          set_has_android_device_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_user_public_key;
        break;
      }

      // required bytes user_public_key = 4;
      case 4: {
        if (tag == 34) {
         parse_user_public_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_public_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_device_model;
        break;
      }

      // optional string device_model = 7;
      case 7: {
        if (tag == 58) {
         parse_device_model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_model()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_locale;
        break;
      }

      // optional string locale = 8;
      case 8: {
        if (tag == 66) {
         parse_locale:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_locale()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_key_handle;
        break;
      }

      // optional bytes key_handle = 9;
      case 9: {
        if (tag == 74) {
         parse_key_handle:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key_handle()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_counter;
        break;
      }

      // optional int64 counter = 12 [default = 0];
      case 12: {
        if (tag == 96) {
         parse_counter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &counter_)));
          set_has_counter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_device_os_version;
        break;
      }

      // optional string device_os_version = 13;
      case 13: {
        if (tag == 106) {
         parse_device_os_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_os_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_device_os_version_code;
        break;
      }

      // optional int64 device_os_version_code = 14;
      case 14: {
        if (tag == 112) {
         parse_device_os_version_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &device_os_version_code_)));
          set_has_device_os_version_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_device_os_release;
        break;
      }

      // optional string device_os_release = 15;
      case 15: {
        if (tag == 122) {
         parse_device_os_release:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_os_release()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_device_os_codename;
        break;
      }

      // optional string device_os_codename = 16;
      case 16: {
        if (tag == 130) {
         parse_device_os_codename:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_os_codename()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(138)) goto parse_device_software_version;
        break;
      }

      // optional string device_software_version = 17;
      case 17: {
        if (tag == 138) {
         parse_device_software_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_software_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_device_software_version_code;
        break;
      }

      // optional int64 device_software_version_code = 18;
      case 18: {
        if (tag == 144) {
         parse_device_software_version_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &device_software_version_code_)));
          set_has_device_software_version_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_device_software_package;
        break;
      }

      // optional string device_software_package = 19;
      case 19: {
        if (tag == 154) {
         parse_device_software_package:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_software_package()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(176)) goto parse_device_display_diagonal_mils;
        break;
      }

      // optional int32 device_display_diagonal_mils = 22;
      case 22: {
        if (tag == 176) {
         parse_device_display_diagonal_mils:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &device_display_diagonal_mils_)));
          set_has_device_display_diagonal_mils();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_device_authzen_version;
        break;
      }

      // optional int32 device_authzen_version = 24;
      case 24: {
        if (tag == 192) {
         parse_device_authzen_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &device_authzen_version_)));
          set_has_device_authzen_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(234)) goto parse_long_device_id;
        break;
      }

      // optional bytes long_device_id = 29;
      case 29: {
        if (tag == 234) {
         parse_long_device_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_long_device_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(250)) goto parse_device_manufacturer;
        break;
      }

      // optional string device_manufacturer = 31;
      case 31: {
        if (tag == 250) {
         parse_device_manufacturer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_manufacturer()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(256)) goto parse_device_type;
        break;
      }

      // optional .cryptauth.DeviceType device_type = 32 [default = ANDROIDOS];
      case 32: {
        if (tag == 256) {
         parse_device_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cryptauth::DeviceType_IsValid(value)) {
            set_device_type(static_cast< ::cryptauth::DeviceType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(256);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(818)) goto parse_gcm_registration_id;
        break;
      }

      // optional bytes gcm_registration_id = 102;
      case 102: {
        if (tag == 818) {
         parse_gcm_registration_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_gcm_registration_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(826)) goto parse_device_master_key_hash;
        break;
      }

      // optional bytes device_master_key_hash = 103;
      case 103: {
        if (tag == 826) {
         parse_device_master_key_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_device_master_key_hash()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1618)) goto parse_apn_registration_id;
        break;
      }

      // optional bytes apn_registration_id = 202;
      case 202: {
        if (tag == 1618) {
         parse_apn_registration_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_apn_registration_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(1624)) goto parse_apn_notification_enabled;
        break;
      }

      // optional bool apn_notification_enabled = 203 [default = false];
      case 203: {
        if (tag == 1624) {
         parse_apn_notification_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &apn_notification_enabled_)));
          set_has_apn_notification_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(2418)) goto parse_bluetooth_mac_address;
        break;
      }

      // optional string bluetooth_mac_address = 302;
      case 302: {
        if (tag == 2418) {
         parse_bluetooth_mac_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bluetooth_mac_address()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(3200)) goto parse_using_secure_screenlock;
        break;
      }

      // optional bool using_secure_screenlock = 400 [default = false];
      case 400: {
        if (tag == 3200) {
         parse_using_secure_screenlock:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &using_secure_screenlock_)));
          set_has_using_secure_screenlock();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(3208)) goto parse_auto_unlock_screenlock_supported;
        break;
      }

      // optional bool auto_unlock_screenlock_supported = 401 [default = false];
      case 401: {
        if (tag == 3208) {
         parse_auto_unlock_screenlock_supported:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &auto_unlock_screenlock_supported_)));
          set_has_auto_unlock_screenlock_supported();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(3216)) goto parse_auto_unlock_screenlock_enabled;
        break;
      }

      // optional bool auto_unlock_screenlock_enabled = 402 [default = false];
      case 402: {
        if (tag == 3216) {
         parse_auto_unlock_screenlock_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &auto_unlock_screenlock_enabled_)));
          set_has_auto_unlock_screenlock_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(3224)) goto parse_bluetooth_radio_supported;
        break;
      }

      // optional bool bluetooth_radio_supported = 403 [default = false];
      case 403: {
        if (tag == 3224) {
         parse_bluetooth_radio_supported:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bluetooth_radio_supported_)));
          set_has_bluetooth_radio_supported();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(3232)) goto parse_bluetooth_radio_enabled;
        break;
      }

      // optional bool bluetooth_radio_enabled = 404 [default = false];
      case 404: {
        if (tag == 3232) {
         parse_bluetooth_radio_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bluetooth_radio_enabled_)));
          set_has_bluetooth_radio_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8002)) goto parse_enrollment_session_id;
        break;
      }

      // optional bytes enrollment_session_id = 1000;
      case 1000: {
        if (tag == 8002) {
         parse_enrollment_session_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_enrollment_session_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8010)) goto parse_oauth_token;
        break;
      }

      // optional string oauth_token = 1001;
      case 1001: {
        if (tag == 8010) {
         parse_oauth_token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_oauth_token()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.GcmDeviceInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.GcmDeviceInfo)
  return false;
#undef DO_
}

void GcmDeviceInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.GcmDeviceInfo)
  // optional fixed64 android_device_id = 1;
  if (has_android_device_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->android_device_id(), output);
  }

  // required bytes user_public_key = 4;
  if (has_user_public_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->user_public_key(), output);
  }

  // optional string device_model = 7;
  if (has_device_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->device_model(), output);
  }

  // optional string locale = 8;
  if (has_locale()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->locale(), output);
  }

  // optional bytes key_handle = 9;
  if (has_key_handle()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      9, this->key_handle(), output);
  }

  // optional int64 counter = 12 [default = 0];
  if (has_counter()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(12, this->counter(), output);
  }

  // optional string device_os_version = 13;
  if (has_device_os_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      13, this->device_os_version(), output);
  }

  // optional int64 device_os_version_code = 14;
  if (has_device_os_version_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(14, this->device_os_version_code(), output);
  }

  // optional string device_os_release = 15;
  if (has_device_os_release()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      15, this->device_os_release(), output);
  }

  // optional string device_os_codename = 16;
  if (has_device_os_codename()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      16, this->device_os_codename(), output);
  }

  // optional string device_software_version = 17;
  if (has_device_software_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      17, this->device_software_version(), output);
  }

  // optional int64 device_software_version_code = 18;
  if (has_device_software_version_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(18, this->device_software_version_code(), output);
  }

  // optional string device_software_package = 19;
  if (has_device_software_package()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      19, this->device_software_package(), output);
  }

  // optional int32 device_display_diagonal_mils = 22;
  if (has_device_display_diagonal_mils()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(22, this->device_display_diagonal_mils(), output);
  }

  // optional int32 device_authzen_version = 24;
  if (has_device_authzen_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(24, this->device_authzen_version(), output);
  }

  // optional bytes long_device_id = 29;
  if (has_long_device_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      29, this->long_device_id(), output);
  }

  // optional string device_manufacturer = 31;
  if (has_device_manufacturer()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      31, this->device_manufacturer(), output);
  }

  // optional .cryptauth.DeviceType device_type = 32 [default = ANDROIDOS];
  if (has_device_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      32, this->device_type(), output);
  }

  // optional bytes gcm_registration_id = 102;
  if (has_gcm_registration_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      102, this->gcm_registration_id(), output);
  }

  // optional bytes device_master_key_hash = 103;
  if (has_device_master_key_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      103, this->device_master_key_hash(), output);
  }

  // optional bytes apn_registration_id = 202;
  if (has_apn_registration_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      202, this->apn_registration_id(), output);
  }

  // optional bool apn_notification_enabled = 203 [default = false];
  if (has_apn_notification_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(203, this->apn_notification_enabled(), output);
  }

  // optional string bluetooth_mac_address = 302;
  if (has_bluetooth_mac_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      302, this->bluetooth_mac_address(), output);
  }

  // optional bool using_secure_screenlock = 400 [default = false];
  if (has_using_secure_screenlock()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(400, this->using_secure_screenlock(), output);
  }

  // optional bool auto_unlock_screenlock_supported = 401 [default = false];
  if (has_auto_unlock_screenlock_supported()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(401, this->auto_unlock_screenlock_supported(), output);
  }

  // optional bool auto_unlock_screenlock_enabled = 402 [default = false];
  if (has_auto_unlock_screenlock_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(402, this->auto_unlock_screenlock_enabled(), output);
  }

  // optional bool bluetooth_radio_supported = 403 [default = false];
  if (has_bluetooth_radio_supported()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(403, this->bluetooth_radio_supported(), output);
  }

  // optional bool bluetooth_radio_enabled = 404 [default = false];
  if (has_bluetooth_radio_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(404, this->bluetooth_radio_enabled(), output);
  }

  // optional bytes enrollment_session_id = 1000;
  if (has_enrollment_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1000, this->enrollment_session_id(), output);
  }

  // optional string oauth_token = 1001;
  if (has_oauth_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1001, this->oauth_token(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.GcmDeviceInfo)
}

int GcmDeviceInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.GcmDeviceInfo)
  int total_size = 0;

  // required bytes user_public_key = 4;
  if (has_user_public_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->user_public_key());
  }
  if (_has_bits_[0 / 32] & 191u) {
    // optional fixed64 android_device_id = 1;
    if (has_android_device_id()) {
      total_size += 1 + 8;
    }

    // optional bytes gcm_registration_id = 102;
    if (has_gcm_registration_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->gcm_registration_id());
    }

    // optional bytes apn_registration_id = 202;
    if (has_apn_registration_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->apn_registration_id());
    }

    // optional bool apn_notification_enabled = 203 [default = false];
    if (has_apn_notification_enabled()) {
      total_size += 2 + 1;
    }

    // optional string bluetooth_mac_address = 302;
    if (has_bluetooth_mac_address()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bluetooth_mac_address());
    }

    // optional bytes device_master_key_hash = 103;
    if (has_device_master_key_hash()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->device_master_key_hash());
    }

    // optional string device_model = 7;
    if (has_device_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_model());
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional string locale = 8;
    if (has_locale()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->locale());
    }

    // optional bytes key_handle = 9;
    if (has_key_handle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key_handle());
    }

    // optional int64 counter = 12 [default = 0];
    if (has_counter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->counter());
    }

    // optional string device_os_version = 13;
    if (has_device_os_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_os_version());
    }

    // optional int64 device_os_version_code = 14;
    if (has_device_os_version_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->device_os_version_code());
    }

    // optional string device_os_release = 15;
    if (has_device_os_release()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_os_release());
    }

    // optional string device_os_codename = 16;
    if (has_device_os_codename()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_os_codename());
    }

    // optional string device_software_version = 17;
    if (has_device_software_version()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_software_version());
    }

  }
  if (_has_bits_[16 / 32] & 16711680u) {
    // optional int64 device_software_version_code = 18;
    if (has_device_software_version_code()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->device_software_version_code());
    }

    // optional string device_software_package = 19;
    if (has_device_software_package()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_software_package());
    }

    // optional int32 device_display_diagonal_mils = 22;
    if (has_device_display_diagonal_mils()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->device_display_diagonal_mils());
    }

    // optional int32 device_authzen_version = 24;
    if (has_device_authzen_version()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->device_authzen_version());
    }

    // optional bytes long_device_id = 29;
    if (has_long_device_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->long_device_id());
    }

    // optional string device_manufacturer = 31;
    if (has_device_manufacturer()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_manufacturer());
    }

    // optional .cryptauth.DeviceType device_type = 32 [default = ANDROIDOS];
    if (has_device_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->device_type());
    }

    // optional bool using_secure_screenlock = 400 [default = false];
    if (has_using_secure_screenlock()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[24 / 32] & 1056964608u) {
    // optional bool auto_unlock_screenlock_supported = 401 [default = false];
    if (has_auto_unlock_screenlock_supported()) {
      total_size += 2 + 1;
    }

    // optional bool auto_unlock_screenlock_enabled = 402 [default = false];
    if (has_auto_unlock_screenlock_enabled()) {
      total_size += 2 + 1;
    }

    // optional bool bluetooth_radio_supported = 403 [default = false];
    if (has_bluetooth_radio_supported()) {
      total_size += 2 + 1;
    }

    // optional bool bluetooth_radio_enabled = 404 [default = false];
    if (has_bluetooth_radio_enabled()) {
      total_size += 2 + 1;
    }

    // optional bytes enrollment_session_id = 1000;
    if (has_enrollment_session_id()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->enrollment_session_id());
    }

    // optional string oauth_token = 1001;
    if (has_oauth_token()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->oauth_token());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GcmDeviceInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GcmDeviceInfo*>(&from));
}

void GcmDeviceInfo::MergeFrom(const GcmDeviceInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.GcmDeviceInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_android_device_id()) {
      set_android_device_id(from.android_device_id());
    }
    if (from.has_gcm_registration_id()) {
      set_has_gcm_registration_id();
      gcm_registration_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gcm_registration_id_);
    }
    if (from.has_apn_registration_id()) {
      set_has_apn_registration_id();
      apn_registration_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.apn_registration_id_);
    }
    if (from.has_apn_notification_enabled()) {
      set_apn_notification_enabled(from.apn_notification_enabled());
    }
    if (from.has_bluetooth_mac_address()) {
      set_has_bluetooth_mac_address();
      bluetooth_mac_address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.bluetooth_mac_address_);
    }
    if (from.has_device_master_key_hash()) {
      set_has_device_master_key_hash();
      device_master_key_hash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_master_key_hash_);
    }
    if (from.has_user_public_key()) {
      set_has_user_public_key();
      user_public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_public_key_);
    }
    if (from.has_device_model()) {
      set_has_device_model();
      device_model_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_model_);
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_locale()) {
      set_has_locale();
      locale_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.locale_);
    }
    if (from.has_key_handle()) {
      set_has_key_handle();
      key_handle_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_handle_);
    }
    if (from.has_counter()) {
      set_counter(from.counter());
    }
    if (from.has_device_os_version()) {
      set_has_device_os_version();
      device_os_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_os_version_);
    }
    if (from.has_device_os_version_code()) {
      set_device_os_version_code(from.device_os_version_code());
    }
    if (from.has_device_os_release()) {
      set_has_device_os_release();
      device_os_release_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_os_release_);
    }
    if (from.has_device_os_codename()) {
      set_has_device_os_codename();
      device_os_codename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_os_codename_);
    }
    if (from.has_device_software_version()) {
      set_has_device_software_version();
      device_software_version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_software_version_);
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_device_software_version_code()) {
      set_device_software_version_code(from.device_software_version_code());
    }
    if (from.has_device_software_package()) {
      set_has_device_software_package();
      device_software_package_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_software_package_);
    }
    if (from.has_device_display_diagonal_mils()) {
      set_device_display_diagonal_mils(from.device_display_diagonal_mils());
    }
    if (from.has_device_authzen_version()) {
      set_device_authzen_version(from.device_authzen_version());
    }
    if (from.has_long_device_id()) {
      set_has_long_device_id();
      long_device_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.long_device_id_);
    }
    if (from.has_device_manufacturer()) {
      set_has_device_manufacturer();
      device_manufacturer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_manufacturer_);
    }
    if (from.has_device_type()) {
      set_device_type(from.device_type());
    }
    if (from.has_using_secure_screenlock()) {
      set_using_secure_screenlock(from.using_secure_screenlock());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_auto_unlock_screenlock_supported()) {
      set_auto_unlock_screenlock_supported(from.auto_unlock_screenlock_supported());
    }
    if (from.has_auto_unlock_screenlock_enabled()) {
      set_auto_unlock_screenlock_enabled(from.auto_unlock_screenlock_enabled());
    }
    if (from.has_bluetooth_radio_supported()) {
      set_bluetooth_radio_supported(from.bluetooth_radio_supported());
    }
    if (from.has_bluetooth_radio_enabled()) {
      set_bluetooth_radio_enabled(from.bluetooth_radio_enabled());
    }
    if (from.has_enrollment_session_id()) {
      set_has_enrollment_session_id();
      enrollment_session_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.enrollment_session_id_);
    }
    if (from.has_oauth_token()) {
      set_has_oauth_token();
      oauth_token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.oauth_token_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GcmDeviceInfo::CopyFrom(const GcmDeviceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.GcmDeviceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GcmDeviceInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000040) != 0x00000040) return false;

  return true;
}

void GcmDeviceInfo::Swap(GcmDeviceInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GcmDeviceInfo::InternalSwap(GcmDeviceInfo* other) {
  std::swap(android_device_id_, other->android_device_id_);
  gcm_registration_id_.Swap(&other->gcm_registration_id_);
  apn_registration_id_.Swap(&other->apn_registration_id_);
  std::swap(apn_notification_enabled_, other->apn_notification_enabled_);
  bluetooth_mac_address_.Swap(&other->bluetooth_mac_address_);
  device_master_key_hash_.Swap(&other->device_master_key_hash_);
  user_public_key_.Swap(&other->user_public_key_);
  device_model_.Swap(&other->device_model_);
  locale_.Swap(&other->locale_);
  key_handle_.Swap(&other->key_handle_);
  std::swap(counter_, other->counter_);
  device_os_version_.Swap(&other->device_os_version_);
  std::swap(device_os_version_code_, other->device_os_version_code_);
  device_os_release_.Swap(&other->device_os_release_);
  device_os_codename_.Swap(&other->device_os_codename_);
  device_software_version_.Swap(&other->device_software_version_);
  std::swap(device_software_version_code_, other->device_software_version_code_);
  device_software_package_.Swap(&other->device_software_package_);
  std::swap(device_display_diagonal_mils_, other->device_display_diagonal_mils_);
  std::swap(device_authzen_version_, other->device_authzen_version_);
  long_device_id_.Swap(&other->long_device_id_);
  device_manufacturer_.Swap(&other->device_manufacturer_);
  std::swap(device_type_, other->device_type_);
  std::swap(using_secure_screenlock_, other->using_secure_screenlock_);
  std::swap(auto_unlock_screenlock_supported_, other->auto_unlock_screenlock_supported_);
  std::swap(auto_unlock_screenlock_enabled_, other->auto_unlock_screenlock_enabled_);
  std::swap(bluetooth_radio_supported_, other->bluetooth_radio_supported_);
  std::swap(bluetooth_radio_enabled_, other->bluetooth_radio_enabled_);
  enrollment_session_id_.Swap(&other->enrollment_session_id_);
  oauth_token_.Swap(&other->oauth_token_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GcmDeviceInfo::GetTypeName() const {
  return "cryptauth.GcmDeviceInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GcmDeviceInfo

// optional fixed64 android_device_id = 1;
bool GcmDeviceInfo::has_android_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GcmDeviceInfo::set_has_android_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
void GcmDeviceInfo::clear_has_android_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void GcmDeviceInfo::clear_android_device_id() {
  android_device_id_ = GOOGLE_ULONGLONG(0);
  clear_has_android_device_id();
}
 ::google::protobuf::uint64 GcmDeviceInfo::android_device_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.android_device_id)
  return android_device_id_;
}
 void GcmDeviceInfo::set_android_device_id(::google::protobuf::uint64 value) {
  set_has_android_device_id();
  android_device_id_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.android_device_id)
}

// optional bytes gcm_registration_id = 102;
bool GcmDeviceInfo::has_gcm_registration_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GcmDeviceInfo::set_has_gcm_registration_id() {
  _has_bits_[0] |= 0x00000002u;
}
void GcmDeviceInfo::clear_has_gcm_registration_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void GcmDeviceInfo::clear_gcm_registration_id() {
  gcm_registration_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gcm_registration_id();
}
 const ::std::string& GcmDeviceInfo::gcm_registration_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.gcm_registration_id)
  return gcm_registration_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_gcm_registration_id(const ::std::string& value) {
  set_has_gcm_registration_id();
  gcm_registration_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.gcm_registration_id)
}
 void GcmDeviceInfo::set_gcm_registration_id(const char* value) {
  set_has_gcm_registration_id();
  gcm_registration_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.gcm_registration_id)
}
 void GcmDeviceInfo::set_gcm_registration_id(const void* value, size_t size) {
  set_has_gcm_registration_id();
  gcm_registration_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.gcm_registration_id)
}
 ::std::string* GcmDeviceInfo::mutable_gcm_registration_id() {
  set_has_gcm_registration_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.gcm_registration_id)
  return gcm_registration_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_gcm_registration_id() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.gcm_registration_id)
  clear_has_gcm_registration_id();
  return gcm_registration_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_gcm_registration_id(::std::string* gcm_registration_id) {
  if (gcm_registration_id != NULL) {
    set_has_gcm_registration_id();
  } else {
    clear_has_gcm_registration_id();
  }
  gcm_registration_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gcm_registration_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.gcm_registration_id)
}

// optional bytes apn_registration_id = 202;
bool GcmDeviceInfo::has_apn_registration_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void GcmDeviceInfo::set_has_apn_registration_id() {
  _has_bits_[0] |= 0x00000004u;
}
void GcmDeviceInfo::clear_has_apn_registration_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void GcmDeviceInfo::clear_apn_registration_id() {
  apn_registration_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_apn_registration_id();
}
 const ::std::string& GcmDeviceInfo::apn_registration_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.apn_registration_id)
  return apn_registration_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_apn_registration_id(const ::std::string& value) {
  set_has_apn_registration_id();
  apn_registration_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.apn_registration_id)
}
 void GcmDeviceInfo::set_apn_registration_id(const char* value) {
  set_has_apn_registration_id();
  apn_registration_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.apn_registration_id)
}
 void GcmDeviceInfo::set_apn_registration_id(const void* value, size_t size) {
  set_has_apn_registration_id();
  apn_registration_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.apn_registration_id)
}
 ::std::string* GcmDeviceInfo::mutable_apn_registration_id() {
  set_has_apn_registration_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.apn_registration_id)
  return apn_registration_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_apn_registration_id() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.apn_registration_id)
  clear_has_apn_registration_id();
  return apn_registration_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_apn_registration_id(::std::string* apn_registration_id) {
  if (apn_registration_id != NULL) {
    set_has_apn_registration_id();
  } else {
    clear_has_apn_registration_id();
  }
  apn_registration_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), apn_registration_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.apn_registration_id)
}

// optional bool apn_notification_enabled = 203 [default = false];
bool GcmDeviceInfo::has_apn_notification_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void GcmDeviceInfo::set_has_apn_notification_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
void GcmDeviceInfo::clear_has_apn_notification_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
void GcmDeviceInfo::clear_apn_notification_enabled() {
  apn_notification_enabled_ = false;
  clear_has_apn_notification_enabled();
}
 bool GcmDeviceInfo::apn_notification_enabled() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.apn_notification_enabled)
  return apn_notification_enabled_;
}
 void GcmDeviceInfo::set_apn_notification_enabled(bool value) {
  set_has_apn_notification_enabled();
  apn_notification_enabled_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.apn_notification_enabled)
}

// optional string bluetooth_mac_address = 302;
bool GcmDeviceInfo::has_bluetooth_mac_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void GcmDeviceInfo::set_has_bluetooth_mac_address() {
  _has_bits_[0] |= 0x00000010u;
}
void GcmDeviceInfo::clear_has_bluetooth_mac_address() {
  _has_bits_[0] &= ~0x00000010u;
}
void GcmDeviceInfo::clear_bluetooth_mac_address() {
  bluetooth_mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bluetooth_mac_address();
}
 const ::std::string& GcmDeviceInfo::bluetooth_mac_address() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
  return bluetooth_mac_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_bluetooth_mac_address(const ::std::string& value) {
  set_has_bluetooth_mac_address();
  bluetooth_mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
}
 void GcmDeviceInfo::set_bluetooth_mac_address(const char* value) {
  set_has_bluetooth_mac_address();
  bluetooth_mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
}
 void GcmDeviceInfo::set_bluetooth_mac_address(const char* value, size_t size) {
  set_has_bluetooth_mac_address();
  bluetooth_mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
}
 ::std::string* GcmDeviceInfo::mutable_bluetooth_mac_address() {
  set_has_bluetooth_mac_address();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
  return bluetooth_mac_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_bluetooth_mac_address() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
  clear_has_bluetooth_mac_address();
  return bluetooth_mac_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_bluetooth_mac_address(::std::string* bluetooth_mac_address) {
  if (bluetooth_mac_address != NULL) {
    set_has_bluetooth_mac_address();
  } else {
    clear_has_bluetooth_mac_address();
  }
  bluetooth_mac_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bluetooth_mac_address);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
}

// optional bytes device_master_key_hash = 103;
bool GcmDeviceInfo::has_device_master_key_hash() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void GcmDeviceInfo::set_has_device_master_key_hash() {
  _has_bits_[0] |= 0x00000020u;
}
void GcmDeviceInfo::clear_has_device_master_key_hash() {
  _has_bits_[0] &= ~0x00000020u;
}
void GcmDeviceInfo::clear_device_master_key_hash() {
  device_master_key_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_master_key_hash();
}
 const ::std::string& GcmDeviceInfo::device_master_key_hash() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_master_key_hash)
  return device_master_key_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_device_master_key_hash(const ::std::string& value) {
  set_has_device_master_key_hash();
  device_master_key_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_master_key_hash)
}
 void GcmDeviceInfo::set_device_master_key_hash(const char* value) {
  set_has_device_master_key_hash();
  device_master_key_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_master_key_hash)
}
 void GcmDeviceInfo::set_device_master_key_hash(const void* value, size_t size) {
  set_has_device_master_key_hash();
  device_master_key_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_master_key_hash)
}
 ::std::string* GcmDeviceInfo::mutable_device_master_key_hash() {
  set_has_device_master_key_hash();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_master_key_hash)
  return device_master_key_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_device_master_key_hash() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_master_key_hash)
  clear_has_device_master_key_hash();
  return device_master_key_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_device_master_key_hash(::std::string* device_master_key_hash) {
  if (device_master_key_hash != NULL) {
    set_has_device_master_key_hash();
  } else {
    clear_has_device_master_key_hash();
  }
  device_master_key_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_master_key_hash);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_master_key_hash)
}

// required bytes user_public_key = 4;
bool GcmDeviceInfo::has_user_public_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void GcmDeviceInfo::set_has_user_public_key() {
  _has_bits_[0] |= 0x00000040u;
}
void GcmDeviceInfo::clear_has_user_public_key() {
  _has_bits_[0] &= ~0x00000040u;
}
void GcmDeviceInfo::clear_user_public_key() {
  user_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_public_key();
}
 const ::std::string& GcmDeviceInfo::user_public_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.user_public_key)
  return user_public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_user_public_key(const ::std::string& value) {
  set_has_user_public_key();
  user_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.user_public_key)
}
 void GcmDeviceInfo::set_user_public_key(const char* value) {
  set_has_user_public_key();
  user_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.user_public_key)
}
 void GcmDeviceInfo::set_user_public_key(const void* value, size_t size) {
  set_has_user_public_key();
  user_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.user_public_key)
}
 ::std::string* GcmDeviceInfo::mutable_user_public_key() {
  set_has_user_public_key();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.user_public_key)
  return user_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_user_public_key() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.user_public_key)
  clear_has_user_public_key();
  return user_public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_user_public_key(::std::string* user_public_key) {
  if (user_public_key != NULL) {
    set_has_user_public_key();
  } else {
    clear_has_user_public_key();
  }
  user_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_public_key);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.user_public_key)
}

// optional string device_model = 7;
bool GcmDeviceInfo::has_device_model() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void GcmDeviceInfo::set_has_device_model() {
  _has_bits_[0] |= 0x00000080u;
}
void GcmDeviceInfo::clear_has_device_model() {
  _has_bits_[0] &= ~0x00000080u;
}
void GcmDeviceInfo::clear_device_model() {
  device_model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_model();
}
 const ::std::string& GcmDeviceInfo::device_model() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_model)
  return device_model_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_device_model(const ::std::string& value) {
  set_has_device_model();
  device_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_model)
}
 void GcmDeviceInfo::set_device_model(const char* value) {
  set_has_device_model();
  device_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_model)
}
 void GcmDeviceInfo::set_device_model(const char* value, size_t size) {
  set_has_device_model();
  device_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_model)
}
 ::std::string* GcmDeviceInfo::mutable_device_model() {
  set_has_device_model();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_model)
  return device_model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_device_model() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_model)
  clear_has_device_model();
  return device_model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_device_model(::std::string* device_model) {
  if (device_model != NULL) {
    set_has_device_model();
  } else {
    clear_has_device_model();
  }
  device_model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_model);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_model)
}

// optional string locale = 8;
bool GcmDeviceInfo::has_locale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void GcmDeviceInfo::set_has_locale() {
  _has_bits_[0] |= 0x00000100u;
}
void GcmDeviceInfo::clear_has_locale() {
  _has_bits_[0] &= ~0x00000100u;
}
void GcmDeviceInfo::clear_locale() {
  locale_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_locale();
}
 const ::std::string& GcmDeviceInfo::locale() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.locale)
  return locale_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_locale(const ::std::string& value) {
  set_has_locale();
  locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.locale)
}
 void GcmDeviceInfo::set_locale(const char* value) {
  set_has_locale();
  locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.locale)
}
 void GcmDeviceInfo::set_locale(const char* value, size_t size) {
  set_has_locale();
  locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.locale)
}
 ::std::string* GcmDeviceInfo::mutable_locale() {
  set_has_locale();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.locale)
  return locale_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_locale() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.locale)
  clear_has_locale();
  return locale_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_locale(::std::string* locale) {
  if (locale != NULL) {
    set_has_locale();
  } else {
    clear_has_locale();
  }
  locale_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), locale);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.locale)
}

// optional bytes key_handle = 9;
bool GcmDeviceInfo::has_key_handle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void GcmDeviceInfo::set_has_key_handle() {
  _has_bits_[0] |= 0x00000200u;
}
void GcmDeviceInfo::clear_has_key_handle() {
  _has_bits_[0] &= ~0x00000200u;
}
void GcmDeviceInfo::clear_key_handle() {
  key_handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key_handle();
}
 const ::std::string& GcmDeviceInfo::key_handle() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.key_handle)
  return key_handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_key_handle(const ::std::string& value) {
  set_has_key_handle();
  key_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.key_handle)
}
 void GcmDeviceInfo::set_key_handle(const char* value) {
  set_has_key_handle();
  key_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.key_handle)
}
 void GcmDeviceInfo::set_key_handle(const void* value, size_t size) {
  set_has_key_handle();
  key_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.key_handle)
}
 ::std::string* GcmDeviceInfo::mutable_key_handle() {
  set_has_key_handle();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.key_handle)
  return key_handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_key_handle() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.key_handle)
  clear_has_key_handle();
  return key_handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_key_handle(::std::string* key_handle) {
  if (key_handle != NULL) {
    set_has_key_handle();
  } else {
    clear_has_key_handle();
  }
  key_handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_handle);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.key_handle)
}

// optional int64 counter = 12 [default = 0];
bool GcmDeviceInfo::has_counter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void GcmDeviceInfo::set_has_counter() {
  _has_bits_[0] |= 0x00000400u;
}
void GcmDeviceInfo::clear_has_counter() {
  _has_bits_[0] &= ~0x00000400u;
}
void GcmDeviceInfo::clear_counter() {
  counter_ = GOOGLE_LONGLONG(0);
  clear_has_counter();
}
 ::google::protobuf::int64 GcmDeviceInfo::counter() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.counter)
  return counter_;
}
 void GcmDeviceInfo::set_counter(::google::protobuf::int64 value) {
  set_has_counter();
  counter_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.counter)
}

// optional string device_os_version = 13;
bool GcmDeviceInfo::has_device_os_version() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void GcmDeviceInfo::set_has_device_os_version() {
  _has_bits_[0] |= 0x00000800u;
}
void GcmDeviceInfo::clear_has_device_os_version() {
  _has_bits_[0] &= ~0x00000800u;
}
void GcmDeviceInfo::clear_device_os_version() {
  device_os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_os_version();
}
 const ::std::string& GcmDeviceInfo::device_os_version() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_os_version)
  return device_os_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_device_os_version(const ::std::string& value) {
  set_has_device_os_version();
  device_os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_os_version)
}
 void GcmDeviceInfo::set_device_os_version(const char* value) {
  set_has_device_os_version();
  device_os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_os_version)
}
 void GcmDeviceInfo::set_device_os_version(const char* value, size_t size) {
  set_has_device_os_version();
  device_os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_os_version)
}
 ::std::string* GcmDeviceInfo::mutable_device_os_version() {
  set_has_device_os_version();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_os_version)
  return device_os_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_device_os_version() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_os_version)
  clear_has_device_os_version();
  return device_os_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_device_os_version(::std::string* device_os_version) {
  if (device_os_version != NULL) {
    set_has_device_os_version();
  } else {
    clear_has_device_os_version();
  }
  device_os_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_os_version);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_os_version)
}

// optional int64 device_os_version_code = 14;
bool GcmDeviceInfo::has_device_os_version_code() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void GcmDeviceInfo::set_has_device_os_version_code() {
  _has_bits_[0] |= 0x00001000u;
}
void GcmDeviceInfo::clear_has_device_os_version_code() {
  _has_bits_[0] &= ~0x00001000u;
}
void GcmDeviceInfo::clear_device_os_version_code() {
  device_os_version_code_ = GOOGLE_LONGLONG(0);
  clear_has_device_os_version_code();
}
 ::google::protobuf::int64 GcmDeviceInfo::device_os_version_code() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_os_version_code)
  return device_os_version_code_;
}
 void GcmDeviceInfo::set_device_os_version_code(::google::protobuf::int64 value) {
  set_has_device_os_version_code();
  device_os_version_code_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_os_version_code)
}

// optional string device_os_release = 15;
bool GcmDeviceInfo::has_device_os_release() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void GcmDeviceInfo::set_has_device_os_release() {
  _has_bits_[0] |= 0x00002000u;
}
void GcmDeviceInfo::clear_has_device_os_release() {
  _has_bits_[0] &= ~0x00002000u;
}
void GcmDeviceInfo::clear_device_os_release() {
  device_os_release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_os_release();
}
 const ::std::string& GcmDeviceInfo::device_os_release() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_os_release)
  return device_os_release_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_device_os_release(const ::std::string& value) {
  set_has_device_os_release();
  device_os_release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_os_release)
}
 void GcmDeviceInfo::set_device_os_release(const char* value) {
  set_has_device_os_release();
  device_os_release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_os_release)
}
 void GcmDeviceInfo::set_device_os_release(const char* value, size_t size) {
  set_has_device_os_release();
  device_os_release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_os_release)
}
 ::std::string* GcmDeviceInfo::mutable_device_os_release() {
  set_has_device_os_release();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_os_release)
  return device_os_release_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_device_os_release() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_os_release)
  clear_has_device_os_release();
  return device_os_release_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_device_os_release(::std::string* device_os_release) {
  if (device_os_release != NULL) {
    set_has_device_os_release();
  } else {
    clear_has_device_os_release();
  }
  device_os_release_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_os_release);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_os_release)
}

// optional string device_os_codename = 16;
bool GcmDeviceInfo::has_device_os_codename() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void GcmDeviceInfo::set_has_device_os_codename() {
  _has_bits_[0] |= 0x00004000u;
}
void GcmDeviceInfo::clear_has_device_os_codename() {
  _has_bits_[0] &= ~0x00004000u;
}
void GcmDeviceInfo::clear_device_os_codename() {
  device_os_codename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_os_codename();
}
 const ::std::string& GcmDeviceInfo::device_os_codename() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_os_codename)
  return device_os_codename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_device_os_codename(const ::std::string& value) {
  set_has_device_os_codename();
  device_os_codename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_os_codename)
}
 void GcmDeviceInfo::set_device_os_codename(const char* value) {
  set_has_device_os_codename();
  device_os_codename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_os_codename)
}
 void GcmDeviceInfo::set_device_os_codename(const char* value, size_t size) {
  set_has_device_os_codename();
  device_os_codename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_os_codename)
}
 ::std::string* GcmDeviceInfo::mutable_device_os_codename() {
  set_has_device_os_codename();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_os_codename)
  return device_os_codename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_device_os_codename() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_os_codename)
  clear_has_device_os_codename();
  return device_os_codename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_device_os_codename(::std::string* device_os_codename) {
  if (device_os_codename != NULL) {
    set_has_device_os_codename();
  } else {
    clear_has_device_os_codename();
  }
  device_os_codename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_os_codename);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_os_codename)
}

// optional string device_software_version = 17;
bool GcmDeviceInfo::has_device_software_version() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void GcmDeviceInfo::set_has_device_software_version() {
  _has_bits_[0] |= 0x00008000u;
}
void GcmDeviceInfo::clear_has_device_software_version() {
  _has_bits_[0] &= ~0x00008000u;
}
void GcmDeviceInfo::clear_device_software_version() {
  device_software_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_software_version();
}
 const ::std::string& GcmDeviceInfo::device_software_version() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_software_version)
  return device_software_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_device_software_version(const ::std::string& value) {
  set_has_device_software_version();
  device_software_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_software_version)
}
 void GcmDeviceInfo::set_device_software_version(const char* value) {
  set_has_device_software_version();
  device_software_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_software_version)
}
 void GcmDeviceInfo::set_device_software_version(const char* value, size_t size) {
  set_has_device_software_version();
  device_software_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_software_version)
}
 ::std::string* GcmDeviceInfo::mutable_device_software_version() {
  set_has_device_software_version();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_software_version)
  return device_software_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_device_software_version() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_software_version)
  clear_has_device_software_version();
  return device_software_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_device_software_version(::std::string* device_software_version) {
  if (device_software_version != NULL) {
    set_has_device_software_version();
  } else {
    clear_has_device_software_version();
  }
  device_software_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_software_version);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_software_version)
}

// optional int64 device_software_version_code = 18;
bool GcmDeviceInfo::has_device_software_version_code() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void GcmDeviceInfo::set_has_device_software_version_code() {
  _has_bits_[0] |= 0x00010000u;
}
void GcmDeviceInfo::clear_has_device_software_version_code() {
  _has_bits_[0] &= ~0x00010000u;
}
void GcmDeviceInfo::clear_device_software_version_code() {
  device_software_version_code_ = GOOGLE_LONGLONG(0);
  clear_has_device_software_version_code();
}
 ::google::protobuf::int64 GcmDeviceInfo::device_software_version_code() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_software_version_code)
  return device_software_version_code_;
}
 void GcmDeviceInfo::set_device_software_version_code(::google::protobuf::int64 value) {
  set_has_device_software_version_code();
  device_software_version_code_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_software_version_code)
}

// optional string device_software_package = 19;
bool GcmDeviceInfo::has_device_software_package() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void GcmDeviceInfo::set_has_device_software_package() {
  _has_bits_[0] |= 0x00020000u;
}
void GcmDeviceInfo::clear_has_device_software_package() {
  _has_bits_[0] &= ~0x00020000u;
}
void GcmDeviceInfo::clear_device_software_package() {
  device_software_package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_software_package();
}
 const ::std::string& GcmDeviceInfo::device_software_package() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_software_package)
  return device_software_package_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_device_software_package(const ::std::string& value) {
  set_has_device_software_package();
  device_software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_software_package)
}
 void GcmDeviceInfo::set_device_software_package(const char* value) {
  set_has_device_software_package();
  device_software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_software_package)
}
 void GcmDeviceInfo::set_device_software_package(const char* value, size_t size) {
  set_has_device_software_package();
  device_software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_software_package)
}
 ::std::string* GcmDeviceInfo::mutable_device_software_package() {
  set_has_device_software_package();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_software_package)
  return device_software_package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_device_software_package() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_software_package)
  clear_has_device_software_package();
  return device_software_package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_device_software_package(::std::string* device_software_package) {
  if (device_software_package != NULL) {
    set_has_device_software_package();
  } else {
    clear_has_device_software_package();
  }
  device_software_package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_software_package);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_software_package)
}

// optional int32 device_display_diagonal_mils = 22;
bool GcmDeviceInfo::has_device_display_diagonal_mils() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void GcmDeviceInfo::set_has_device_display_diagonal_mils() {
  _has_bits_[0] |= 0x00040000u;
}
void GcmDeviceInfo::clear_has_device_display_diagonal_mils() {
  _has_bits_[0] &= ~0x00040000u;
}
void GcmDeviceInfo::clear_device_display_diagonal_mils() {
  device_display_diagonal_mils_ = 0;
  clear_has_device_display_diagonal_mils();
}
 ::google::protobuf::int32 GcmDeviceInfo::device_display_diagonal_mils() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_display_diagonal_mils)
  return device_display_diagonal_mils_;
}
 void GcmDeviceInfo::set_device_display_diagonal_mils(::google::protobuf::int32 value) {
  set_has_device_display_diagonal_mils();
  device_display_diagonal_mils_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_display_diagonal_mils)
}

// optional int32 device_authzen_version = 24;
bool GcmDeviceInfo::has_device_authzen_version() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void GcmDeviceInfo::set_has_device_authzen_version() {
  _has_bits_[0] |= 0x00080000u;
}
void GcmDeviceInfo::clear_has_device_authzen_version() {
  _has_bits_[0] &= ~0x00080000u;
}
void GcmDeviceInfo::clear_device_authzen_version() {
  device_authzen_version_ = 0;
  clear_has_device_authzen_version();
}
 ::google::protobuf::int32 GcmDeviceInfo::device_authzen_version() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_authzen_version)
  return device_authzen_version_;
}
 void GcmDeviceInfo::set_device_authzen_version(::google::protobuf::int32 value) {
  set_has_device_authzen_version();
  device_authzen_version_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_authzen_version)
}

// optional bytes long_device_id = 29;
bool GcmDeviceInfo::has_long_device_id() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void GcmDeviceInfo::set_has_long_device_id() {
  _has_bits_[0] |= 0x00100000u;
}
void GcmDeviceInfo::clear_has_long_device_id() {
  _has_bits_[0] &= ~0x00100000u;
}
void GcmDeviceInfo::clear_long_device_id() {
  long_device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_long_device_id();
}
 const ::std::string& GcmDeviceInfo::long_device_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.long_device_id)
  return long_device_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_long_device_id(const ::std::string& value) {
  set_has_long_device_id();
  long_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.long_device_id)
}
 void GcmDeviceInfo::set_long_device_id(const char* value) {
  set_has_long_device_id();
  long_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.long_device_id)
}
 void GcmDeviceInfo::set_long_device_id(const void* value, size_t size) {
  set_has_long_device_id();
  long_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.long_device_id)
}
 ::std::string* GcmDeviceInfo::mutable_long_device_id() {
  set_has_long_device_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.long_device_id)
  return long_device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_long_device_id() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.long_device_id)
  clear_has_long_device_id();
  return long_device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_long_device_id(::std::string* long_device_id) {
  if (long_device_id != NULL) {
    set_has_long_device_id();
  } else {
    clear_has_long_device_id();
  }
  long_device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), long_device_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.long_device_id)
}

// optional string device_manufacturer = 31;
bool GcmDeviceInfo::has_device_manufacturer() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void GcmDeviceInfo::set_has_device_manufacturer() {
  _has_bits_[0] |= 0x00200000u;
}
void GcmDeviceInfo::clear_has_device_manufacturer() {
  _has_bits_[0] &= ~0x00200000u;
}
void GcmDeviceInfo::clear_device_manufacturer() {
  device_manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_manufacturer();
}
 const ::std::string& GcmDeviceInfo::device_manufacturer() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_manufacturer)
  return device_manufacturer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_device_manufacturer(const ::std::string& value) {
  set_has_device_manufacturer();
  device_manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_manufacturer)
}
 void GcmDeviceInfo::set_device_manufacturer(const char* value) {
  set_has_device_manufacturer();
  device_manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_manufacturer)
}
 void GcmDeviceInfo::set_device_manufacturer(const char* value, size_t size) {
  set_has_device_manufacturer();
  device_manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_manufacturer)
}
 ::std::string* GcmDeviceInfo::mutable_device_manufacturer() {
  set_has_device_manufacturer();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_manufacturer)
  return device_manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_device_manufacturer() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_manufacturer)
  clear_has_device_manufacturer();
  return device_manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_device_manufacturer(::std::string* device_manufacturer) {
  if (device_manufacturer != NULL) {
    set_has_device_manufacturer();
  } else {
    clear_has_device_manufacturer();
  }
  device_manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_manufacturer);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_manufacturer)
}

// optional .cryptauth.DeviceType device_type = 32 [default = ANDROIDOS];
bool GcmDeviceInfo::has_device_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
void GcmDeviceInfo::set_has_device_type() {
  _has_bits_[0] |= 0x00400000u;
}
void GcmDeviceInfo::clear_has_device_type() {
  _has_bits_[0] &= ~0x00400000u;
}
void GcmDeviceInfo::clear_device_type() {
  device_type_ = 1;
  clear_has_device_type();
}
 ::cryptauth::DeviceType GcmDeviceInfo::device_type() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_type)
  return static_cast< ::cryptauth::DeviceType >(device_type_);
}
 void GcmDeviceInfo::set_device_type(::cryptauth::DeviceType value) {
  assert(::cryptauth::DeviceType_IsValid(value));
  set_has_device_type();
  device_type_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_type)
}

// optional bool using_secure_screenlock = 400 [default = false];
bool GcmDeviceInfo::has_using_secure_screenlock() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void GcmDeviceInfo::set_has_using_secure_screenlock() {
  _has_bits_[0] |= 0x00800000u;
}
void GcmDeviceInfo::clear_has_using_secure_screenlock() {
  _has_bits_[0] &= ~0x00800000u;
}
void GcmDeviceInfo::clear_using_secure_screenlock() {
  using_secure_screenlock_ = false;
  clear_has_using_secure_screenlock();
}
 bool GcmDeviceInfo::using_secure_screenlock() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.using_secure_screenlock)
  return using_secure_screenlock_;
}
 void GcmDeviceInfo::set_using_secure_screenlock(bool value) {
  set_has_using_secure_screenlock();
  using_secure_screenlock_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.using_secure_screenlock)
}

// optional bool auto_unlock_screenlock_supported = 401 [default = false];
bool GcmDeviceInfo::has_auto_unlock_screenlock_supported() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
void GcmDeviceInfo::set_has_auto_unlock_screenlock_supported() {
  _has_bits_[0] |= 0x01000000u;
}
void GcmDeviceInfo::clear_has_auto_unlock_screenlock_supported() {
  _has_bits_[0] &= ~0x01000000u;
}
void GcmDeviceInfo::clear_auto_unlock_screenlock_supported() {
  auto_unlock_screenlock_supported_ = false;
  clear_has_auto_unlock_screenlock_supported();
}
 bool GcmDeviceInfo::auto_unlock_screenlock_supported() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.auto_unlock_screenlock_supported)
  return auto_unlock_screenlock_supported_;
}
 void GcmDeviceInfo::set_auto_unlock_screenlock_supported(bool value) {
  set_has_auto_unlock_screenlock_supported();
  auto_unlock_screenlock_supported_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.auto_unlock_screenlock_supported)
}

// optional bool auto_unlock_screenlock_enabled = 402 [default = false];
bool GcmDeviceInfo::has_auto_unlock_screenlock_enabled() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
void GcmDeviceInfo::set_has_auto_unlock_screenlock_enabled() {
  _has_bits_[0] |= 0x02000000u;
}
void GcmDeviceInfo::clear_has_auto_unlock_screenlock_enabled() {
  _has_bits_[0] &= ~0x02000000u;
}
void GcmDeviceInfo::clear_auto_unlock_screenlock_enabled() {
  auto_unlock_screenlock_enabled_ = false;
  clear_has_auto_unlock_screenlock_enabled();
}
 bool GcmDeviceInfo::auto_unlock_screenlock_enabled() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.auto_unlock_screenlock_enabled)
  return auto_unlock_screenlock_enabled_;
}
 void GcmDeviceInfo::set_auto_unlock_screenlock_enabled(bool value) {
  set_has_auto_unlock_screenlock_enabled();
  auto_unlock_screenlock_enabled_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.auto_unlock_screenlock_enabled)
}

// optional bool bluetooth_radio_supported = 403 [default = false];
bool GcmDeviceInfo::has_bluetooth_radio_supported() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
void GcmDeviceInfo::set_has_bluetooth_radio_supported() {
  _has_bits_[0] |= 0x04000000u;
}
void GcmDeviceInfo::clear_has_bluetooth_radio_supported() {
  _has_bits_[0] &= ~0x04000000u;
}
void GcmDeviceInfo::clear_bluetooth_radio_supported() {
  bluetooth_radio_supported_ = false;
  clear_has_bluetooth_radio_supported();
}
 bool GcmDeviceInfo::bluetooth_radio_supported() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.bluetooth_radio_supported)
  return bluetooth_radio_supported_;
}
 void GcmDeviceInfo::set_bluetooth_radio_supported(bool value) {
  set_has_bluetooth_radio_supported();
  bluetooth_radio_supported_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.bluetooth_radio_supported)
}

// optional bool bluetooth_radio_enabled = 404 [default = false];
bool GcmDeviceInfo::has_bluetooth_radio_enabled() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
void GcmDeviceInfo::set_has_bluetooth_radio_enabled() {
  _has_bits_[0] |= 0x08000000u;
}
void GcmDeviceInfo::clear_has_bluetooth_radio_enabled() {
  _has_bits_[0] &= ~0x08000000u;
}
void GcmDeviceInfo::clear_bluetooth_radio_enabled() {
  bluetooth_radio_enabled_ = false;
  clear_has_bluetooth_radio_enabled();
}
 bool GcmDeviceInfo::bluetooth_radio_enabled() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.bluetooth_radio_enabled)
  return bluetooth_radio_enabled_;
}
 void GcmDeviceInfo::set_bluetooth_radio_enabled(bool value) {
  set_has_bluetooth_radio_enabled();
  bluetooth_radio_enabled_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.bluetooth_radio_enabled)
}

// optional bytes enrollment_session_id = 1000;
bool GcmDeviceInfo::has_enrollment_session_id() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
void GcmDeviceInfo::set_has_enrollment_session_id() {
  _has_bits_[0] |= 0x10000000u;
}
void GcmDeviceInfo::clear_has_enrollment_session_id() {
  _has_bits_[0] &= ~0x10000000u;
}
void GcmDeviceInfo::clear_enrollment_session_id() {
  enrollment_session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_enrollment_session_id();
}
 const ::std::string& GcmDeviceInfo::enrollment_session_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.enrollment_session_id)
  return enrollment_session_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_enrollment_session_id(const ::std::string& value) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.enrollment_session_id)
}
 void GcmDeviceInfo::set_enrollment_session_id(const char* value) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.enrollment_session_id)
}
 void GcmDeviceInfo::set_enrollment_session_id(const void* value, size_t size) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.enrollment_session_id)
}
 ::std::string* GcmDeviceInfo::mutable_enrollment_session_id() {
  set_has_enrollment_session_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.enrollment_session_id)
  return enrollment_session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_enrollment_session_id() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.enrollment_session_id)
  clear_has_enrollment_session_id();
  return enrollment_session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_enrollment_session_id(::std::string* enrollment_session_id) {
  if (enrollment_session_id != NULL) {
    set_has_enrollment_session_id();
  } else {
    clear_has_enrollment_session_id();
  }
  enrollment_session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enrollment_session_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.enrollment_session_id)
}

// optional string oauth_token = 1001;
bool GcmDeviceInfo::has_oauth_token() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
void GcmDeviceInfo::set_has_oauth_token() {
  _has_bits_[0] |= 0x20000000u;
}
void GcmDeviceInfo::clear_has_oauth_token() {
  _has_bits_[0] &= ~0x20000000u;
}
void GcmDeviceInfo::clear_oauth_token() {
  oauth_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_oauth_token();
}
 const ::std::string& GcmDeviceInfo::oauth_token() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.oauth_token)
  return oauth_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_oauth_token(const ::std::string& value) {
  set_has_oauth_token();
  oauth_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.oauth_token)
}
 void GcmDeviceInfo::set_oauth_token(const char* value) {
  set_has_oauth_token();
  oauth_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.oauth_token)
}
 void GcmDeviceInfo::set_oauth_token(const char* value, size_t size) {
  set_has_oauth_token();
  oauth_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.oauth_token)
}
 ::std::string* GcmDeviceInfo::mutable_oauth_token() {
  set_has_oauth_token();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.oauth_token)
  return oauth_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GcmDeviceInfo::release_oauth_token() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.oauth_token)
  clear_has_oauth_token();
  return oauth_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GcmDeviceInfo::set_allocated_oauth_token(::std::string* oauth_token) {
  if (oauth_token != NULL) {
    set_has_oauth_token();
  } else {
    clear_has_oauth_token();
  }
  oauth_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oauth_token);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.oauth_token)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForGcmMetadata(
    GcmMetadata* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GcmMetadata::kTypeFieldNumber;
const int GcmMetadata::kVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GcmMetadata::GcmMetadata()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.GcmMetadata)
}

void GcmMetadata::InitAsDefaultInstance() {
}

GcmMetadata::GcmMetadata(const GcmMetadata& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.GcmMetadata)
}

void GcmMetadata::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  version_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GcmMetadata::~GcmMetadata() {
  // @@protoc_insertion_point(destructor:cryptauth.GcmMetadata)
  SharedDtor();
}

void GcmMetadata::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GcmMetadata::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GcmMetadata& GcmMetadata::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

GcmMetadata* GcmMetadata::default_instance_ = NULL;

GcmMetadata* GcmMetadata::New(::google::protobuf::Arena* arena) const {
  GcmMetadata* n = new GcmMetadata;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GcmMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.GcmMetadata)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(GcmMetadata, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<GcmMetadata*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(type_, version_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GcmMetadata::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGcmMetadata, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.GcmMetadata)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .cryptauth.MessageType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cryptauth::MessageType_IsValid(value)) {
            set_type(static_cast< ::cryptauth::MessageType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_version;
        break;
      }

      // optional int32 version = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.GcmMetadata)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.GcmMetadata)
  return false;
#undef DO_
}

void GcmMetadata::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.GcmMetadata)
  // required .cryptauth.MessageType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional int32 version = 2 [default = 0];
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->version(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.GcmMetadata)
}

int GcmMetadata::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.GcmMetadata)
  int total_size = 0;

  // required .cryptauth.MessageType type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }
  // optional int32 version = 2 [default = 0];
  if (has_version()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->version());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GcmMetadata::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GcmMetadata*>(&from));
}

void GcmMetadata::MergeFrom(const GcmMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.GcmMetadata)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GcmMetadata::CopyFrom(const GcmMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.GcmMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GcmMetadata::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GcmMetadata::Swap(GcmMetadata* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GcmMetadata::InternalSwap(GcmMetadata* other) {
  std::swap(type_, other->type_);
  std::swap(version_, other->version_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GcmMetadata::GetTypeName() const {
  return "cryptauth.GcmMetadata";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GcmMetadata

// required .cryptauth.MessageType type = 1;
bool GcmMetadata::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GcmMetadata::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void GcmMetadata::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void GcmMetadata::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::cryptauth::MessageType GcmMetadata::type() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmMetadata.type)
  return static_cast< ::cryptauth::MessageType >(type_);
}
 void GcmMetadata::set_type(::cryptauth::MessageType value) {
  assert(::cryptauth::MessageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmMetadata.type)
}

// optional int32 version = 2 [default = 0];
bool GcmMetadata::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GcmMetadata::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
void GcmMetadata::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
void GcmMetadata::clear_version() {
  version_ = 0;
  clear_has_version();
}
 ::google::protobuf::int32 GcmMetadata::version() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmMetadata.version)
  return version_;
}
 void GcmMetadata::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmMetadata.version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForGetMyDevicesRequest(
    GetMyDevicesRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetMyDevicesRequest::kApprovedForUnlockRequiredFieldNumber;
const int GetMyDevicesRequest::kAllowStaleReadFieldNumber;
const int GetMyDevicesRequest::kInvocationReasonFieldNumber;
const int GetMyDevicesRequest::kRetryCountFieldNumber;
const int GetMyDevicesRequest::kDeviceClassifierFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetMyDevicesRequest::GetMyDevicesRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.GetMyDevicesRequest)
}

void GetMyDevicesRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(
      ::cryptauth::DeviceClassifier::internal_default_instance());
#else
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(&::cryptauth::DeviceClassifier::default_instance());
#endif
}

GetMyDevicesRequest::GetMyDevicesRequest(const GetMyDevicesRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.GetMyDevicesRequest)
}

void GetMyDevicesRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  approved_for_unlock_required_ = false;
  allow_stale_read_ = false;
  invocation_reason_ = 0;
  retry_count_ = 0;
  device_classifier_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetMyDevicesRequest::~GetMyDevicesRequest() {
  // @@protoc_insertion_point(destructor:cryptauth.GetMyDevicesRequest)
  SharedDtor();
}

void GetMyDevicesRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete device_classifier_;
  }
}

void GetMyDevicesRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetMyDevicesRequest& GetMyDevicesRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

GetMyDevicesRequest* GetMyDevicesRequest::default_instance_ = NULL;

GetMyDevicesRequest* GetMyDevicesRequest::New(::google::protobuf::Arena* arena) const {
  GetMyDevicesRequest* n = new GetMyDevicesRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetMyDevicesRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.GetMyDevicesRequest)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(GetMyDevicesRequest, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<GetMyDevicesRequest*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(approved_for_unlock_required_, invocation_reason_);
    retry_count_ = 0;
    if (has_device_classifier()) {
      if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GetMyDevicesRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGetMyDevicesRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.GetMyDevicesRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool approved_for_unlock_required = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &approved_for_unlock_required_)));
          set_has_approved_for_unlock_required();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_allow_stale_read;
        break;
      }

      // optional bool allow_stale_read = 3 [default = false];
      case 3: {
        if (tag == 24) {
         parse_allow_stale_read:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &allow_stale_read_)));
          set_has_allow_stale_read();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_invocation_reason;
        break;
      }

      // optional int32 invocation_reason = 4 [default = 0];
      case 4: {
        if (tag == 32) {
         parse_invocation_reason:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &invocation_reason_)));
          set_has_invocation_reason();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_retry_count;
        break;
      }

      // optional int32 retry_count = 5 [default = 0];
      case 5: {
        if (tag == 40) {
         parse_retry_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &retry_count_)));
          set_has_retry_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_device_classifier;
        break;
      }

      // optional .cryptauth.DeviceClassifier device_classifier = 6;
      case 6: {
        if (tag == 50) {
         parse_device_classifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_device_classifier()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.GetMyDevicesRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.GetMyDevicesRequest)
  return false;
#undef DO_
}

void GetMyDevicesRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.GetMyDevicesRequest)
  // optional bool approved_for_unlock_required = 2;
  if (has_approved_for_unlock_required()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->approved_for_unlock_required(), output);
  }

  // optional bool allow_stale_read = 3 [default = false];
  if (has_allow_stale_read()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->allow_stale_read(), output);
  }

  // optional int32 invocation_reason = 4 [default = 0];
  if (has_invocation_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->invocation_reason(), output);
  }

  // optional int32 retry_count = 5 [default = 0];
  if (has_retry_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->retry_count(), output);
  }

  // optional .cryptauth.DeviceClassifier device_classifier = 6;
  if (has_device_classifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->device_classifier_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.GetMyDevicesRequest)
}

int GetMyDevicesRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.GetMyDevicesRequest)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional bool approved_for_unlock_required = 2;
    if (has_approved_for_unlock_required()) {
      total_size += 1 + 1;
    }

    // optional bool allow_stale_read = 3 [default = false];
    if (has_allow_stale_read()) {
      total_size += 1 + 1;
    }

    // optional int32 invocation_reason = 4 [default = 0];
    if (has_invocation_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->invocation_reason());
    }

    // optional int32 retry_count = 5 [default = 0];
    if (has_retry_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->retry_count());
    }

    // optional .cryptauth.DeviceClassifier device_classifier = 6;
    if (has_device_classifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->device_classifier_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetMyDevicesRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetMyDevicesRequest*>(&from));
}

void GetMyDevicesRequest::MergeFrom(const GetMyDevicesRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.GetMyDevicesRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_approved_for_unlock_required()) {
      set_approved_for_unlock_required(from.approved_for_unlock_required());
    }
    if (from.has_allow_stale_read()) {
      set_allow_stale_read(from.allow_stale_read());
    }
    if (from.has_invocation_reason()) {
      set_invocation_reason(from.invocation_reason());
    }
    if (from.has_retry_count()) {
      set_retry_count(from.retry_count());
    }
    if (from.has_device_classifier()) {
      mutable_device_classifier()->::cryptauth::DeviceClassifier::MergeFrom(from.device_classifier());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GetMyDevicesRequest::CopyFrom(const GetMyDevicesRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.GetMyDevicesRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMyDevicesRequest::IsInitialized() const {

  return true;
}

void GetMyDevicesRequest::Swap(GetMyDevicesRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetMyDevicesRequest::InternalSwap(GetMyDevicesRequest* other) {
  std::swap(approved_for_unlock_required_, other->approved_for_unlock_required_);
  std::swap(allow_stale_read_, other->allow_stale_read_);
  std::swap(invocation_reason_, other->invocation_reason_);
  std::swap(retry_count_, other->retry_count_);
  std::swap(device_classifier_, other->device_classifier_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GetMyDevicesRequest::GetTypeName() const {
  return "cryptauth.GetMyDevicesRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetMyDevicesRequest

// optional bool approved_for_unlock_required = 2;
bool GetMyDevicesRequest::has_approved_for_unlock_required() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetMyDevicesRequest::set_has_approved_for_unlock_required() {
  _has_bits_[0] |= 0x00000001u;
}
void GetMyDevicesRequest::clear_has_approved_for_unlock_required() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetMyDevicesRequest::clear_approved_for_unlock_required() {
  approved_for_unlock_required_ = false;
  clear_has_approved_for_unlock_required();
}
 bool GetMyDevicesRequest::approved_for_unlock_required() const {
  // @@protoc_insertion_point(field_get:cryptauth.GetMyDevicesRequest.approved_for_unlock_required)
  return approved_for_unlock_required_;
}
 void GetMyDevicesRequest::set_approved_for_unlock_required(bool value) {
  set_has_approved_for_unlock_required();
  approved_for_unlock_required_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GetMyDevicesRequest.approved_for_unlock_required)
}

// optional bool allow_stale_read = 3 [default = false];
bool GetMyDevicesRequest::has_allow_stale_read() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetMyDevicesRequest::set_has_allow_stale_read() {
  _has_bits_[0] |= 0x00000002u;
}
void GetMyDevicesRequest::clear_has_allow_stale_read() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetMyDevicesRequest::clear_allow_stale_read() {
  allow_stale_read_ = false;
  clear_has_allow_stale_read();
}
 bool GetMyDevicesRequest::allow_stale_read() const {
  // @@protoc_insertion_point(field_get:cryptauth.GetMyDevicesRequest.allow_stale_read)
  return allow_stale_read_;
}
 void GetMyDevicesRequest::set_allow_stale_read(bool value) {
  set_has_allow_stale_read();
  allow_stale_read_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GetMyDevicesRequest.allow_stale_read)
}

// optional int32 invocation_reason = 4 [default = 0];
bool GetMyDevicesRequest::has_invocation_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void GetMyDevicesRequest::set_has_invocation_reason() {
  _has_bits_[0] |= 0x00000004u;
}
void GetMyDevicesRequest::clear_has_invocation_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
void GetMyDevicesRequest::clear_invocation_reason() {
  invocation_reason_ = 0;
  clear_has_invocation_reason();
}
 ::google::protobuf::int32 GetMyDevicesRequest::invocation_reason() const {
  // @@protoc_insertion_point(field_get:cryptauth.GetMyDevicesRequest.invocation_reason)
  return invocation_reason_;
}
 void GetMyDevicesRequest::set_invocation_reason(::google::protobuf::int32 value) {
  set_has_invocation_reason();
  invocation_reason_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GetMyDevicesRequest.invocation_reason)
}

// optional int32 retry_count = 5 [default = 0];
bool GetMyDevicesRequest::has_retry_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void GetMyDevicesRequest::set_has_retry_count() {
  _has_bits_[0] |= 0x00000008u;
}
void GetMyDevicesRequest::clear_has_retry_count() {
  _has_bits_[0] &= ~0x00000008u;
}
void GetMyDevicesRequest::clear_retry_count() {
  retry_count_ = 0;
  clear_has_retry_count();
}
 ::google::protobuf::int32 GetMyDevicesRequest::retry_count() const {
  // @@protoc_insertion_point(field_get:cryptauth.GetMyDevicesRequest.retry_count)
  return retry_count_;
}
 void GetMyDevicesRequest::set_retry_count(::google::protobuf::int32 value) {
  set_has_retry_count();
  retry_count_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GetMyDevicesRequest.retry_count)
}

// optional .cryptauth.DeviceClassifier device_classifier = 6;
bool GetMyDevicesRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void GetMyDevicesRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000010u;
}
void GetMyDevicesRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000010u;
}
void GetMyDevicesRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
const ::cryptauth::DeviceClassifier& GetMyDevicesRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.GetMyDevicesRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
::cryptauth::DeviceClassifier* GetMyDevicesRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.GetMyDevicesRequest.device_classifier)
  return device_classifier_;
}
::cryptauth::DeviceClassifier* GetMyDevicesRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.GetMyDevicesRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
void GetMyDevicesRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GetMyDevicesRequest.device_classifier)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForGetMyDevicesResponse(
    GetMyDevicesResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetMyDevicesResponse::kDevicesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetMyDevicesResponse::GetMyDevicesResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.GetMyDevicesResponse)
}

void GetMyDevicesResponse::InitAsDefaultInstance() {
}

GetMyDevicesResponse::GetMyDevicesResponse(const GetMyDevicesResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.GetMyDevicesResponse)
}

void GetMyDevicesResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetMyDevicesResponse::~GetMyDevicesResponse() {
  // @@protoc_insertion_point(destructor:cryptauth.GetMyDevicesResponse)
  SharedDtor();
}

void GetMyDevicesResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetMyDevicesResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetMyDevicesResponse& GetMyDevicesResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

GetMyDevicesResponse* GetMyDevicesResponse::default_instance_ = NULL;

GetMyDevicesResponse* GetMyDevicesResponse::New(::google::protobuf::Arena* arena) const {
  GetMyDevicesResponse* n = new GetMyDevicesResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetMyDevicesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.GetMyDevicesResponse)
  devices_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GetMyDevicesResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGetMyDevicesResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.GetMyDevicesResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .cryptauth.ExternalDeviceInfo devices = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_devices:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_devices()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_devices;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.GetMyDevicesResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.GetMyDevicesResponse)
  return false;
#undef DO_
}

void GetMyDevicesResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.GetMyDevicesResponse)
  // repeated .cryptauth.ExternalDeviceInfo devices = 1;
  for (unsigned int i = 0, n = this->devices_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->devices(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.GetMyDevicesResponse)
}

int GetMyDevicesResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.GetMyDevicesResponse)
  int total_size = 0;

  // repeated .cryptauth.ExternalDeviceInfo devices = 1;
  total_size += 1 * this->devices_size();
  for (int i = 0; i < this->devices_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->devices(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetMyDevicesResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetMyDevicesResponse*>(&from));
}

void GetMyDevicesResponse::MergeFrom(const GetMyDevicesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.GetMyDevicesResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  devices_.MergeFrom(from.devices_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GetMyDevicesResponse::CopyFrom(const GetMyDevicesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.GetMyDevicesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetMyDevicesResponse::IsInitialized() const {

  return true;
}

void GetMyDevicesResponse::Swap(GetMyDevicesResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetMyDevicesResponse::InternalSwap(GetMyDevicesResponse* other) {
  devices_.UnsafeArenaSwap(&other->devices_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GetMyDevicesResponse::GetTypeName() const {
  return "cryptauth.GetMyDevicesResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetMyDevicesResponse

// repeated .cryptauth.ExternalDeviceInfo devices = 1;
int GetMyDevicesResponse::devices_size() const {
  return devices_.size();
}
void GetMyDevicesResponse::clear_devices() {
  devices_.Clear();
}
const ::cryptauth::ExternalDeviceInfo& GetMyDevicesResponse::devices(int index) const {
  // @@protoc_insertion_point(field_get:cryptauth.GetMyDevicesResponse.devices)
  return devices_.Get(index);
}
::cryptauth::ExternalDeviceInfo* GetMyDevicesResponse::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:cryptauth.GetMyDevicesResponse.devices)
  return devices_.Mutable(index);
}
::cryptauth::ExternalDeviceInfo* GetMyDevicesResponse::add_devices() {
  // @@protoc_insertion_point(field_add:cryptauth.GetMyDevicesResponse.devices)
  return devices_.Add();
}
::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo >*
GetMyDevicesResponse::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:cryptauth.GetMyDevicesResponse.devices)
  return &devices_;
}
const ::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo >&
GetMyDevicesResponse::devices() const {
  // @@protoc_insertion_point(field_list:cryptauth.GetMyDevicesResponse.devices)
  return devices_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForIneligibleDevice(
    IneligibleDevice* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IneligibleDevice::kDeviceFieldNumber;
const int IneligibleDevice::kReasonsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IneligibleDevice::IneligibleDevice()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.IneligibleDevice)
}

void IneligibleDevice::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  device_ = const_cast< ::cryptauth::ExternalDeviceInfo*>(
      ::cryptauth::ExternalDeviceInfo::internal_default_instance());
#else
  device_ = const_cast< ::cryptauth::ExternalDeviceInfo*>(&::cryptauth::ExternalDeviceInfo::default_instance());
#endif
}

IneligibleDevice::IneligibleDevice(const IneligibleDevice& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.IneligibleDevice)
}

void IneligibleDevice::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IneligibleDevice::~IneligibleDevice() {
  // @@protoc_insertion_point(destructor:cryptauth.IneligibleDevice)
  SharedDtor();
}

void IneligibleDevice::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete device_;
  }
}

void IneligibleDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IneligibleDevice& IneligibleDevice::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

IneligibleDevice* IneligibleDevice::default_instance_ = NULL;

IneligibleDevice* IneligibleDevice::New(::google::protobuf::Arena* arena) const {
  IneligibleDevice* n = new IneligibleDevice;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IneligibleDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.IneligibleDevice)
  if (has_device()) {
    if (device_ != NULL) device_->::cryptauth::ExternalDeviceInfo::Clear();
  }
  reasons_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool IneligibleDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForIneligibleDevice, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.IneligibleDevice)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cryptauth.ExternalDeviceInfo device = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_device()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_reasons;
        break;
      }

      // repeated string reasons = 2;
      case 2: {
        if (tag == 18) {
         parse_reasons:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_reasons()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_reasons;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.IneligibleDevice)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.IneligibleDevice)
  return false;
#undef DO_
}

void IneligibleDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.IneligibleDevice)
  // optional .cryptauth.ExternalDeviceInfo device = 1;
  if (has_device()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->device_, output);
  }

  // repeated string reasons = 2;
  for (int i = 0; i < this->reasons_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->reasons(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.IneligibleDevice)
}

int IneligibleDevice::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.IneligibleDevice)
  int total_size = 0;

  // optional .cryptauth.ExternalDeviceInfo device = 1;
  if (has_device()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->device_);
  }

  // repeated string reasons = 2;
  total_size += 1 * this->reasons_size();
  for (int i = 0; i < this->reasons_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->reasons(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IneligibleDevice::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IneligibleDevice*>(&from));
}

void IneligibleDevice::MergeFrom(const IneligibleDevice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.IneligibleDevice)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  reasons_.MergeFrom(from.reasons_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_device()) {
      mutable_device()->::cryptauth::ExternalDeviceInfo::MergeFrom(from.device());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void IneligibleDevice::CopyFrom(const IneligibleDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.IneligibleDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IneligibleDevice::IsInitialized() const {

  return true;
}

void IneligibleDevice::Swap(IneligibleDevice* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IneligibleDevice::InternalSwap(IneligibleDevice* other) {
  std::swap(device_, other->device_);
  reasons_.UnsafeArenaSwap(&other->reasons_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string IneligibleDevice::GetTypeName() const {
  return "cryptauth.IneligibleDevice";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IneligibleDevice

// optional .cryptauth.ExternalDeviceInfo device = 1;
bool IneligibleDevice::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IneligibleDevice::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
void IneligibleDevice::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
void IneligibleDevice::clear_device() {
  if (device_ != NULL) device_->::cryptauth::ExternalDeviceInfo::Clear();
  clear_has_device();
}
const ::cryptauth::ExternalDeviceInfo& IneligibleDevice::device() const {
  // @@protoc_insertion_point(field_get:cryptauth.IneligibleDevice.device)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_ != NULL ? *device_ : *default_instance().device_;
#else
  return device_ != NULL ? *device_ : *default_instance_->device_;
#endif
}
::cryptauth::ExternalDeviceInfo* IneligibleDevice::mutable_device() {
  set_has_device();
  if (device_ == NULL) {
    device_ = new ::cryptauth::ExternalDeviceInfo;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.IneligibleDevice.device)
  return device_;
}
::cryptauth::ExternalDeviceInfo* IneligibleDevice::release_device() {
  // @@protoc_insertion_point(field_release:cryptauth.IneligibleDevice.device)
  clear_has_device();
  ::cryptauth::ExternalDeviceInfo* temp = device_;
  device_ = NULL;
  return temp;
}
void IneligibleDevice::set_allocated_device(::cryptauth::ExternalDeviceInfo* device) {
  delete device_;
  device_ = device;
  if (device) {
    set_has_device();
  } else {
    clear_has_device();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.IneligibleDevice.device)
}

// repeated string reasons = 2;
int IneligibleDevice::reasons_size() const {
  return reasons_.size();
}
void IneligibleDevice::clear_reasons() {
  reasons_.Clear();
}
 const ::std::string& IneligibleDevice::reasons(int index) const {
  // @@protoc_insertion_point(field_get:cryptauth.IneligibleDevice.reasons)
  return reasons_.Get(index);
}
 ::std::string* IneligibleDevice::mutable_reasons(int index) {
  // @@protoc_insertion_point(field_mutable:cryptauth.IneligibleDevice.reasons)
  return reasons_.Mutable(index);
}
 void IneligibleDevice::set_reasons(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cryptauth.IneligibleDevice.reasons)
  reasons_.Mutable(index)->assign(value);
}
 void IneligibleDevice::set_reasons(int index, const char* value) {
  reasons_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cryptauth.IneligibleDevice.reasons)
}
 void IneligibleDevice::set_reasons(int index, const char* value, size_t size) {
  reasons_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cryptauth.IneligibleDevice.reasons)
}
 ::std::string* IneligibleDevice::add_reasons() {
  // @@protoc_insertion_point(field_add_mutable:cryptauth.IneligibleDevice.reasons)
  return reasons_.Add();
}
 void IneligibleDevice::add_reasons(const ::std::string& value) {
  reasons_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cryptauth.IneligibleDevice.reasons)
}
 void IneligibleDevice::add_reasons(const char* value) {
  reasons_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cryptauth.IneligibleDevice.reasons)
}
 void IneligibleDevice::add_reasons(const char* value, size_t size) {
  reasons_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cryptauth.IneligibleDevice.reasons)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
IneligibleDevice::reasons() const {
  // @@protoc_insertion_point(field_list:cryptauth.IneligibleDevice.reasons)
  return reasons_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
IneligibleDevice::mutable_reasons() {
  // @@protoc_insertion_point(field_mutable_list:cryptauth.IneligibleDevice.reasons)
  return &reasons_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForSendDeviceSyncTickleRequest(
    SendDeviceSyncTickleRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SendDeviceSyncTickleRequest::kTickleTypeFieldNumber;
const int SendDeviceSyncTickleRequest::kDeviceClassifierFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SendDeviceSyncTickleRequest::SendDeviceSyncTickleRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.SendDeviceSyncTickleRequest)
}

void SendDeviceSyncTickleRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(
      ::cryptauth::DeviceClassifier::internal_default_instance());
#else
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(&::cryptauth::DeviceClassifier::default_instance());
#endif
}

SendDeviceSyncTickleRequest::SendDeviceSyncTickleRequest(const SendDeviceSyncTickleRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.SendDeviceSyncTickleRequest)
}

void SendDeviceSyncTickleRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tickle_type_ = 0;
  device_classifier_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendDeviceSyncTickleRequest::~SendDeviceSyncTickleRequest() {
  // @@protoc_insertion_point(destructor:cryptauth.SendDeviceSyncTickleRequest)
  SharedDtor();
}

void SendDeviceSyncTickleRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete device_classifier_;
  }
}

void SendDeviceSyncTickleRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SendDeviceSyncTickleRequest& SendDeviceSyncTickleRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

SendDeviceSyncTickleRequest* SendDeviceSyncTickleRequest::default_instance_ = NULL;

SendDeviceSyncTickleRequest* SendDeviceSyncTickleRequest::New(::google::protobuf::Arena* arena) const {
  SendDeviceSyncTickleRequest* n = new SendDeviceSyncTickleRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SendDeviceSyncTickleRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.SendDeviceSyncTickleRequest)
  if (_has_bits_[0 / 32] & 3u) {
    tickle_type_ = 0;
    if (has_device_classifier()) {
      if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SendDeviceSyncTickleRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSendDeviceSyncTickleRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.SendDeviceSyncTickleRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .cryptauth.RegistrationTickleType tickle_type = 3;
      case 3: {
        if (tag == 24) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::cryptauth::RegistrationTickleType_IsValid(value)) {
            set_tickle_type(static_cast< ::cryptauth::RegistrationTickleType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_device_classifier;
        break;
      }

      // optional .cryptauth.DeviceClassifier device_classifier = 4;
      case 4: {
        if (tag == 34) {
         parse_device_classifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_device_classifier()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.SendDeviceSyncTickleRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.SendDeviceSyncTickleRequest)
  return false;
#undef DO_
}

void SendDeviceSyncTickleRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.SendDeviceSyncTickleRequest)
  // optional .cryptauth.RegistrationTickleType tickle_type = 3;
  if (has_tickle_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->tickle_type(), output);
  }

  // optional .cryptauth.DeviceClassifier device_classifier = 4;
  if (has_device_classifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->device_classifier_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.SendDeviceSyncTickleRequest)
}

int SendDeviceSyncTickleRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.SendDeviceSyncTickleRequest)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .cryptauth.RegistrationTickleType tickle_type = 3;
    if (has_tickle_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->tickle_type());
    }

    // optional .cryptauth.DeviceClassifier device_classifier = 4;
    if (has_device_classifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->device_classifier_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendDeviceSyncTickleRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SendDeviceSyncTickleRequest*>(&from));
}

void SendDeviceSyncTickleRequest::MergeFrom(const SendDeviceSyncTickleRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.SendDeviceSyncTickleRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tickle_type()) {
      set_tickle_type(from.tickle_type());
    }
    if (from.has_device_classifier()) {
      mutable_device_classifier()->::cryptauth::DeviceClassifier::MergeFrom(from.device_classifier());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SendDeviceSyncTickleRequest::CopyFrom(const SendDeviceSyncTickleRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.SendDeviceSyncTickleRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendDeviceSyncTickleRequest::IsInitialized() const {

  return true;
}

void SendDeviceSyncTickleRequest::Swap(SendDeviceSyncTickleRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SendDeviceSyncTickleRequest::InternalSwap(SendDeviceSyncTickleRequest* other) {
  std::swap(tickle_type_, other->tickle_type_);
  std::swap(device_classifier_, other->device_classifier_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SendDeviceSyncTickleRequest::GetTypeName() const {
  return "cryptauth.SendDeviceSyncTickleRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SendDeviceSyncTickleRequest

// optional .cryptauth.RegistrationTickleType tickle_type = 3;
bool SendDeviceSyncTickleRequest::has_tickle_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SendDeviceSyncTickleRequest::set_has_tickle_type() {
  _has_bits_[0] |= 0x00000001u;
}
void SendDeviceSyncTickleRequest::clear_has_tickle_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void SendDeviceSyncTickleRequest::clear_tickle_type() {
  tickle_type_ = 0;
  clear_has_tickle_type();
}
 ::cryptauth::RegistrationTickleType SendDeviceSyncTickleRequest::tickle_type() const {
  // @@protoc_insertion_point(field_get:cryptauth.SendDeviceSyncTickleRequest.tickle_type)
  return static_cast< ::cryptauth::RegistrationTickleType >(tickle_type_);
}
 void SendDeviceSyncTickleRequest::set_tickle_type(::cryptauth::RegistrationTickleType value) {
  assert(::cryptauth::RegistrationTickleType_IsValid(value));
  set_has_tickle_type();
  tickle_type_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.SendDeviceSyncTickleRequest.tickle_type)
}

// optional .cryptauth.DeviceClassifier device_classifier = 4;
bool SendDeviceSyncTickleRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SendDeviceSyncTickleRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000002u;
}
void SendDeviceSyncTickleRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000002u;
}
void SendDeviceSyncTickleRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
const ::cryptauth::DeviceClassifier& SendDeviceSyncTickleRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.SendDeviceSyncTickleRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
::cryptauth::DeviceClassifier* SendDeviceSyncTickleRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.SendDeviceSyncTickleRequest.device_classifier)
  return device_classifier_;
}
::cryptauth::DeviceClassifier* SendDeviceSyncTickleRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.SendDeviceSyncTickleRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
void SendDeviceSyncTickleRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SendDeviceSyncTickleRequest.device_classifier)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForSendDeviceSyncTickleResponse(
    SendDeviceSyncTickleResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SendDeviceSyncTickleResponse::SendDeviceSyncTickleResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.SendDeviceSyncTickleResponse)
}

void SendDeviceSyncTickleResponse::InitAsDefaultInstance() {
}

SendDeviceSyncTickleResponse::SendDeviceSyncTickleResponse(const SendDeviceSyncTickleResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.SendDeviceSyncTickleResponse)
}

void SendDeviceSyncTickleResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendDeviceSyncTickleResponse::~SendDeviceSyncTickleResponse() {
  // @@protoc_insertion_point(destructor:cryptauth.SendDeviceSyncTickleResponse)
  SharedDtor();
}

void SendDeviceSyncTickleResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SendDeviceSyncTickleResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SendDeviceSyncTickleResponse& SendDeviceSyncTickleResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

SendDeviceSyncTickleResponse* SendDeviceSyncTickleResponse::default_instance_ = NULL;

SendDeviceSyncTickleResponse* SendDeviceSyncTickleResponse::New(::google::protobuf::Arena* arena) const {
  SendDeviceSyncTickleResponse* n = new SendDeviceSyncTickleResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SendDeviceSyncTickleResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.SendDeviceSyncTickleResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SendDeviceSyncTickleResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSendDeviceSyncTickleResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.SendDeviceSyncTickleResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.SendDeviceSyncTickleResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.SendDeviceSyncTickleResponse)
  return false;
#undef DO_
}

void SendDeviceSyncTickleResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.SendDeviceSyncTickleResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.SendDeviceSyncTickleResponse)
}

int SendDeviceSyncTickleResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.SendDeviceSyncTickleResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendDeviceSyncTickleResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SendDeviceSyncTickleResponse*>(&from));
}

void SendDeviceSyncTickleResponse::MergeFrom(const SendDeviceSyncTickleResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.SendDeviceSyncTickleResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SendDeviceSyncTickleResponse::CopyFrom(const SendDeviceSyncTickleResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.SendDeviceSyncTickleResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendDeviceSyncTickleResponse::IsInitialized() const {

  return true;
}

void SendDeviceSyncTickleResponse::Swap(SendDeviceSyncTickleResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SendDeviceSyncTickleResponse::InternalSwap(SendDeviceSyncTickleResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SendDeviceSyncTickleResponse::GetTypeName() const {
  return "cryptauth.SendDeviceSyncTickleResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SendDeviceSyncTickleResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForSetupEnrollmentInfo(
    SetupEnrollmentInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SetupEnrollmentInfo::kTypeFieldNumber;
const int SetupEnrollmentInfo::kEnrollmentSessionIdFieldNumber;
const int SetupEnrollmentInfo::kServerEphemeralKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SetupEnrollmentInfo::SetupEnrollmentInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.SetupEnrollmentInfo)
}

void SetupEnrollmentInfo::InitAsDefaultInstance() {
}

SetupEnrollmentInfo::SetupEnrollmentInfo(const SetupEnrollmentInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.SetupEnrollmentInfo)
}

void SetupEnrollmentInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  enrollment_session_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  server_ephemeral_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetupEnrollmentInfo::~SetupEnrollmentInfo() {
  // @@protoc_insertion_point(destructor:cryptauth.SetupEnrollmentInfo)
  SharedDtor();
}

void SetupEnrollmentInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  enrollment_session_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  server_ephemeral_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SetupEnrollmentInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SetupEnrollmentInfo& SetupEnrollmentInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

SetupEnrollmentInfo* SetupEnrollmentInfo::default_instance_ = NULL;

SetupEnrollmentInfo* SetupEnrollmentInfo::New(::google::protobuf::Arena* arena) const {
  SetupEnrollmentInfo* n = new SetupEnrollmentInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SetupEnrollmentInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.SetupEnrollmentInfo)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_type()) {
      type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_enrollment_session_id()) {
      enrollment_session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_server_ephemeral_key()) {
      server_ephemeral_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SetupEnrollmentInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSetupEnrollmentInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.SetupEnrollmentInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string type = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_enrollment_session_id;
        break;
      }

      // optional bytes enrollment_session_id = 2;
      case 2: {
        if (tag == 18) {
         parse_enrollment_session_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_enrollment_session_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_server_ephemeral_key;
        break;
      }

      // optional bytes server_ephemeral_key = 3;
      case 3: {
        if (tag == 26) {
         parse_server_ephemeral_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_server_ephemeral_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.SetupEnrollmentInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.SetupEnrollmentInfo)
  return false;
#undef DO_
}

void SetupEnrollmentInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.SetupEnrollmentInfo)
  // optional string type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->type(), output);
  }

  // optional bytes enrollment_session_id = 2;
  if (has_enrollment_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->enrollment_session_id(), output);
  }

  // optional bytes server_ephemeral_key = 3;
  if (has_server_ephemeral_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->server_ephemeral_key(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.SetupEnrollmentInfo)
}

int SetupEnrollmentInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.SetupEnrollmentInfo)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional string type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // optional bytes enrollment_session_id = 2;
    if (has_enrollment_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->enrollment_session_id());
    }

    // optional bytes server_ephemeral_key = 3;
    if (has_server_ephemeral_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->server_ephemeral_key());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetupEnrollmentInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SetupEnrollmentInfo*>(&from));
}

void SetupEnrollmentInfo::MergeFrom(const SetupEnrollmentInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.SetupEnrollmentInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_has_type();
      type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
    }
    if (from.has_enrollment_session_id()) {
      set_has_enrollment_session_id();
      enrollment_session_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.enrollment_session_id_);
    }
    if (from.has_server_ephemeral_key()) {
      set_has_server_ephemeral_key();
      server_ephemeral_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.server_ephemeral_key_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SetupEnrollmentInfo::CopyFrom(const SetupEnrollmentInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.SetupEnrollmentInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetupEnrollmentInfo::IsInitialized() const {

  return true;
}

void SetupEnrollmentInfo::Swap(SetupEnrollmentInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SetupEnrollmentInfo::InternalSwap(SetupEnrollmentInfo* other) {
  type_.Swap(&other->type_);
  enrollment_session_id_.Swap(&other->enrollment_session_id_);
  server_ephemeral_key_.Swap(&other->server_ephemeral_key_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SetupEnrollmentInfo::GetTypeName() const {
  return "cryptauth.SetupEnrollmentInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SetupEnrollmentInfo

// optional string type = 1;
bool SetupEnrollmentInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SetupEnrollmentInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void SetupEnrollmentInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void SetupEnrollmentInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
 const ::std::string& SetupEnrollmentInfo::type() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentInfo.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetupEnrollmentInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentInfo.type)
}
 void SetupEnrollmentInfo::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentInfo.type)
}
 void SetupEnrollmentInfo::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentInfo.type)
}
 ::std::string* SetupEnrollmentInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetupEnrollmentInfo::release_type() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentInfo.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetupEnrollmentInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentInfo.type)
}

// optional bytes enrollment_session_id = 2;
bool SetupEnrollmentInfo::has_enrollment_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SetupEnrollmentInfo::set_has_enrollment_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
void SetupEnrollmentInfo::clear_has_enrollment_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void SetupEnrollmentInfo::clear_enrollment_session_id() {
  enrollment_session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_enrollment_session_id();
}
 const ::std::string& SetupEnrollmentInfo::enrollment_session_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
  return enrollment_session_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetupEnrollmentInfo::set_enrollment_session_id(const ::std::string& value) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
}
 void SetupEnrollmentInfo::set_enrollment_session_id(const char* value) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
}
 void SetupEnrollmentInfo::set_enrollment_session_id(const void* value, size_t size) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
}
 ::std::string* SetupEnrollmentInfo::mutable_enrollment_session_id() {
  set_has_enrollment_session_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
  return enrollment_session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetupEnrollmentInfo::release_enrollment_session_id() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
  clear_has_enrollment_session_id();
  return enrollment_session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetupEnrollmentInfo::set_allocated_enrollment_session_id(::std::string* enrollment_session_id) {
  if (enrollment_session_id != NULL) {
    set_has_enrollment_session_id();
  } else {
    clear_has_enrollment_session_id();
  }
  enrollment_session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enrollment_session_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
}

// optional bytes server_ephemeral_key = 3;
bool SetupEnrollmentInfo::has_server_ephemeral_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SetupEnrollmentInfo::set_has_server_ephemeral_key() {
  _has_bits_[0] |= 0x00000004u;
}
void SetupEnrollmentInfo::clear_has_server_ephemeral_key() {
  _has_bits_[0] &= ~0x00000004u;
}
void SetupEnrollmentInfo::clear_server_ephemeral_key() {
  server_ephemeral_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_server_ephemeral_key();
}
 const ::std::string& SetupEnrollmentInfo::server_ephemeral_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
  return server_ephemeral_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetupEnrollmentInfo::set_server_ephemeral_key(const ::std::string& value) {
  set_has_server_ephemeral_key();
  server_ephemeral_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
}
 void SetupEnrollmentInfo::set_server_ephemeral_key(const char* value) {
  set_has_server_ephemeral_key();
  server_ephemeral_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
}
 void SetupEnrollmentInfo::set_server_ephemeral_key(const void* value, size_t size) {
  set_has_server_ephemeral_key();
  server_ephemeral_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
}
 ::std::string* SetupEnrollmentInfo::mutable_server_ephemeral_key() {
  set_has_server_ephemeral_key();
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
  return server_ephemeral_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetupEnrollmentInfo::release_server_ephemeral_key() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
  clear_has_server_ephemeral_key();
  return server_ephemeral_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetupEnrollmentInfo::set_allocated_server_ephemeral_key(::std::string* server_ephemeral_key) {
  if (server_ephemeral_key != NULL) {
    set_has_server_ephemeral_key();
  } else {
    clear_has_server_ephemeral_key();
  }
  server_ephemeral_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_ephemeral_key);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForSetupEnrollmentRequest(
    SetupEnrollmentRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SetupEnrollmentRequest::kOriginFieldNumber;
const int SetupEnrollmentRequest::kTypesFieldNumber;
const int SetupEnrollmentRequest::kUseLegacyCryptoFieldNumber;
const int SetupEnrollmentRequest::kApplicationIdFieldNumber;
const int SetupEnrollmentRequest::kInvocationReasonFieldNumber;
const int SetupEnrollmentRequest::kRetryCountFieldNumber;
const int SetupEnrollmentRequest::kDeviceClassifierFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SetupEnrollmentRequest::SetupEnrollmentRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.SetupEnrollmentRequest)
}

void SetupEnrollmentRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(
      ::cryptauth::DeviceClassifier::internal_default_instance());
#else
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(&::cryptauth::DeviceClassifier::default_instance());
#endif
}

SetupEnrollmentRequest::SetupEnrollmentRequest(const SetupEnrollmentRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.SetupEnrollmentRequest)
}

void SetupEnrollmentRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  origin_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  use_legacy_crypto_ = false;
  application_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  invocation_reason_ = 0;
  retry_count_ = 0;
  device_classifier_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetupEnrollmentRequest::~SetupEnrollmentRequest() {
  // @@protoc_insertion_point(destructor:cryptauth.SetupEnrollmentRequest)
  SharedDtor();
}

void SetupEnrollmentRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  origin_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  application_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete device_classifier_;
  }
}

void SetupEnrollmentRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SetupEnrollmentRequest& SetupEnrollmentRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

SetupEnrollmentRequest* SetupEnrollmentRequest::default_instance_ = NULL;

SetupEnrollmentRequest* SetupEnrollmentRequest::New(::google::protobuf::Arena* arena) const {
  SetupEnrollmentRequest* n = new SetupEnrollmentRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SetupEnrollmentRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.SetupEnrollmentRequest)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(SetupEnrollmentRequest, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SetupEnrollmentRequest*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 125u) {
    ZR_(use_legacy_crypto_, invocation_reason_);
    if (has_origin()) {
      origin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_application_id()) {
      application_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    retry_count_ = 0;
    if (has_device_classifier()) {
      if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  types_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SetupEnrollmentRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSetupEnrollmentRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.SetupEnrollmentRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string origin = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_types;
        break;
      }

      // repeated string types = 3;
      case 3: {
        if (tag == 26) {
         parse_types:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_types()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_types;
        if (input->ExpectTag(32)) goto parse_use_legacy_crypto;
        break;
      }

      // optional bool use_legacy_crypto = 4;
      case 4: {
        if (tag == 32) {
         parse_use_legacy_crypto:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &use_legacy_crypto_)));
          set_has_use_legacy_crypto();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_application_id;
        break;
      }

      // optional string application_id = 5;
      case 5: {
        if (tag == 42) {
         parse_application_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_application_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_invocation_reason;
        break;
      }

      // optional int32 invocation_reason = 6 [default = 0];
      case 6: {
        if (tag == 48) {
         parse_invocation_reason:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &invocation_reason_)));
          set_has_invocation_reason();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_retry_count;
        break;
      }

      // optional int32 retry_count = 7 [default = 0];
      case 7: {
        if (tag == 56) {
         parse_retry_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &retry_count_)));
          set_has_retry_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_device_classifier;
        break;
      }

      // optional .cryptauth.DeviceClassifier device_classifier = 8;
      case 8: {
        if (tag == 66) {
         parse_device_classifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_device_classifier()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.SetupEnrollmentRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.SetupEnrollmentRequest)
  return false;
#undef DO_
}

void SetupEnrollmentRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.SetupEnrollmentRequest)
  // optional string origin = 2;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->origin(), output);
  }

  // repeated string types = 3;
  for (int i = 0; i < this->types_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->types(i), output);
  }

  // optional bool use_legacy_crypto = 4;
  if (has_use_legacy_crypto()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->use_legacy_crypto(), output);
  }

  // optional string application_id = 5;
  if (has_application_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->application_id(), output);
  }

  // optional int32 invocation_reason = 6 [default = 0];
  if (has_invocation_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->invocation_reason(), output);
  }

  // optional int32 retry_count = 7 [default = 0];
  if (has_retry_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->retry_count(), output);
  }

  // optional .cryptauth.DeviceClassifier device_classifier = 8;
  if (has_device_classifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, *this->device_classifier_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.SetupEnrollmentRequest)
}

int SetupEnrollmentRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.SetupEnrollmentRequest)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 125u) {
    // optional string origin = 2;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->origin());
    }

    // optional bool use_legacy_crypto = 4;
    if (has_use_legacy_crypto()) {
      total_size += 1 + 1;
    }

    // optional string application_id = 5;
    if (has_application_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->application_id());
    }

    // optional int32 invocation_reason = 6 [default = 0];
    if (has_invocation_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->invocation_reason());
    }

    // optional int32 retry_count = 7 [default = 0];
    if (has_retry_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->retry_count());
    }

    // optional .cryptauth.DeviceClassifier device_classifier = 8;
    if (has_device_classifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->device_classifier_);
    }

  }
  // repeated string types = 3;
  total_size += 1 * this->types_size();
  for (int i = 0; i < this->types_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->types(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetupEnrollmentRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SetupEnrollmentRequest*>(&from));
}

void SetupEnrollmentRequest::MergeFrom(const SetupEnrollmentRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.SetupEnrollmentRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  types_.MergeFrom(from.types_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin()) {
      set_has_origin();
      origin_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.origin_);
    }
    if (from.has_use_legacy_crypto()) {
      set_use_legacy_crypto(from.use_legacy_crypto());
    }
    if (from.has_application_id()) {
      set_has_application_id();
      application_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.application_id_);
    }
    if (from.has_invocation_reason()) {
      set_invocation_reason(from.invocation_reason());
    }
    if (from.has_retry_count()) {
      set_retry_count(from.retry_count());
    }
    if (from.has_device_classifier()) {
      mutable_device_classifier()->::cryptauth::DeviceClassifier::MergeFrom(from.device_classifier());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SetupEnrollmentRequest::CopyFrom(const SetupEnrollmentRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.SetupEnrollmentRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetupEnrollmentRequest::IsInitialized() const {

  return true;
}

void SetupEnrollmentRequest::Swap(SetupEnrollmentRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SetupEnrollmentRequest::InternalSwap(SetupEnrollmentRequest* other) {
  origin_.Swap(&other->origin_);
  types_.UnsafeArenaSwap(&other->types_);
  std::swap(use_legacy_crypto_, other->use_legacy_crypto_);
  application_id_.Swap(&other->application_id_);
  std::swap(invocation_reason_, other->invocation_reason_);
  std::swap(retry_count_, other->retry_count_);
  std::swap(device_classifier_, other->device_classifier_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SetupEnrollmentRequest::GetTypeName() const {
  return "cryptauth.SetupEnrollmentRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SetupEnrollmentRequest

// optional string origin = 2;
bool SetupEnrollmentRequest::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SetupEnrollmentRequest::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
void SetupEnrollmentRequest::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
void SetupEnrollmentRequest::clear_origin() {
  origin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_origin();
}
 const ::std::string& SetupEnrollmentRequest::origin() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.origin)
  return origin_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetupEnrollmentRequest::set_origin(const ::std::string& value) {
  set_has_origin();
  origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentRequest.origin)
}
 void SetupEnrollmentRequest::set_origin(const char* value) {
  set_has_origin();
  origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentRequest.origin)
}
 void SetupEnrollmentRequest::set_origin(const char* value, size_t size) {
  set_has_origin();
  origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentRequest.origin)
}
 ::std::string* SetupEnrollmentRequest::mutable_origin() {
  set_has_origin();
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentRequest.origin)
  return origin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetupEnrollmentRequest::release_origin() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentRequest.origin)
  clear_has_origin();
  return origin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetupEnrollmentRequest::set_allocated_origin(::std::string* origin) {
  if (origin != NULL) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  origin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), origin);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentRequest.origin)
}

// repeated string types = 3;
int SetupEnrollmentRequest::types_size() const {
  return types_.size();
}
void SetupEnrollmentRequest::clear_types() {
  types_.Clear();
}
 const ::std::string& SetupEnrollmentRequest::types(int index) const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.types)
  return types_.Get(index);
}
 ::std::string* SetupEnrollmentRequest::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentRequest.types)
  return types_.Mutable(index);
}
 void SetupEnrollmentRequest::set_types(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentRequest.types)
  types_.Mutable(index)->assign(value);
}
 void SetupEnrollmentRequest::set_types(int index, const char* value) {
  types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentRequest.types)
}
 void SetupEnrollmentRequest::set_types(int index, const char* value, size_t size) {
  types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentRequest.types)
}
 ::std::string* SetupEnrollmentRequest::add_types() {
  // @@protoc_insertion_point(field_add_mutable:cryptauth.SetupEnrollmentRequest.types)
  return types_.Add();
}
 void SetupEnrollmentRequest::add_types(const ::std::string& value) {
  types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cryptauth.SetupEnrollmentRequest.types)
}
 void SetupEnrollmentRequest::add_types(const char* value) {
  types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cryptauth.SetupEnrollmentRequest.types)
}
 void SetupEnrollmentRequest::add_types(const char* value, size_t size) {
  types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cryptauth.SetupEnrollmentRequest.types)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
SetupEnrollmentRequest::types() const {
  // @@protoc_insertion_point(field_list:cryptauth.SetupEnrollmentRequest.types)
  return types_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
SetupEnrollmentRequest::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:cryptauth.SetupEnrollmentRequest.types)
  return &types_;
}

// optional bool use_legacy_crypto = 4;
bool SetupEnrollmentRequest::has_use_legacy_crypto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SetupEnrollmentRequest::set_has_use_legacy_crypto() {
  _has_bits_[0] |= 0x00000004u;
}
void SetupEnrollmentRequest::clear_has_use_legacy_crypto() {
  _has_bits_[0] &= ~0x00000004u;
}
void SetupEnrollmentRequest::clear_use_legacy_crypto() {
  use_legacy_crypto_ = false;
  clear_has_use_legacy_crypto();
}
 bool SetupEnrollmentRequest::use_legacy_crypto() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.use_legacy_crypto)
  return use_legacy_crypto_;
}
 void SetupEnrollmentRequest::set_use_legacy_crypto(bool value) {
  set_has_use_legacy_crypto();
  use_legacy_crypto_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentRequest.use_legacy_crypto)
}

// optional string application_id = 5;
bool SetupEnrollmentRequest::has_application_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SetupEnrollmentRequest::set_has_application_id() {
  _has_bits_[0] |= 0x00000008u;
}
void SetupEnrollmentRequest::clear_has_application_id() {
  _has_bits_[0] &= ~0x00000008u;
}
void SetupEnrollmentRequest::clear_application_id() {
  application_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_application_id();
}
 const ::std::string& SetupEnrollmentRequest::application_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.application_id)
  return application_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetupEnrollmentRequest::set_application_id(const ::std::string& value) {
  set_has_application_id();
  application_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentRequest.application_id)
}
 void SetupEnrollmentRequest::set_application_id(const char* value) {
  set_has_application_id();
  application_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentRequest.application_id)
}
 void SetupEnrollmentRequest::set_application_id(const char* value, size_t size) {
  set_has_application_id();
  application_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentRequest.application_id)
}
 ::std::string* SetupEnrollmentRequest::mutable_application_id() {
  set_has_application_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentRequest.application_id)
  return application_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetupEnrollmentRequest::release_application_id() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentRequest.application_id)
  clear_has_application_id();
  return application_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetupEnrollmentRequest::set_allocated_application_id(::std::string* application_id) {
  if (application_id != NULL) {
    set_has_application_id();
  } else {
    clear_has_application_id();
  }
  application_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentRequest.application_id)
}

// optional int32 invocation_reason = 6 [default = 0];
bool SetupEnrollmentRequest::has_invocation_reason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void SetupEnrollmentRequest::set_has_invocation_reason() {
  _has_bits_[0] |= 0x00000010u;
}
void SetupEnrollmentRequest::clear_has_invocation_reason() {
  _has_bits_[0] &= ~0x00000010u;
}
void SetupEnrollmentRequest::clear_invocation_reason() {
  invocation_reason_ = 0;
  clear_has_invocation_reason();
}
 ::google::protobuf::int32 SetupEnrollmentRequest::invocation_reason() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.invocation_reason)
  return invocation_reason_;
}
 void SetupEnrollmentRequest::set_invocation_reason(::google::protobuf::int32 value) {
  set_has_invocation_reason();
  invocation_reason_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentRequest.invocation_reason)
}

// optional int32 retry_count = 7 [default = 0];
bool SetupEnrollmentRequest::has_retry_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void SetupEnrollmentRequest::set_has_retry_count() {
  _has_bits_[0] |= 0x00000020u;
}
void SetupEnrollmentRequest::clear_has_retry_count() {
  _has_bits_[0] &= ~0x00000020u;
}
void SetupEnrollmentRequest::clear_retry_count() {
  retry_count_ = 0;
  clear_has_retry_count();
}
 ::google::protobuf::int32 SetupEnrollmentRequest::retry_count() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.retry_count)
  return retry_count_;
}
 void SetupEnrollmentRequest::set_retry_count(::google::protobuf::int32 value) {
  set_has_retry_count();
  retry_count_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentRequest.retry_count)
}

// optional .cryptauth.DeviceClassifier device_classifier = 8;
bool SetupEnrollmentRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void SetupEnrollmentRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000040u;
}
void SetupEnrollmentRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000040u;
}
void SetupEnrollmentRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
const ::cryptauth::DeviceClassifier& SetupEnrollmentRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
::cryptauth::DeviceClassifier* SetupEnrollmentRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentRequest.device_classifier)
  return device_classifier_;
}
::cryptauth::DeviceClassifier* SetupEnrollmentRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
void SetupEnrollmentRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentRequest.device_classifier)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForSetupEnrollmentResponse(
    SetupEnrollmentResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SetupEnrollmentResponse::kStatusFieldNumber;
const int SetupEnrollmentResponse::kInfosFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SetupEnrollmentResponse::SetupEnrollmentResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.SetupEnrollmentResponse)
}

void SetupEnrollmentResponse::InitAsDefaultInstance() {
}

SetupEnrollmentResponse::SetupEnrollmentResponse(const SetupEnrollmentResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.SetupEnrollmentResponse)
}

void SetupEnrollmentResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  status_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetupEnrollmentResponse::~SetupEnrollmentResponse() {
  // @@protoc_insertion_point(destructor:cryptauth.SetupEnrollmentResponse)
  SharedDtor();
}

void SetupEnrollmentResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  status_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SetupEnrollmentResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SetupEnrollmentResponse& SetupEnrollmentResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

SetupEnrollmentResponse* SetupEnrollmentResponse::default_instance_ = NULL;

SetupEnrollmentResponse* SetupEnrollmentResponse::New(::google::protobuf::Arena* arena) const {
  SetupEnrollmentResponse* n = new SetupEnrollmentResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SetupEnrollmentResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.SetupEnrollmentResponse)
  if (has_status()) {
    status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SetupEnrollmentResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSetupEnrollmentResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.SetupEnrollmentResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string status = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_infos;
        break;
      }

      // repeated .cryptauth.SetupEnrollmentInfo infos = 2;
      case 2: {
        if (tag == 18) {
         parse_infos:
          DO_(input->IncrementRecursionDepth());
         parse_loop_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_infos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_infos;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.SetupEnrollmentResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.SetupEnrollmentResponse)
  return false;
#undef DO_
}

void SetupEnrollmentResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.SetupEnrollmentResponse)
  // optional string status = 1;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->status(), output);
  }

  // repeated .cryptauth.SetupEnrollmentInfo infos = 2;
  for (unsigned int i = 0, n = this->infos_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->infos(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.SetupEnrollmentResponse)
}

int SetupEnrollmentResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.SetupEnrollmentResponse)
  int total_size = 0;

  // optional string status = 1;
  if (has_status()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->status());
  }

  // repeated .cryptauth.SetupEnrollmentInfo infos = 2;
  total_size += 1 * this->infos_size();
  for (int i = 0; i < this->infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->infos(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetupEnrollmentResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SetupEnrollmentResponse*>(&from));
}

void SetupEnrollmentResponse::MergeFrom(const SetupEnrollmentResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.SetupEnrollmentResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  infos_.MergeFrom(from.infos_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status()) {
      set_has_status();
      status_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.status_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SetupEnrollmentResponse::CopyFrom(const SetupEnrollmentResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.SetupEnrollmentResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetupEnrollmentResponse::IsInitialized() const {

  return true;
}

void SetupEnrollmentResponse::Swap(SetupEnrollmentResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SetupEnrollmentResponse::InternalSwap(SetupEnrollmentResponse* other) {
  status_.Swap(&other->status_);
  infos_.UnsafeArenaSwap(&other->infos_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SetupEnrollmentResponse::GetTypeName() const {
  return "cryptauth.SetupEnrollmentResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SetupEnrollmentResponse

// optional string status = 1;
bool SetupEnrollmentResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SetupEnrollmentResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
void SetupEnrollmentResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
void SetupEnrollmentResponse::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
 const ::std::string& SetupEnrollmentResponse::status() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentResponse.status)
  return status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetupEnrollmentResponse::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentResponse.status)
}
 void SetupEnrollmentResponse::set_status(const char* value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentResponse.status)
}
 void SetupEnrollmentResponse::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentResponse.status)
}
 ::std::string* SetupEnrollmentResponse::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentResponse.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SetupEnrollmentResponse::release_status() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentResponse.status)
  clear_has_status();
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SetupEnrollmentResponse::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentResponse.status)
}

// repeated .cryptauth.SetupEnrollmentInfo infos = 2;
int SetupEnrollmentResponse::infos_size() const {
  return infos_.size();
}
void SetupEnrollmentResponse::clear_infos() {
  infos_.Clear();
}
const ::cryptauth::SetupEnrollmentInfo& SetupEnrollmentResponse::infos(int index) const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentResponse.infos)
  return infos_.Get(index);
}
::cryptauth::SetupEnrollmentInfo* SetupEnrollmentResponse::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentResponse.infos)
  return infos_.Mutable(index);
}
::cryptauth::SetupEnrollmentInfo* SetupEnrollmentResponse::add_infos() {
  // @@protoc_insertion_point(field_add:cryptauth.SetupEnrollmentResponse.infos)
  return infos_.Add();
}
::google::protobuf::RepeatedPtrField< ::cryptauth::SetupEnrollmentInfo >*
SetupEnrollmentResponse::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:cryptauth.SetupEnrollmentResponse.infos)
  return &infos_;
}
const ::google::protobuf::RepeatedPtrField< ::cryptauth::SetupEnrollmentInfo >&
SetupEnrollmentResponse::infos() const {
  // @@protoc_insertion_point(field_list:cryptauth.SetupEnrollmentResponse.infos)
  return infos_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForToggleEasyUnlockRequest(
    ToggleEasyUnlockRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ToggleEasyUnlockRequest::kEnableFieldNumber;
const int ToggleEasyUnlockRequest::kPublicKeyFieldNumber;
const int ToggleEasyUnlockRequest::kApplyToAllFieldNumber;
const int ToggleEasyUnlockRequest::kDeviceClassifierFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ToggleEasyUnlockRequest::ToggleEasyUnlockRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.ToggleEasyUnlockRequest)
}

void ToggleEasyUnlockRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(
      ::cryptauth::DeviceClassifier::internal_default_instance());
#else
  device_classifier_ = const_cast< ::cryptauth::DeviceClassifier*>(&::cryptauth::DeviceClassifier::default_instance());
#endif
}

ToggleEasyUnlockRequest::ToggleEasyUnlockRequest(const ToggleEasyUnlockRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.ToggleEasyUnlockRequest)
}

void ToggleEasyUnlockRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  enable_ = false;
  public_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  apply_to_all_ = false;
  device_classifier_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ToggleEasyUnlockRequest::~ToggleEasyUnlockRequest() {
  // @@protoc_insertion_point(destructor:cryptauth.ToggleEasyUnlockRequest)
  SharedDtor();
}

void ToggleEasyUnlockRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete device_classifier_;
  }
}

void ToggleEasyUnlockRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ToggleEasyUnlockRequest& ToggleEasyUnlockRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

ToggleEasyUnlockRequest* ToggleEasyUnlockRequest::default_instance_ = NULL;

ToggleEasyUnlockRequest* ToggleEasyUnlockRequest::New(::google::protobuf::Arena* arena) const {
  ToggleEasyUnlockRequest* n = new ToggleEasyUnlockRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ToggleEasyUnlockRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.ToggleEasyUnlockRequest)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ToggleEasyUnlockRequest, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ToggleEasyUnlockRequest*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(enable_, apply_to_all_);
    if (has_public_key()) {
      public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_device_classifier()) {
      if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ToggleEasyUnlockRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForToggleEasyUnlockRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.ToggleEasyUnlockRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool enable = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_)));
          set_has_enable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_public_key;
        break;
      }

      // optional bytes public_key = 2;
      case 2: {
        if (tag == 18) {
         parse_public_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_apply_to_all;
        break;
      }

      // optional bool apply_to_all = 3;
      case 3: {
        if (tag == 24) {
         parse_apply_to_all:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &apply_to_all_)));
          set_has_apply_to_all();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_device_classifier;
        break;
      }

      // optional .cryptauth.DeviceClassifier device_classifier = 4;
      case 4: {
        if (tag == 34) {
         parse_device_classifier:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_device_classifier()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.ToggleEasyUnlockRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.ToggleEasyUnlockRequest)
  return false;
#undef DO_
}

void ToggleEasyUnlockRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.ToggleEasyUnlockRequest)
  // optional bool enable = 1;
  if (has_enable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->enable(), output);
  }

  // optional bytes public_key = 2;
  if (has_public_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->public_key(), output);
  }

  // optional bool apply_to_all = 3;
  if (has_apply_to_all()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->apply_to_all(), output);
  }

  // optional .cryptauth.DeviceClassifier device_classifier = 4;
  if (has_device_classifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->device_classifier_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.ToggleEasyUnlockRequest)
}

int ToggleEasyUnlockRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.ToggleEasyUnlockRequest)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional bool enable = 1;
    if (has_enable()) {
      total_size += 1 + 1;
    }

    // optional bytes public_key = 2;
    if (has_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_key());
    }

    // optional bool apply_to_all = 3;
    if (has_apply_to_all()) {
      total_size += 1 + 1;
    }

    // optional .cryptauth.DeviceClassifier device_classifier = 4;
    if (has_device_classifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->device_classifier_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ToggleEasyUnlockRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ToggleEasyUnlockRequest*>(&from));
}

void ToggleEasyUnlockRequest::MergeFrom(const ToggleEasyUnlockRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.ToggleEasyUnlockRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enable()) {
      set_enable(from.enable());
    }
    if (from.has_public_key()) {
      set_has_public_key();
      public_key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_key_);
    }
    if (from.has_apply_to_all()) {
      set_apply_to_all(from.apply_to_all());
    }
    if (from.has_device_classifier()) {
      mutable_device_classifier()->::cryptauth::DeviceClassifier::MergeFrom(from.device_classifier());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ToggleEasyUnlockRequest::CopyFrom(const ToggleEasyUnlockRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.ToggleEasyUnlockRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ToggleEasyUnlockRequest::IsInitialized() const {

  return true;
}

void ToggleEasyUnlockRequest::Swap(ToggleEasyUnlockRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ToggleEasyUnlockRequest::InternalSwap(ToggleEasyUnlockRequest* other) {
  std::swap(enable_, other->enable_);
  public_key_.Swap(&other->public_key_);
  std::swap(apply_to_all_, other->apply_to_all_);
  std::swap(device_classifier_, other->device_classifier_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ToggleEasyUnlockRequest::GetTypeName() const {
  return "cryptauth.ToggleEasyUnlockRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ToggleEasyUnlockRequest

// optional bool enable = 1;
bool ToggleEasyUnlockRequest::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ToggleEasyUnlockRequest::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
void ToggleEasyUnlockRequest::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
void ToggleEasyUnlockRequest::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
 bool ToggleEasyUnlockRequest::enable() const {
  // @@protoc_insertion_point(field_get:cryptauth.ToggleEasyUnlockRequest.enable)
  return enable_;
}
 void ToggleEasyUnlockRequest::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.ToggleEasyUnlockRequest.enable)
}

// optional bytes public_key = 2;
bool ToggleEasyUnlockRequest::has_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ToggleEasyUnlockRequest::set_has_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
void ToggleEasyUnlockRequest::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
void ToggleEasyUnlockRequest::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
 const ::std::string& ToggleEasyUnlockRequest::public_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.ToggleEasyUnlockRequest.public_key)
  return public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ToggleEasyUnlockRequest::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.ToggleEasyUnlockRequest.public_key)
}
 void ToggleEasyUnlockRequest::set_public_key(const char* value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.ToggleEasyUnlockRequest.public_key)
}
 void ToggleEasyUnlockRequest::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.ToggleEasyUnlockRequest.public_key)
}
 ::std::string* ToggleEasyUnlockRequest::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:cryptauth.ToggleEasyUnlockRequest.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ToggleEasyUnlockRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:cryptauth.ToggleEasyUnlockRequest.public_key)
  clear_has_public_key();
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ToggleEasyUnlockRequest::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.ToggleEasyUnlockRequest.public_key)
}

// optional bool apply_to_all = 3;
bool ToggleEasyUnlockRequest::has_apply_to_all() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ToggleEasyUnlockRequest::set_has_apply_to_all() {
  _has_bits_[0] |= 0x00000004u;
}
void ToggleEasyUnlockRequest::clear_has_apply_to_all() {
  _has_bits_[0] &= ~0x00000004u;
}
void ToggleEasyUnlockRequest::clear_apply_to_all() {
  apply_to_all_ = false;
  clear_has_apply_to_all();
}
 bool ToggleEasyUnlockRequest::apply_to_all() const {
  // @@protoc_insertion_point(field_get:cryptauth.ToggleEasyUnlockRequest.apply_to_all)
  return apply_to_all_;
}
 void ToggleEasyUnlockRequest::set_apply_to_all(bool value) {
  set_has_apply_to_all();
  apply_to_all_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.ToggleEasyUnlockRequest.apply_to_all)
}

// optional .cryptauth.DeviceClassifier device_classifier = 4;
bool ToggleEasyUnlockRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ToggleEasyUnlockRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000008u;
}
void ToggleEasyUnlockRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000008u;
}
void ToggleEasyUnlockRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
const ::cryptauth::DeviceClassifier& ToggleEasyUnlockRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.ToggleEasyUnlockRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
::cryptauth::DeviceClassifier* ToggleEasyUnlockRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.ToggleEasyUnlockRequest.device_classifier)
  return device_classifier_;
}
::cryptauth::DeviceClassifier* ToggleEasyUnlockRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.ToggleEasyUnlockRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
void ToggleEasyUnlockRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.ToggleEasyUnlockRequest.device_classifier)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForToggleEasyUnlockResponse(
    ToggleEasyUnlockResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ToggleEasyUnlockResponse::ToggleEasyUnlockResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:cryptauth.ToggleEasyUnlockResponse)
}

void ToggleEasyUnlockResponse::InitAsDefaultInstance() {
}

ToggleEasyUnlockResponse::ToggleEasyUnlockResponse(const ToggleEasyUnlockResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:cryptauth.ToggleEasyUnlockResponse)
}

void ToggleEasyUnlockResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ToggleEasyUnlockResponse::~ToggleEasyUnlockResponse() {
  // @@protoc_insertion_point(destructor:cryptauth.ToggleEasyUnlockResponse)
  SharedDtor();
}

void ToggleEasyUnlockResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ToggleEasyUnlockResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ToggleEasyUnlockResponse& ToggleEasyUnlockResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_cryptauth_5fapi_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_cryptauth_5fapi_2eproto();
#endif
  return *default_instance_;
}

ToggleEasyUnlockResponse* ToggleEasyUnlockResponse::default_instance_ = NULL;

ToggleEasyUnlockResponse* ToggleEasyUnlockResponse::New(::google::protobuf::Arena* arena) const {
  ToggleEasyUnlockResponse* n = new ToggleEasyUnlockResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ToggleEasyUnlockResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:cryptauth.ToggleEasyUnlockResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ToggleEasyUnlockResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForToggleEasyUnlockResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:cryptauth.ToggleEasyUnlockResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:cryptauth.ToggleEasyUnlockResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:cryptauth.ToggleEasyUnlockResponse)
  return false;
#undef DO_
}

void ToggleEasyUnlockResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:cryptauth.ToggleEasyUnlockResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:cryptauth.ToggleEasyUnlockResponse)
}

int ToggleEasyUnlockResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:cryptauth.ToggleEasyUnlockResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ToggleEasyUnlockResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ToggleEasyUnlockResponse*>(&from));
}

void ToggleEasyUnlockResponse::MergeFrom(const ToggleEasyUnlockResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:cryptauth.ToggleEasyUnlockResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ToggleEasyUnlockResponse::CopyFrom(const ToggleEasyUnlockResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:cryptauth.ToggleEasyUnlockResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ToggleEasyUnlockResponse::IsInitialized() const {

  return true;
}

void ToggleEasyUnlockResponse::Swap(ToggleEasyUnlockResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ToggleEasyUnlockResponse::InternalSwap(ToggleEasyUnlockResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ToggleEasyUnlockResponse::GetTypeName() const {
  return "cryptauth.ToggleEasyUnlockResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ToggleEasyUnlockResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace cryptauth

// @@protoc_insertion_point(global_scope)
