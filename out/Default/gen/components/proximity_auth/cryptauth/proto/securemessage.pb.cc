// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: securemessage.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "securemessage.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace securemessage {

void protobuf_ShutdownFile_securemessage_2eproto() {
  delete SecureMessage::default_instance_;
  delete Header::default_instance_;
  delete HeaderAndBody::default_instance_;
  delete EcP256PublicKey::default_instance_;
  delete SimpleRsaPublicKey::default_instance_;
  delete DhPublicKey::default_instance_;
  delete GenericPublicKey::default_instance_;
  delete DeviceToDeviceMessage::default_instance_;
  delete InitiatorHello::default_instance_;
  delete ResponderHello::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_securemessage_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_securemessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  SecureMessage::default_instance_ = new SecureMessage();
  Header::default_instance_ = new Header();
  HeaderAndBody::default_instance_ = new HeaderAndBody();
  EcP256PublicKey::default_instance_ = new EcP256PublicKey();
  SimpleRsaPublicKey::default_instance_ = new SimpleRsaPublicKey();
  DhPublicKey::default_instance_ = new DhPublicKey();
  GenericPublicKey::default_instance_ = new GenericPublicKey();
  DeviceToDeviceMessage::default_instance_ = new DeviceToDeviceMessage();
  InitiatorHello::default_instance_ = new InitiatorHello();
  ResponderHello::default_instance_ = new ResponderHello();
  SecureMessage::default_instance_->InitAsDefaultInstance();
  Header::default_instance_->InitAsDefaultInstance();
  HeaderAndBody::default_instance_->InitAsDefaultInstance();
  EcP256PublicKey::default_instance_->InitAsDefaultInstance();
  SimpleRsaPublicKey::default_instance_->InitAsDefaultInstance();
  DhPublicKey::default_instance_->InitAsDefaultInstance();
  GenericPublicKey::default_instance_->InitAsDefaultInstance();
  DeviceToDeviceMessage::default_instance_->InitAsDefaultInstance();
  InitiatorHello::default_instance_->InitAsDefaultInstance();
  ResponderHello::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_securemessage_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_securemessage_2eproto_once_);
void protobuf_AddDesc_securemessage_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_securemessage_2eproto_once_,
                 &protobuf_AddDesc_securemessage_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_securemessage_2eproto {
  StaticDescriptorInitializer_securemessage_2eproto() {
    protobuf_AddDesc_securemessage_2eproto();
  }
} static_descriptor_initializer_securemessage_2eproto_;
#endif
bool SigScheme_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool EncScheme_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool PublicKeyType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
GOOGLE_ATTRIBUTE_NOINLINE static void MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForSecureMessage(
    SecureMessage* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SecureMessage::kHeaderAndBodyFieldNumber;
const int SecureMessage::kSignatureFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SecureMessage::SecureMessage()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:securemessage.SecureMessage)
}

void SecureMessage::InitAsDefaultInstance() {
}

SecureMessage::SecureMessage(const SecureMessage& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:securemessage.SecureMessage)
}

void SecureMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  header_and_body_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SecureMessage::~SecureMessage() {
  // @@protoc_insertion_point(destructor:securemessage.SecureMessage)
  SharedDtor();
}

void SecureMessage::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  header_and_body_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SecureMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SecureMessage& SecureMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_securemessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_securemessage_2eproto();
#endif
  return *default_instance_;
}

SecureMessage* SecureMessage::default_instance_ = NULL;

SecureMessage* SecureMessage::New(::google::protobuf::Arena* arena) const {
  SecureMessage* n = new SecureMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SecureMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:securemessage.SecureMessage)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header_and_body()) {
      header_and_body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_signature()) {
      signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SecureMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSecureMessage, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:securemessage.SecureMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes header_and_body = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_header_and_body()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_signature;
        break;
      }

      // required bytes signature = 2;
      case 2: {
        if (tag == 18) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:securemessage.SecureMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:securemessage.SecureMessage)
  return false;
#undef DO_
}

void SecureMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:securemessage.SecureMessage)
  // required bytes header_and_body = 1;
  if (has_header_and_body()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->header_and_body(), output);
  }

  // required bytes signature = 2;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->signature(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:securemessage.SecureMessage)
}

int SecureMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:securemessage.SecureMessage)
  int total_size = 0;

  if (has_header_and_body()) {
    // required bytes header_and_body = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->header_and_body());
  }

  if (has_signature()) {
    // required bytes signature = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->signature());
  }

  return total_size;
}
int SecureMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:securemessage.SecureMessage)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes header_and_body = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->header_and_body());

    // required bytes signature = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->signature());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SecureMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SecureMessage*>(&from));
}

void SecureMessage::MergeFrom(const SecureMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:securemessage.SecureMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header_and_body()) {
      set_has_header_and_body();
      header_and_body_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.header_and_body_);
    }
    if (from.has_signature()) {
      set_has_signature();
      signature_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.signature_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SecureMessage::CopyFrom(const SecureMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:securemessage.SecureMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SecureMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SecureMessage::Swap(SecureMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SecureMessage::InternalSwap(SecureMessage* other) {
  header_and_body_.Swap(&other->header_and_body_);
  signature_.Swap(&other->signature_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SecureMessage::GetTypeName() const {
  return "securemessage.SecureMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SecureMessage

// required bytes header_and_body = 1;
bool SecureMessage::has_header_and_body() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SecureMessage::set_has_header_and_body() {
  _has_bits_[0] |= 0x00000001u;
}
void SecureMessage::clear_has_header_and_body() {
  _has_bits_[0] &= ~0x00000001u;
}
void SecureMessage::clear_header_and_body() {
  header_and_body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_header_and_body();
}
 const ::std::string& SecureMessage::header_and_body() const {
  // @@protoc_insertion_point(field_get:securemessage.SecureMessage.header_and_body)
  return header_and_body_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SecureMessage::set_header_and_body(const ::std::string& value) {
  set_has_header_and_body();
  header_and_body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.SecureMessage.header_and_body)
}
 void SecureMessage::set_header_and_body(const char* value) {
  set_has_header_and_body();
  header_and_body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.SecureMessage.header_and_body)
}
 void SecureMessage::set_header_and_body(const void* value, size_t size) {
  set_has_header_and_body();
  header_and_body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.SecureMessage.header_and_body)
}
 ::std::string* SecureMessage::mutable_header_and_body() {
  set_has_header_and_body();
  // @@protoc_insertion_point(field_mutable:securemessage.SecureMessage.header_and_body)
  return header_and_body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SecureMessage::release_header_and_body() {
  // @@protoc_insertion_point(field_release:securemessage.SecureMessage.header_and_body)
  clear_has_header_and_body();
  return header_and_body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SecureMessage::set_allocated_header_and_body(::std::string* header_and_body) {
  if (header_and_body != NULL) {
    set_has_header_and_body();
  } else {
    clear_has_header_and_body();
  }
  header_and_body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), header_and_body);
  // @@protoc_insertion_point(field_set_allocated:securemessage.SecureMessage.header_and_body)
}

// required bytes signature = 2;
bool SecureMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SecureMessage::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
void SecureMessage::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
void SecureMessage::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
 const ::std::string& SecureMessage::signature() const {
  // @@protoc_insertion_point(field_get:securemessage.SecureMessage.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SecureMessage::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.SecureMessage.signature)
}
 void SecureMessage::set_signature(const char* value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.SecureMessage.signature)
}
 void SecureMessage::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.SecureMessage.signature)
}
 ::std::string* SecureMessage::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:securemessage.SecureMessage.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SecureMessage::release_signature() {
  // @@protoc_insertion_point(field_release:securemessage.SecureMessage.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SecureMessage::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:securemessage.SecureMessage.signature)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForHeader(
    Header* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Header::kSignatureSchemeFieldNumber;
const int Header::kEncryptionSchemeFieldNumber;
const int Header::kVerificationKeyIdFieldNumber;
const int Header::kDecryptionKeyIdFieldNumber;
const int Header::kIvFieldNumber;
const int Header::kPublicMetadataFieldNumber;
const int Header::kAssociatedDataLengthFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Header::Header()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:securemessage.Header)
}

void Header::InitAsDefaultInstance() {
}

Header::Header(const Header& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:securemessage.Header)
}

void Header::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  signature_scheme_ = 1;
  encryption_scheme_ = 1;
  verification_key_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  decryption_key_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iv_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_metadata_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  associated_data_length_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Header::~Header() {
  // @@protoc_insertion_point(destructor:securemessage.Header)
  SharedDtor();
}

void Header::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  verification_key_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  decryption_key_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iv_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_metadata_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Header::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Header& Header::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_securemessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_securemessage_2eproto();
#endif
  return *default_instance_;
}

Header* Header::default_instance_ = NULL;

Header* Header::New(::google::protobuf::Arena* arena) const {
  Header* n = new Header;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Header::Clear() {
// @@protoc_insertion_point(message_clear_start:securemessage.Header)
  if (_has_bits_[0 / 32] & 127u) {
    signature_scheme_ = 1;
    encryption_scheme_ = 1;
    if (has_verification_key_id()) {
      verification_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_decryption_key_id()) {
      decryption_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_iv()) {
      iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_public_metadata()) {
      public_metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    associated_data_length_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Header::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForHeader, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:securemessage.Header)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .securemessage.SigScheme signature_scheme = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::securemessage::SigScheme_IsValid(value)) {
            set_signature_scheme(static_cast< ::securemessage::SigScheme >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_encryption_scheme;
        break;
      }

      // required .securemessage.EncScheme encryption_scheme = 2;
      case 2: {
        if (tag == 16) {
         parse_encryption_scheme:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::securemessage::EncScheme_IsValid(value)) {
            set_encryption_scheme(static_cast< ::securemessage::EncScheme >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_verification_key_id;
        break;
      }

      // optional bytes verification_key_id = 3;
      case 3: {
        if (tag == 26) {
         parse_verification_key_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_verification_key_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_decryption_key_id;
        break;
      }

      // optional bytes decryption_key_id = 4;
      case 4: {
        if (tag == 34) {
         parse_decryption_key_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_decryption_key_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_iv;
        break;
      }

      // optional bytes iv = 5;
      case 5: {
        if (tag == 42) {
         parse_iv:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_iv()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_public_metadata;
        break;
      }

      // optional bytes public_metadata = 6;
      case 6: {
        if (tag == 50) {
         parse_public_metadata:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_metadata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_associated_data_length;
        break;
      }

      // optional uint32 associated_data_length = 7 [default = 0];
      case 7: {
        if (tag == 56) {
         parse_associated_data_length:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &associated_data_length_)));
          set_has_associated_data_length();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:securemessage.Header)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:securemessage.Header)
  return false;
#undef DO_
}

void Header::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:securemessage.Header)
  // required .securemessage.SigScheme signature_scheme = 1;
  if (has_signature_scheme()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->signature_scheme(), output);
  }

  // required .securemessage.EncScheme encryption_scheme = 2;
  if (has_encryption_scheme()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->encryption_scheme(), output);
  }

  // optional bytes verification_key_id = 3;
  if (has_verification_key_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->verification_key_id(), output);
  }

  // optional bytes decryption_key_id = 4;
  if (has_decryption_key_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->decryption_key_id(), output);
  }

  // optional bytes iv = 5;
  if (has_iv()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->iv(), output);
  }

  // optional bytes public_metadata = 6;
  if (has_public_metadata()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->public_metadata(), output);
  }

  // optional uint32 associated_data_length = 7 [default = 0];
  if (has_associated_data_length()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->associated_data_length(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:securemessage.Header)
}

int Header::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:securemessage.Header)
  int total_size = 0;

  if (has_signature_scheme()) {
    // required .securemessage.SigScheme signature_scheme = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->signature_scheme());
  }

  if (has_encryption_scheme()) {
    // required .securemessage.EncScheme encryption_scheme = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->encryption_scheme());
  }

  return total_size;
}
int Header::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:securemessage.Header)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .securemessage.SigScheme signature_scheme = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->signature_scheme());

    // required .securemessage.EncScheme encryption_scheme = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->encryption_scheme());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[2 / 32] & 124u) {
    // optional bytes verification_key_id = 3;
    if (has_verification_key_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->verification_key_id());
    }

    // optional bytes decryption_key_id = 4;
    if (has_decryption_key_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->decryption_key_id());
    }

    // optional bytes iv = 5;
    if (has_iv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->iv());
    }

    // optional bytes public_metadata = 6;
    if (has_public_metadata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_metadata());
    }

    // optional uint32 associated_data_length = 7 [default = 0];
    if (has_associated_data_length()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->associated_data_length());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Header::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Header*>(&from));
}

void Header::MergeFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:securemessage.Header)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signature_scheme()) {
      set_signature_scheme(from.signature_scheme());
    }
    if (from.has_encryption_scheme()) {
      set_encryption_scheme(from.encryption_scheme());
    }
    if (from.has_verification_key_id()) {
      set_has_verification_key_id();
      verification_key_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.verification_key_id_);
    }
    if (from.has_decryption_key_id()) {
      set_has_decryption_key_id();
      decryption_key_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.decryption_key_id_);
    }
    if (from.has_iv()) {
      set_has_iv();
      iv_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.iv_);
    }
    if (from.has_public_metadata()) {
      set_has_public_metadata();
      public_metadata_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.public_metadata_);
    }
    if (from.has_associated_data_length()) {
      set_associated_data_length(from.associated_data_length());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Header::CopyFrom(const Header& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:securemessage.Header)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Header::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Header::Swap(Header* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Header::InternalSwap(Header* other) {
  std::swap(signature_scheme_, other->signature_scheme_);
  std::swap(encryption_scheme_, other->encryption_scheme_);
  verification_key_id_.Swap(&other->verification_key_id_);
  decryption_key_id_.Swap(&other->decryption_key_id_);
  iv_.Swap(&other->iv_);
  public_metadata_.Swap(&other->public_metadata_);
  std::swap(associated_data_length_, other->associated_data_length_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Header::GetTypeName() const {
  return "securemessage.Header";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Header

// required .securemessage.SigScheme signature_scheme = 1;
bool Header::has_signature_scheme() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Header::set_has_signature_scheme() {
  _has_bits_[0] |= 0x00000001u;
}
void Header::clear_has_signature_scheme() {
  _has_bits_[0] &= ~0x00000001u;
}
void Header::clear_signature_scheme() {
  signature_scheme_ = 1;
  clear_has_signature_scheme();
}
 ::securemessage::SigScheme Header::signature_scheme() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.signature_scheme)
  return static_cast< ::securemessage::SigScheme >(signature_scheme_);
}
 void Header::set_signature_scheme(::securemessage::SigScheme value) {
  assert(::securemessage::SigScheme_IsValid(value));
  set_has_signature_scheme();
  signature_scheme_ = value;
  // @@protoc_insertion_point(field_set:securemessage.Header.signature_scheme)
}

// required .securemessage.EncScheme encryption_scheme = 2;
bool Header::has_encryption_scheme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Header::set_has_encryption_scheme() {
  _has_bits_[0] |= 0x00000002u;
}
void Header::clear_has_encryption_scheme() {
  _has_bits_[0] &= ~0x00000002u;
}
void Header::clear_encryption_scheme() {
  encryption_scheme_ = 1;
  clear_has_encryption_scheme();
}
 ::securemessage::EncScheme Header::encryption_scheme() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.encryption_scheme)
  return static_cast< ::securemessage::EncScheme >(encryption_scheme_);
}
 void Header::set_encryption_scheme(::securemessage::EncScheme value) {
  assert(::securemessage::EncScheme_IsValid(value));
  set_has_encryption_scheme();
  encryption_scheme_ = value;
  // @@protoc_insertion_point(field_set:securemessage.Header.encryption_scheme)
}

// optional bytes verification_key_id = 3;
bool Header::has_verification_key_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Header::set_has_verification_key_id() {
  _has_bits_[0] |= 0x00000004u;
}
void Header::clear_has_verification_key_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void Header::clear_verification_key_id() {
  verification_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verification_key_id();
}
 const ::std::string& Header::verification_key_id() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.verification_key_id)
  return verification_key_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Header::set_verification_key_id(const ::std::string& value) {
  set_has_verification_key_id();
  verification_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.Header.verification_key_id)
}
 void Header::set_verification_key_id(const char* value) {
  set_has_verification_key_id();
  verification_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.Header.verification_key_id)
}
 void Header::set_verification_key_id(const void* value, size_t size) {
  set_has_verification_key_id();
  verification_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.Header.verification_key_id)
}
 ::std::string* Header::mutable_verification_key_id() {
  set_has_verification_key_id();
  // @@protoc_insertion_point(field_mutable:securemessage.Header.verification_key_id)
  return verification_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Header::release_verification_key_id() {
  // @@protoc_insertion_point(field_release:securemessage.Header.verification_key_id)
  clear_has_verification_key_id();
  return verification_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Header::set_allocated_verification_key_id(::std::string* verification_key_id) {
  if (verification_key_id != NULL) {
    set_has_verification_key_id();
  } else {
    clear_has_verification_key_id();
  }
  verification_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verification_key_id);
  // @@protoc_insertion_point(field_set_allocated:securemessage.Header.verification_key_id)
}

// optional bytes decryption_key_id = 4;
bool Header::has_decryption_key_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Header::set_has_decryption_key_id() {
  _has_bits_[0] |= 0x00000008u;
}
void Header::clear_has_decryption_key_id() {
  _has_bits_[0] &= ~0x00000008u;
}
void Header::clear_decryption_key_id() {
  decryption_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_decryption_key_id();
}
 const ::std::string& Header::decryption_key_id() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.decryption_key_id)
  return decryption_key_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Header::set_decryption_key_id(const ::std::string& value) {
  set_has_decryption_key_id();
  decryption_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.Header.decryption_key_id)
}
 void Header::set_decryption_key_id(const char* value) {
  set_has_decryption_key_id();
  decryption_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.Header.decryption_key_id)
}
 void Header::set_decryption_key_id(const void* value, size_t size) {
  set_has_decryption_key_id();
  decryption_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.Header.decryption_key_id)
}
 ::std::string* Header::mutable_decryption_key_id() {
  set_has_decryption_key_id();
  // @@protoc_insertion_point(field_mutable:securemessage.Header.decryption_key_id)
  return decryption_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Header::release_decryption_key_id() {
  // @@protoc_insertion_point(field_release:securemessage.Header.decryption_key_id)
  clear_has_decryption_key_id();
  return decryption_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Header::set_allocated_decryption_key_id(::std::string* decryption_key_id) {
  if (decryption_key_id != NULL) {
    set_has_decryption_key_id();
  } else {
    clear_has_decryption_key_id();
  }
  decryption_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), decryption_key_id);
  // @@protoc_insertion_point(field_set_allocated:securemessage.Header.decryption_key_id)
}

// optional bytes iv = 5;
bool Header::has_iv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Header::set_has_iv() {
  _has_bits_[0] |= 0x00000010u;
}
void Header::clear_has_iv() {
  _has_bits_[0] &= ~0x00000010u;
}
void Header::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_iv();
}
 const ::std::string& Header::iv() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.iv)
  return iv_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Header::set_iv(const ::std::string& value) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.Header.iv)
}
 void Header::set_iv(const char* value) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.Header.iv)
}
 void Header::set_iv(const void* value, size_t size) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.Header.iv)
}
 ::std::string* Header::mutable_iv() {
  set_has_iv();
  // @@protoc_insertion_point(field_mutable:securemessage.Header.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Header::release_iv() {
  // @@protoc_insertion_point(field_release:securemessage.Header.iv)
  clear_has_iv();
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Header::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    set_has_iv();
  } else {
    clear_has_iv();
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:securemessage.Header.iv)
}

// optional bytes public_metadata = 6;
bool Header::has_public_metadata() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Header::set_has_public_metadata() {
  _has_bits_[0] |= 0x00000020u;
}
void Header::clear_has_public_metadata() {
  _has_bits_[0] &= ~0x00000020u;
}
void Header::clear_public_metadata() {
  public_metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_metadata();
}
 const ::std::string& Header::public_metadata() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.public_metadata)
  return public_metadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Header::set_public_metadata(const ::std::string& value) {
  set_has_public_metadata();
  public_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.Header.public_metadata)
}
 void Header::set_public_metadata(const char* value) {
  set_has_public_metadata();
  public_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.Header.public_metadata)
}
 void Header::set_public_metadata(const void* value, size_t size) {
  set_has_public_metadata();
  public_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.Header.public_metadata)
}
 ::std::string* Header::mutable_public_metadata() {
  set_has_public_metadata();
  // @@protoc_insertion_point(field_mutable:securemessage.Header.public_metadata)
  return public_metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Header::release_public_metadata() {
  // @@protoc_insertion_point(field_release:securemessage.Header.public_metadata)
  clear_has_public_metadata();
  return public_metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Header::set_allocated_public_metadata(::std::string* public_metadata) {
  if (public_metadata != NULL) {
    set_has_public_metadata();
  } else {
    clear_has_public_metadata();
  }
  public_metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_metadata);
  // @@protoc_insertion_point(field_set_allocated:securemessage.Header.public_metadata)
}

// optional uint32 associated_data_length = 7 [default = 0];
bool Header::has_associated_data_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Header::set_has_associated_data_length() {
  _has_bits_[0] |= 0x00000040u;
}
void Header::clear_has_associated_data_length() {
  _has_bits_[0] &= ~0x00000040u;
}
void Header::clear_associated_data_length() {
  associated_data_length_ = 0u;
  clear_has_associated_data_length();
}
 ::google::protobuf::uint32 Header::associated_data_length() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.associated_data_length)
  return associated_data_length_;
}
 void Header::set_associated_data_length(::google::protobuf::uint32 value) {
  set_has_associated_data_length();
  associated_data_length_ = value;
  // @@protoc_insertion_point(field_set:securemessage.Header.associated_data_length)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForHeaderAndBody(
    HeaderAndBody* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HeaderAndBody::kHeaderFieldNumber;
const int HeaderAndBody::kBodyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HeaderAndBody::HeaderAndBody()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:securemessage.HeaderAndBody)
}

void HeaderAndBody::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  header_ = const_cast< ::securemessage::Header*>(
      ::securemessage::Header::internal_default_instance());
#else
  header_ = const_cast< ::securemessage::Header*>(&::securemessage::Header::default_instance());
#endif
}

HeaderAndBody::HeaderAndBody(const HeaderAndBody& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:securemessage.HeaderAndBody)
}

void HeaderAndBody::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  header_ = NULL;
  body_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeaderAndBody::~HeaderAndBody() {
  // @@protoc_insertion_point(destructor:securemessage.HeaderAndBody)
  SharedDtor();
}

void HeaderAndBody::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  body_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete header_;
  }
}

void HeaderAndBody::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HeaderAndBody& HeaderAndBody::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_securemessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_securemessage_2eproto();
#endif
  return *default_instance_;
}

HeaderAndBody* HeaderAndBody::default_instance_ = NULL;

HeaderAndBody* HeaderAndBody::New(::google::protobuf::Arena* arena) const {
  HeaderAndBody* n = new HeaderAndBody;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HeaderAndBody::Clear() {
// @@protoc_insertion_point(message_clear_start:securemessage.HeaderAndBody)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_header()) {
      if (header_ != NULL) header_->::securemessage::Header::Clear();
    }
    if (has_body()) {
      body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool HeaderAndBody::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForHeaderAndBody, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:securemessage.HeaderAndBody)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .securemessage.Header header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_body;
        break;
      }

      // required bytes body = 2;
      case 2: {
        if (tag == 18) {
         parse_body:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_body()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:securemessage.HeaderAndBody)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:securemessage.HeaderAndBody)
  return false;
#undef DO_
}

void HeaderAndBody::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:securemessage.HeaderAndBody)
  // required .securemessage.Header header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->header_, output);
  }

  // required bytes body = 2;
  if (has_body()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->body(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:securemessage.HeaderAndBody)
}

int HeaderAndBody::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:securemessage.HeaderAndBody)
  int total_size = 0;

  if (has_header()) {
    // required .securemessage.Header header = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  if (has_body()) {
    // required bytes body = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->body());
  }

  return total_size;
}
int HeaderAndBody::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:securemessage.HeaderAndBody)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .securemessage.Header header = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);

    // required bytes body = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->body());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeaderAndBody::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HeaderAndBody*>(&from));
}

void HeaderAndBody::MergeFrom(const HeaderAndBody& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:securemessage.HeaderAndBody)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_header()) {
      mutable_header()->::securemessage::Header::MergeFrom(from.header());
    }
    if (from.has_body()) {
      set_has_body();
      body_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.body_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void HeaderAndBody::CopyFrom(const HeaderAndBody& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:securemessage.HeaderAndBody)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeaderAndBody::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_header()) {
    if (!this->header_->IsInitialized()) return false;
  }
  return true;
}

void HeaderAndBody::Swap(HeaderAndBody* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HeaderAndBody::InternalSwap(HeaderAndBody* other) {
  std::swap(header_, other->header_);
  body_.Swap(&other->body_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string HeaderAndBody::GetTypeName() const {
  return "securemessage.HeaderAndBody";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HeaderAndBody

// required .securemessage.Header header = 1;
bool HeaderAndBody::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HeaderAndBody::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void HeaderAndBody::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void HeaderAndBody::clear_header() {
  if (header_ != NULL) header_->::securemessage::Header::Clear();
  clear_has_header();
}
const ::securemessage::Header& HeaderAndBody::header() const {
  // @@protoc_insertion_point(field_get:securemessage.HeaderAndBody.header)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return header_ != NULL ? *header_ : *default_instance().header_;
#else
  return header_ != NULL ? *header_ : *default_instance_->header_;
#endif
}
::securemessage::Header* HeaderAndBody::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::securemessage::Header;
  }
  // @@protoc_insertion_point(field_mutable:securemessage.HeaderAndBody.header)
  return header_;
}
::securemessage::Header* HeaderAndBody::release_header() {
  // @@protoc_insertion_point(field_release:securemessage.HeaderAndBody.header)
  clear_has_header();
  ::securemessage::Header* temp = header_;
  header_ = NULL;
  return temp;
}
void HeaderAndBody::set_allocated_header(::securemessage::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:securemessage.HeaderAndBody.header)
}

// required bytes body = 2;
bool HeaderAndBody::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void HeaderAndBody::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
void HeaderAndBody::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
void HeaderAndBody::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_body();
}
 const ::std::string& HeaderAndBody::body() const {
  // @@protoc_insertion_point(field_get:securemessage.HeaderAndBody.body)
  return body_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void HeaderAndBody::set_body(const ::std::string& value) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.HeaderAndBody.body)
}
 void HeaderAndBody::set_body(const char* value) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.HeaderAndBody.body)
}
 void HeaderAndBody::set_body(const void* value, size_t size) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.HeaderAndBody.body)
}
 ::std::string* HeaderAndBody::mutable_body() {
  set_has_body();
  // @@protoc_insertion_point(field_mutable:securemessage.HeaderAndBody.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* HeaderAndBody::release_body() {
  // @@protoc_insertion_point(field_release:securemessage.HeaderAndBody.body)
  clear_has_body();
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void HeaderAndBody::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    set_has_body();
  } else {
    clear_has_body();
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:securemessage.HeaderAndBody.body)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForEcP256PublicKey(
    EcP256PublicKey* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EcP256PublicKey::kXFieldNumber;
const int EcP256PublicKey::kYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EcP256PublicKey::EcP256PublicKey()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:securemessage.EcP256PublicKey)
}

void EcP256PublicKey::InitAsDefaultInstance() {
}

EcP256PublicKey::EcP256PublicKey(const EcP256PublicKey& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:securemessage.EcP256PublicKey)
}

void EcP256PublicKey::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  x_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  y_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EcP256PublicKey::~EcP256PublicKey() {
  // @@protoc_insertion_point(destructor:securemessage.EcP256PublicKey)
  SharedDtor();
}

void EcP256PublicKey::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  x_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  y_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EcP256PublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EcP256PublicKey& EcP256PublicKey::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_securemessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_securemessage_2eproto();
#endif
  return *default_instance_;
}

EcP256PublicKey* EcP256PublicKey::default_instance_ = NULL;

EcP256PublicKey* EcP256PublicKey::New(::google::protobuf::Arena* arena) const {
  EcP256PublicKey* n = new EcP256PublicKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EcP256PublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:securemessage.EcP256PublicKey)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_x()) {
      x_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_y()) {
      y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool EcP256PublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForEcP256PublicKey, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:securemessage.EcP256PublicKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes x = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_x()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_y;
        break;
      }

      // required bytes y = 2;
      case 2: {
        if (tag == 18) {
         parse_y:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_y()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:securemessage.EcP256PublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:securemessage.EcP256PublicKey)
  return false;
#undef DO_
}

void EcP256PublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:securemessage.EcP256PublicKey)
  // required bytes x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->x(), output);
  }

  // required bytes y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->y(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:securemessage.EcP256PublicKey)
}

int EcP256PublicKey::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:securemessage.EcP256PublicKey)
  int total_size = 0;

  if (has_x()) {
    // required bytes x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->x());
  }

  if (has_y()) {
    // required bytes y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->y());
  }

  return total_size;
}
int EcP256PublicKey::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:securemessage.EcP256PublicKey)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes x = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->x());

    // required bytes y = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EcP256PublicKey::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EcP256PublicKey*>(&from));
}

void EcP256PublicKey::MergeFrom(const EcP256PublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:securemessage.EcP256PublicKey)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_has_x();
      x_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.x_);
    }
    if (from.has_y()) {
      set_has_y();
      y_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.y_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void EcP256PublicKey::CopyFrom(const EcP256PublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:securemessage.EcP256PublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EcP256PublicKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void EcP256PublicKey::Swap(EcP256PublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EcP256PublicKey::InternalSwap(EcP256PublicKey* other) {
  x_.Swap(&other->x_);
  y_.Swap(&other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string EcP256PublicKey::GetTypeName() const {
  return "securemessage.EcP256PublicKey";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EcP256PublicKey

// required bytes x = 1;
bool EcP256PublicKey::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EcP256PublicKey::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void EcP256PublicKey::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void EcP256PublicKey::clear_x() {
  x_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_x();
}
 const ::std::string& EcP256PublicKey::x() const {
  // @@protoc_insertion_point(field_get:securemessage.EcP256PublicKey.x)
  return x_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void EcP256PublicKey::set_x(const ::std::string& value) {
  set_has_x();
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.EcP256PublicKey.x)
}
 void EcP256PublicKey::set_x(const char* value) {
  set_has_x();
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.EcP256PublicKey.x)
}
 void EcP256PublicKey::set_x(const void* value, size_t size) {
  set_has_x();
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.EcP256PublicKey.x)
}
 ::std::string* EcP256PublicKey::mutable_x() {
  set_has_x();
  // @@protoc_insertion_point(field_mutable:securemessage.EcP256PublicKey.x)
  return x_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* EcP256PublicKey::release_x() {
  // @@protoc_insertion_point(field_release:securemessage.EcP256PublicKey.x)
  clear_has_x();
  return x_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void EcP256PublicKey::set_allocated_x(::std::string* x) {
  if (x != NULL) {
    set_has_x();
  } else {
    clear_has_x();
  }
  x_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), x);
  // @@protoc_insertion_point(field_set_allocated:securemessage.EcP256PublicKey.x)
}

// required bytes y = 2;
bool EcP256PublicKey::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EcP256PublicKey::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void EcP256PublicKey::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void EcP256PublicKey::clear_y() {
  y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_y();
}
 const ::std::string& EcP256PublicKey::y() const {
  // @@protoc_insertion_point(field_get:securemessage.EcP256PublicKey.y)
  return y_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void EcP256PublicKey::set_y(const ::std::string& value) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.EcP256PublicKey.y)
}
 void EcP256PublicKey::set_y(const char* value) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.EcP256PublicKey.y)
}
 void EcP256PublicKey::set_y(const void* value, size_t size) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.EcP256PublicKey.y)
}
 ::std::string* EcP256PublicKey::mutable_y() {
  set_has_y();
  // @@protoc_insertion_point(field_mutable:securemessage.EcP256PublicKey.y)
  return y_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* EcP256PublicKey::release_y() {
  // @@protoc_insertion_point(field_release:securemessage.EcP256PublicKey.y)
  clear_has_y();
  return y_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void EcP256PublicKey::set_allocated_y(::std::string* y) {
  if (y != NULL) {
    set_has_y();
  } else {
    clear_has_y();
  }
  y_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:securemessage.EcP256PublicKey.y)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForSimpleRsaPublicKey(
    SimpleRsaPublicKey* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SimpleRsaPublicKey::kNFieldNumber;
const int SimpleRsaPublicKey::kEFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SimpleRsaPublicKey::SimpleRsaPublicKey()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:securemessage.SimpleRsaPublicKey)
}

void SimpleRsaPublicKey::InitAsDefaultInstance() {
}

SimpleRsaPublicKey::SimpleRsaPublicKey(const SimpleRsaPublicKey& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:securemessage.SimpleRsaPublicKey)
}

void SimpleRsaPublicKey::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  n_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  e_ = 65537;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SimpleRsaPublicKey::~SimpleRsaPublicKey() {
  // @@protoc_insertion_point(destructor:securemessage.SimpleRsaPublicKey)
  SharedDtor();
}

void SimpleRsaPublicKey::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  n_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SimpleRsaPublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SimpleRsaPublicKey& SimpleRsaPublicKey::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_securemessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_securemessage_2eproto();
#endif
  return *default_instance_;
}

SimpleRsaPublicKey* SimpleRsaPublicKey::default_instance_ = NULL;

SimpleRsaPublicKey* SimpleRsaPublicKey::New(::google::protobuf::Arena* arena) const {
  SimpleRsaPublicKey* n = new SimpleRsaPublicKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SimpleRsaPublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:securemessage.SimpleRsaPublicKey)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_n()) {
      n_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    e_ = 65537;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SimpleRsaPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSimpleRsaPublicKey, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:securemessage.SimpleRsaPublicKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes n = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_n()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_e;
        break;
      }

      // optional int32 e = 2 [default = 65537];
      case 2: {
        if (tag == 16) {
         parse_e:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &e_)));
          set_has_e();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:securemessage.SimpleRsaPublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:securemessage.SimpleRsaPublicKey)
  return false;
#undef DO_
}

void SimpleRsaPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:securemessage.SimpleRsaPublicKey)
  // required bytes n = 1;
  if (has_n()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->n(), output);
  }

  // optional int32 e = 2 [default = 65537];
  if (has_e()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->e(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:securemessage.SimpleRsaPublicKey)
}

int SimpleRsaPublicKey::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:securemessage.SimpleRsaPublicKey)
  int total_size = 0;

  // required bytes n = 1;
  if (has_n()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->n());
  }
  // optional int32 e = 2 [default = 65537];
  if (has_e()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->e());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SimpleRsaPublicKey::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SimpleRsaPublicKey*>(&from));
}

void SimpleRsaPublicKey::MergeFrom(const SimpleRsaPublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:securemessage.SimpleRsaPublicKey)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_n()) {
      set_has_n();
      n_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.n_);
    }
    if (from.has_e()) {
      set_e(from.e());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SimpleRsaPublicKey::CopyFrom(const SimpleRsaPublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:securemessage.SimpleRsaPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleRsaPublicKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SimpleRsaPublicKey::Swap(SimpleRsaPublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SimpleRsaPublicKey::InternalSwap(SimpleRsaPublicKey* other) {
  n_.Swap(&other->n_);
  std::swap(e_, other->e_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SimpleRsaPublicKey::GetTypeName() const {
  return "securemessage.SimpleRsaPublicKey";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SimpleRsaPublicKey

// required bytes n = 1;
bool SimpleRsaPublicKey::has_n() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SimpleRsaPublicKey::set_has_n() {
  _has_bits_[0] |= 0x00000001u;
}
void SimpleRsaPublicKey::clear_has_n() {
  _has_bits_[0] &= ~0x00000001u;
}
void SimpleRsaPublicKey::clear_n() {
  n_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_n();
}
 const ::std::string& SimpleRsaPublicKey::n() const {
  // @@protoc_insertion_point(field_get:securemessage.SimpleRsaPublicKey.n)
  return n_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SimpleRsaPublicKey::set_n(const ::std::string& value) {
  set_has_n();
  n_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.SimpleRsaPublicKey.n)
}
 void SimpleRsaPublicKey::set_n(const char* value) {
  set_has_n();
  n_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.SimpleRsaPublicKey.n)
}
 void SimpleRsaPublicKey::set_n(const void* value, size_t size) {
  set_has_n();
  n_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.SimpleRsaPublicKey.n)
}
 ::std::string* SimpleRsaPublicKey::mutable_n() {
  set_has_n();
  // @@protoc_insertion_point(field_mutable:securemessage.SimpleRsaPublicKey.n)
  return n_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SimpleRsaPublicKey::release_n() {
  // @@protoc_insertion_point(field_release:securemessage.SimpleRsaPublicKey.n)
  clear_has_n();
  return n_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SimpleRsaPublicKey::set_allocated_n(::std::string* n) {
  if (n != NULL) {
    set_has_n();
  } else {
    clear_has_n();
  }
  n_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), n);
  // @@protoc_insertion_point(field_set_allocated:securemessage.SimpleRsaPublicKey.n)
}

// optional int32 e = 2 [default = 65537];
bool SimpleRsaPublicKey::has_e() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SimpleRsaPublicKey::set_has_e() {
  _has_bits_[0] |= 0x00000002u;
}
void SimpleRsaPublicKey::clear_has_e() {
  _has_bits_[0] &= ~0x00000002u;
}
void SimpleRsaPublicKey::clear_e() {
  e_ = 65537;
  clear_has_e();
}
 ::google::protobuf::int32 SimpleRsaPublicKey::e() const {
  // @@protoc_insertion_point(field_get:securemessage.SimpleRsaPublicKey.e)
  return e_;
}
 void SimpleRsaPublicKey::set_e(::google::protobuf::int32 value) {
  set_has_e();
  e_ = value;
  // @@protoc_insertion_point(field_set:securemessage.SimpleRsaPublicKey.e)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDhPublicKey(
    DhPublicKey* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DhPublicKey::kYFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DhPublicKey::DhPublicKey()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:securemessage.DhPublicKey)
}

void DhPublicKey::InitAsDefaultInstance() {
}

DhPublicKey::DhPublicKey(const DhPublicKey& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:securemessage.DhPublicKey)
}

void DhPublicKey::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  y_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DhPublicKey::~DhPublicKey() {
  // @@protoc_insertion_point(destructor:securemessage.DhPublicKey)
  SharedDtor();
}

void DhPublicKey::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  y_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DhPublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DhPublicKey& DhPublicKey::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_securemessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_securemessage_2eproto();
#endif
  return *default_instance_;
}

DhPublicKey* DhPublicKey::default_instance_ = NULL;

DhPublicKey* DhPublicKey::New(::google::protobuf::Arena* arena) const {
  DhPublicKey* n = new DhPublicKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DhPublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:securemessage.DhPublicKey)
  if (has_y()) {
    y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DhPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDhPublicKey, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:securemessage.DhPublicKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes y = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_y()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:securemessage.DhPublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:securemessage.DhPublicKey)
  return false;
#undef DO_
}

void DhPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:securemessage.DhPublicKey)
  // required bytes y = 1;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->y(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:securemessage.DhPublicKey)
}

int DhPublicKey::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:securemessage.DhPublicKey)
  int total_size = 0;

  // required bytes y = 1;
  if (has_y()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->y());
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DhPublicKey::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DhPublicKey*>(&from));
}

void DhPublicKey::MergeFrom(const DhPublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:securemessage.DhPublicKey)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_y()) {
      set_has_y();
      y_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.y_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DhPublicKey::CopyFrom(const DhPublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:securemessage.DhPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DhPublicKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DhPublicKey::Swap(DhPublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DhPublicKey::InternalSwap(DhPublicKey* other) {
  y_.Swap(&other->y_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DhPublicKey::GetTypeName() const {
  return "securemessage.DhPublicKey";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DhPublicKey

// required bytes y = 1;
bool DhPublicKey::has_y() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DhPublicKey::set_has_y() {
  _has_bits_[0] |= 0x00000001u;
}
void DhPublicKey::clear_has_y() {
  _has_bits_[0] &= ~0x00000001u;
}
void DhPublicKey::clear_y() {
  y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_y();
}
 const ::std::string& DhPublicKey::y() const {
  // @@protoc_insertion_point(field_get:securemessage.DhPublicKey.y)
  return y_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DhPublicKey::set_y(const ::std::string& value) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.DhPublicKey.y)
}
 void DhPublicKey::set_y(const char* value) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.DhPublicKey.y)
}
 void DhPublicKey::set_y(const void* value, size_t size) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.DhPublicKey.y)
}
 ::std::string* DhPublicKey::mutable_y() {
  set_has_y();
  // @@protoc_insertion_point(field_mutable:securemessage.DhPublicKey.y)
  return y_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DhPublicKey::release_y() {
  // @@protoc_insertion_point(field_release:securemessage.DhPublicKey.y)
  clear_has_y();
  return y_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DhPublicKey::set_allocated_y(::std::string* y) {
  if (y != NULL) {
    set_has_y();
  } else {
    clear_has_y();
  }
  y_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:securemessage.DhPublicKey.y)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForGenericPublicKey(
    GenericPublicKey* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GenericPublicKey::kTypeFieldNumber;
const int GenericPublicKey::kEcP256PublicKeyFieldNumber;
const int GenericPublicKey::kRsa2048PublicKeyFieldNumber;
const int GenericPublicKey::kDh2048PublicKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GenericPublicKey::GenericPublicKey()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:securemessage.GenericPublicKey)
}

void GenericPublicKey::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ec_p256_public_key_ = const_cast< ::securemessage::EcP256PublicKey*>(
      ::securemessage::EcP256PublicKey::internal_default_instance());
#else
  ec_p256_public_key_ = const_cast< ::securemessage::EcP256PublicKey*>(&::securemessage::EcP256PublicKey::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  rsa2048_public_key_ = const_cast< ::securemessage::SimpleRsaPublicKey*>(
      ::securemessage::SimpleRsaPublicKey::internal_default_instance());
#else
  rsa2048_public_key_ = const_cast< ::securemessage::SimpleRsaPublicKey*>(&::securemessage::SimpleRsaPublicKey::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dh2048_public_key_ = const_cast< ::securemessage::DhPublicKey*>(
      ::securemessage::DhPublicKey::internal_default_instance());
#else
  dh2048_public_key_ = const_cast< ::securemessage::DhPublicKey*>(&::securemessage::DhPublicKey::default_instance());
#endif
}

GenericPublicKey::GenericPublicKey(const GenericPublicKey& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:securemessage.GenericPublicKey)
}

void GenericPublicKey::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 1;
  ec_p256_public_key_ = NULL;
  rsa2048_public_key_ = NULL;
  dh2048_public_key_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GenericPublicKey::~GenericPublicKey() {
  // @@protoc_insertion_point(destructor:securemessage.GenericPublicKey)
  SharedDtor();
}

void GenericPublicKey::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete ec_p256_public_key_;
    delete rsa2048_public_key_;
    delete dh2048_public_key_;
  }
}

void GenericPublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GenericPublicKey& GenericPublicKey::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_securemessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_securemessage_2eproto();
#endif
  return *default_instance_;
}

GenericPublicKey* GenericPublicKey::default_instance_ = NULL;

GenericPublicKey* GenericPublicKey::New(::google::protobuf::Arena* arena) const {
  GenericPublicKey* n = new GenericPublicKey;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GenericPublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:securemessage.GenericPublicKey)
  if (_has_bits_[0 / 32] & 15u) {
    type_ = 1;
    if (has_ec_p256_public_key()) {
      if (ec_p256_public_key_ != NULL) ec_p256_public_key_->::securemessage::EcP256PublicKey::Clear();
    }
    if (has_rsa2048_public_key()) {
      if (rsa2048_public_key_ != NULL) rsa2048_public_key_->::securemessage::SimpleRsaPublicKey::Clear();
    }
    if (has_dh2048_public_key()) {
      if (dh2048_public_key_ != NULL) dh2048_public_key_->::securemessage::DhPublicKey::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GenericPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGenericPublicKey, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:securemessage.GenericPublicKey)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .securemessage.PublicKeyType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::securemessage::PublicKeyType_IsValid(value)) {
            set_type(static_cast< ::securemessage::PublicKeyType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ec_p256_public_key;
        break;
      }

      // optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;
      case 2: {
        if (tag == 18) {
         parse_ec_p256_public_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ec_p256_public_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_rsa2048_public_key;
        break;
      }

      // optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;
      case 3: {
        if (tag == 26) {
         parse_rsa2048_public_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rsa2048_public_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_dh2048_public_key;
        break;
      }

      // optional .securemessage.DhPublicKey dh2048_public_key = 4;
      case 4: {
        if (tag == 34) {
         parse_dh2048_public_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dh2048_public_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:securemessage.GenericPublicKey)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:securemessage.GenericPublicKey)
  return false;
#undef DO_
}

void GenericPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:securemessage.GenericPublicKey)
  // required .securemessage.PublicKeyType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;
  if (has_ec_p256_public_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->ec_p256_public_key_, output);
  }

  // optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;
  if (has_rsa2048_public_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->rsa2048_public_key_, output);
  }

  // optional .securemessage.DhPublicKey dh2048_public_key = 4;
  if (has_dh2048_public_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->dh2048_public_key_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:securemessage.GenericPublicKey)
}

int GenericPublicKey::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:securemessage.GenericPublicKey)
  int total_size = 0;

  // required .securemessage.PublicKeyType type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }
  if (_has_bits_[1 / 32] & 14u) {
    // optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;
    if (has_ec_p256_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->ec_p256_public_key_);
    }

    // optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;
    if (has_rsa2048_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->rsa2048_public_key_);
    }

    // optional .securemessage.DhPublicKey dh2048_public_key = 4;
    if (has_dh2048_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->dh2048_public_key_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GenericPublicKey::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GenericPublicKey*>(&from));
}

void GenericPublicKey::MergeFrom(const GenericPublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:securemessage.GenericPublicKey)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ec_p256_public_key()) {
      mutable_ec_p256_public_key()->::securemessage::EcP256PublicKey::MergeFrom(from.ec_p256_public_key());
    }
    if (from.has_rsa2048_public_key()) {
      mutable_rsa2048_public_key()->::securemessage::SimpleRsaPublicKey::MergeFrom(from.rsa2048_public_key());
    }
    if (from.has_dh2048_public_key()) {
      mutable_dh2048_public_key()->::securemessage::DhPublicKey::MergeFrom(from.dh2048_public_key());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GenericPublicKey::CopyFrom(const GenericPublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:securemessage.GenericPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenericPublicKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_ec_p256_public_key()) {
    if (!this->ec_p256_public_key_->IsInitialized()) return false;
  }
  if (has_rsa2048_public_key()) {
    if (!this->rsa2048_public_key_->IsInitialized()) return false;
  }
  if (has_dh2048_public_key()) {
    if (!this->dh2048_public_key_->IsInitialized()) return false;
  }
  return true;
}

void GenericPublicKey::Swap(GenericPublicKey* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GenericPublicKey::InternalSwap(GenericPublicKey* other) {
  std::swap(type_, other->type_);
  std::swap(ec_p256_public_key_, other->ec_p256_public_key_);
  std::swap(rsa2048_public_key_, other->rsa2048_public_key_);
  std::swap(dh2048_public_key_, other->dh2048_public_key_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GenericPublicKey::GetTypeName() const {
  return "securemessage.GenericPublicKey";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GenericPublicKey

// required .securemessage.PublicKeyType type = 1;
bool GenericPublicKey::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GenericPublicKey::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void GenericPublicKey::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void GenericPublicKey::clear_type() {
  type_ = 1;
  clear_has_type();
}
 ::securemessage::PublicKeyType GenericPublicKey::type() const {
  // @@protoc_insertion_point(field_get:securemessage.GenericPublicKey.type)
  return static_cast< ::securemessage::PublicKeyType >(type_);
}
 void GenericPublicKey::set_type(::securemessage::PublicKeyType value) {
  assert(::securemessage::PublicKeyType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:securemessage.GenericPublicKey.type)
}

// optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;
bool GenericPublicKey::has_ec_p256_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GenericPublicKey::set_has_ec_p256_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
void GenericPublicKey::clear_has_ec_p256_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
void GenericPublicKey::clear_ec_p256_public_key() {
  if (ec_p256_public_key_ != NULL) ec_p256_public_key_->::securemessage::EcP256PublicKey::Clear();
  clear_has_ec_p256_public_key();
}
const ::securemessage::EcP256PublicKey& GenericPublicKey::ec_p256_public_key() const {
  // @@protoc_insertion_point(field_get:securemessage.GenericPublicKey.ec_p256_public_key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ec_p256_public_key_ != NULL ? *ec_p256_public_key_ : *default_instance().ec_p256_public_key_;
#else
  return ec_p256_public_key_ != NULL ? *ec_p256_public_key_ : *default_instance_->ec_p256_public_key_;
#endif
}
::securemessage::EcP256PublicKey* GenericPublicKey::mutable_ec_p256_public_key() {
  set_has_ec_p256_public_key();
  if (ec_p256_public_key_ == NULL) {
    ec_p256_public_key_ = new ::securemessage::EcP256PublicKey;
  }
  // @@protoc_insertion_point(field_mutable:securemessage.GenericPublicKey.ec_p256_public_key)
  return ec_p256_public_key_;
}
::securemessage::EcP256PublicKey* GenericPublicKey::release_ec_p256_public_key() {
  // @@protoc_insertion_point(field_release:securemessage.GenericPublicKey.ec_p256_public_key)
  clear_has_ec_p256_public_key();
  ::securemessage::EcP256PublicKey* temp = ec_p256_public_key_;
  ec_p256_public_key_ = NULL;
  return temp;
}
void GenericPublicKey::set_allocated_ec_p256_public_key(::securemessage::EcP256PublicKey* ec_p256_public_key) {
  delete ec_p256_public_key_;
  ec_p256_public_key_ = ec_p256_public_key;
  if (ec_p256_public_key) {
    set_has_ec_p256_public_key();
  } else {
    clear_has_ec_p256_public_key();
  }
  // @@protoc_insertion_point(field_set_allocated:securemessage.GenericPublicKey.ec_p256_public_key)
}

// optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;
bool GenericPublicKey::has_rsa2048_public_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void GenericPublicKey::set_has_rsa2048_public_key() {
  _has_bits_[0] |= 0x00000004u;
}
void GenericPublicKey::clear_has_rsa2048_public_key() {
  _has_bits_[0] &= ~0x00000004u;
}
void GenericPublicKey::clear_rsa2048_public_key() {
  if (rsa2048_public_key_ != NULL) rsa2048_public_key_->::securemessage::SimpleRsaPublicKey::Clear();
  clear_has_rsa2048_public_key();
}
const ::securemessage::SimpleRsaPublicKey& GenericPublicKey::rsa2048_public_key() const {
  // @@protoc_insertion_point(field_get:securemessage.GenericPublicKey.rsa2048_public_key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rsa2048_public_key_ != NULL ? *rsa2048_public_key_ : *default_instance().rsa2048_public_key_;
#else
  return rsa2048_public_key_ != NULL ? *rsa2048_public_key_ : *default_instance_->rsa2048_public_key_;
#endif
}
::securemessage::SimpleRsaPublicKey* GenericPublicKey::mutable_rsa2048_public_key() {
  set_has_rsa2048_public_key();
  if (rsa2048_public_key_ == NULL) {
    rsa2048_public_key_ = new ::securemessage::SimpleRsaPublicKey;
  }
  // @@protoc_insertion_point(field_mutable:securemessage.GenericPublicKey.rsa2048_public_key)
  return rsa2048_public_key_;
}
::securemessage::SimpleRsaPublicKey* GenericPublicKey::release_rsa2048_public_key() {
  // @@protoc_insertion_point(field_release:securemessage.GenericPublicKey.rsa2048_public_key)
  clear_has_rsa2048_public_key();
  ::securemessage::SimpleRsaPublicKey* temp = rsa2048_public_key_;
  rsa2048_public_key_ = NULL;
  return temp;
}
void GenericPublicKey::set_allocated_rsa2048_public_key(::securemessage::SimpleRsaPublicKey* rsa2048_public_key) {
  delete rsa2048_public_key_;
  rsa2048_public_key_ = rsa2048_public_key;
  if (rsa2048_public_key) {
    set_has_rsa2048_public_key();
  } else {
    clear_has_rsa2048_public_key();
  }
  // @@protoc_insertion_point(field_set_allocated:securemessage.GenericPublicKey.rsa2048_public_key)
}

// optional .securemessage.DhPublicKey dh2048_public_key = 4;
bool GenericPublicKey::has_dh2048_public_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void GenericPublicKey::set_has_dh2048_public_key() {
  _has_bits_[0] |= 0x00000008u;
}
void GenericPublicKey::clear_has_dh2048_public_key() {
  _has_bits_[0] &= ~0x00000008u;
}
void GenericPublicKey::clear_dh2048_public_key() {
  if (dh2048_public_key_ != NULL) dh2048_public_key_->::securemessage::DhPublicKey::Clear();
  clear_has_dh2048_public_key();
}
const ::securemessage::DhPublicKey& GenericPublicKey::dh2048_public_key() const {
  // @@protoc_insertion_point(field_get:securemessage.GenericPublicKey.dh2048_public_key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dh2048_public_key_ != NULL ? *dh2048_public_key_ : *default_instance().dh2048_public_key_;
#else
  return dh2048_public_key_ != NULL ? *dh2048_public_key_ : *default_instance_->dh2048_public_key_;
#endif
}
::securemessage::DhPublicKey* GenericPublicKey::mutable_dh2048_public_key() {
  set_has_dh2048_public_key();
  if (dh2048_public_key_ == NULL) {
    dh2048_public_key_ = new ::securemessage::DhPublicKey;
  }
  // @@protoc_insertion_point(field_mutable:securemessage.GenericPublicKey.dh2048_public_key)
  return dh2048_public_key_;
}
::securemessage::DhPublicKey* GenericPublicKey::release_dh2048_public_key() {
  // @@protoc_insertion_point(field_release:securemessage.GenericPublicKey.dh2048_public_key)
  clear_has_dh2048_public_key();
  ::securemessage::DhPublicKey* temp = dh2048_public_key_;
  dh2048_public_key_ = NULL;
  return temp;
}
void GenericPublicKey::set_allocated_dh2048_public_key(::securemessage::DhPublicKey* dh2048_public_key) {
  delete dh2048_public_key_;
  dh2048_public_key_ = dh2048_public_key;
  if (dh2048_public_key) {
    set_has_dh2048_public_key();
  } else {
    clear_has_dh2048_public_key();
  }
  // @@protoc_insertion_point(field_set_allocated:securemessage.GenericPublicKey.dh2048_public_key)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDeviceToDeviceMessage(
    DeviceToDeviceMessage* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DeviceToDeviceMessage::kMessageFieldNumber;
const int DeviceToDeviceMessage::kSequenceNumberFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DeviceToDeviceMessage::DeviceToDeviceMessage()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:securemessage.DeviceToDeviceMessage)
}

void DeviceToDeviceMessage::InitAsDefaultInstance() {
}

DeviceToDeviceMessage::DeviceToDeviceMessage(const DeviceToDeviceMessage& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:securemessage.DeviceToDeviceMessage)
}

void DeviceToDeviceMessage::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sequence_number_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DeviceToDeviceMessage::~DeviceToDeviceMessage() {
  // @@protoc_insertion_point(destructor:securemessage.DeviceToDeviceMessage)
  SharedDtor();
}

void DeviceToDeviceMessage::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DeviceToDeviceMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DeviceToDeviceMessage& DeviceToDeviceMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_securemessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_securemessage_2eproto();
#endif
  return *default_instance_;
}

DeviceToDeviceMessage* DeviceToDeviceMessage::default_instance_ = NULL;

DeviceToDeviceMessage* DeviceToDeviceMessage::New(::google::protobuf::Arena* arena) const {
  DeviceToDeviceMessage* n = new DeviceToDeviceMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DeviceToDeviceMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:securemessage.DeviceToDeviceMessage)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_message()) {
      message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    sequence_number_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DeviceToDeviceMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDeviceToDeviceMessage, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:securemessage.DeviceToDeviceMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes message = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_sequence_number;
        break;
      }

      // optional int32 sequence_number = 2;
      case 2: {
        if (tag == 16) {
         parse_sequence_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sequence_number_)));
          set_has_sequence_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:securemessage.DeviceToDeviceMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:securemessage.DeviceToDeviceMessage)
  return false;
#undef DO_
}

void DeviceToDeviceMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:securemessage.DeviceToDeviceMessage)
  // optional bytes message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->message(), output);
  }

  // optional int32 sequence_number = 2;
  if (has_sequence_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->sequence_number(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:securemessage.DeviceToDeviceMessage)
}

int DeviceToDeviceMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:securemessage.DeviceToDeviceMessage)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional int32 sequence_number = 2;
    if (has_sequence_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sequence_number());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DeviceToDeviceMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DeviceToDeviceMessage*>(&from));
}

void DeviceToDeviceMessage::MergeFrom(const DeviceToDeviceMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:securemessage.DeviceToDeviceMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (from.has_sequence_number()) {
      set_sequence_number(from.sequence_number());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DeviceToDeviceMessage::CopyFrom(const DeviceToDeviceMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:securemessage.DeviceToDeviceMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DeviceToDeviceMessage::IsInitialized() const {

  return true;
}

void DeviceToDeviceMessage::Swap(DeviceToDeviceMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DeviceToDeviceMessage::InternalSwap(DeviceToDeviceMessage* other) {
  message_.Swap(&other->message_);
  std::swap(sequence_number_, other->sequence_number_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DeviceToDeviceMessage::GetTypeName() const {
  return "securemessage.DeviceToDeviceMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DeviceToDeviceMessage

// optional bytes message = 1;
bool DeviceToDeviceMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DeviceToDeviceMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
void DeviceToDeviceMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
void DeviceToDeviceMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
 const ::std::string& DeviceToDeviceMessage::message() const {
  // @@protoc_insertion_point(field_get:securemessage.DeviceToDeviceMessage.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceToDeviceMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.DeviceToDeviceMessage.message)
}
 void DeviceToDeviceMessage::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.DeviceToDeviceMessage.message)
}
 void DeviceToDeviceMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.DeviceToDeviceMessage.message)
}
 ::std::string* DeviceToDeviceMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:securemessage.DeviceToDeviceMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DeviceToDeviceMessage::release_message() {
  // @@protoc_insertion_point(field_release:securemessage.DeviceToDeviceMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DeviceToDeviceMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:securemessage.DeviceToDeviceMessage.message)
}

// optional int32 sequence_number = 2;
bool DeviceToDeviceMessage::has_sequence_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DeviceToDeviceMessage::set_has_sequence_number() {
  _has_bits_[0] |= 0x00000002u;
}
void DeviceToDeviceMessage::clear_has_sequence_number() {
  _has_bits_[0] &= ~0x00000002u;
}
void DeviceToDeviceMessage::clear_sequence_number() {
  sequence_number_ = 0;
  clear_has_sequence_number();
}
 ::google::protobuf::int32 DeviceToDeviceMessage::sequence_number() const {
  // @@protoc_insertion_point(field_get:securemessage.DeviceToDeviceMessage.sequence_number)
  return sequence_number_;
}
 void DeviceToDeviceMessage::set_sequence_number(::google::protobuf::int32 value) {
  set_has_sequence_number();
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:securemessage.DeviceToDeviceMessage.sequence_number)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForInitiatorHello(
    InitiatorHello* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InitiatorHello::kPublicDhKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InitiatorHello::InitiatorHello()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:securemessage.InitiatorHello)
}

void InitiatorHello::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  public_dh_key_ = const_cast< ::securemessage::GenericPublicKey*>(
      ::securemessage::GenericPublicKey::internal_default_instance());
#else
  public_dh_key_ = const_cast< ::securemessage::GenericPublicKey*>(&::securemessage::GenericPublicKey::default_instance());
#endif
}

InitiatorHello::InitiatorHello(const InitiatorHello& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:securemessage.InitiatorHello)
}

void InitiatorHello::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_dh_key_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InitiatorHello::~InitiatorHello() {
  // @@protoc_insertion_point(destructor:securemessage.InitiatorHello)
  SharedDtor();
}

void InitiatorHello::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete public_dh_key_;
  }
}

void InitiatorHello::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InitiatorHello& InitiatorHello::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_securemessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_securemessage_2eproto();
#endif
  return *default_instance_;
}

InitiatorHello* InitiatorHello::default_instance_ = NULL;

InitiatorHello* InitiatorHello::New(::google::protobuf::Arena* arena) const {
  InitiatorHello* n = new InitiatorHello;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InitiatorHello::Clear() {
// @@protoc_insertion_point(message_clear_start:securemessage.InitiatorHello)
  if (has_public_dh_key()) {
    if (public_dh_key_ != NULL) public_dh_key_->::securemessage::GenericPublicKey::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool InitiatorHello::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForInitiatorHello, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:securemessage.InitiatorHello)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .securemessage.GenericPublicKey public_dh_key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_public_dh_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:securemessage.InitiatorHello)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:securemessage.InitiatorHello)
  return false;
#undef DO_
}

void InitiatorHello::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:securemessage.InitiatorHello)
  // optional .securemessage.GenericPublicKey public_dh_key = 1;
  if (has_public_dh_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->public_dh_key_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:securemessage.InitiatorHello)
}

int InitiatorHello::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:securemessage.InitiatorHello)
  int total_size = 0;

  // optional .securemessage.GenericPublicKey public_dh_key = 1;
  if (has_public_dh_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->public_dh_key_);
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InitiatorHello::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InitiatorHello*>(&from));
}

void InitiatorHello::MergeFrom(const InitiatorHello& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:securemessage.InitiatorHello)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_public_dh_key()) {
      mutable_public_dh_key()->::securemessage::GenericPublicKey::MergeFrom(from.public_dh_key());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void InitiatorHello::CopyFrom(const InitiatorHello& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:securemessage.InitiatorHello)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitiatorHello::IsInitialized() const {

  if (has_public_dh_key()) {
    if (!this->public_dh_key_->IsInitialized()) return false;
  }
  return true;
}

void InitiatorHello::Swap(InitiatorHello* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InitiatorHello::InternalSwap(InitiatorHello* other) {
  std::swap(public_dh_key_, other->public_dh_key_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string InitiatorHello::GetTypeName() const {
  return "securemessage.InitiatorHello";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InitiatorHello

// optional .securemessage.GenericPublicKey public_dh_key = 1;
bool InitiatorHello::has_public_dh_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void InitiatorHello::set_has_public_dh_key() {
  _has_bits_[0] |= 0x00000001u;
}
void InitiatorHello::clear_has_public_dh_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void InitiatorHello::clear_public_dh_key() {
  if (public_dh_key_ != NULL) public_dh_key_->::securemessage::GenericPublicKey::Clear();
  clear_has_public_dh_key();
}
const ::securemessage::GenericPublicKey& InitiatorHello::public_dh_key() const {
  // @@protoc_insertion_point(field_get:securemessage.InitiatorHello.public_dh_key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return public_dh_key_ != NULL ? *public_dh_key_ : *default_instance().public_dh_key_;
#else
  return public_dh_key_ != NULL ? *public_dh_key_ : *default_instance_->public_dh_key_;
#endif
}
::securemessage::GenericPublicKey* InitiatorHello::mutable_public_dh_key() {
  set_has_public_dh_key();
  if (public_dh_key_ == NULL) {
    public_dh_key_ = new ::securemessage::GenericPublicKey;
  }
  // @@protoc_insertion_point(field_mutable:securemessage.InitiatorHello.public_dh_key)
  return public_dh_key_;
}
::securemessage::GenericPublicKey* InitiatorHello::release_public_dh_key() {
  // @@protoc_insertion_point(field_release:securemessage.InitiatorHello.public_dh_key)
  clear_has_public_dh_key();
  ::securemessage::GenericPublicKey* temp = public_dh_key_;
  public_dh_key_ = NULL;
  return temp;
}
void InitiatorHello::set_allocated_public_dh_key(::securemessage::GenericPublicKey* public_dh_key) {
  delete public_dh_key_;
  public_dh_key_ = public_dh_key;
  if (public_dh_key) {
    set_has_public_dh_key();
  } else {
    clear_has_public_dh_key();
  }
  // @@protoc_insertion_point(field_set_allocated:securemessage.InitiatorHello.public_dh_key)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForResponderHello(
    ResponderHello* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResponderHello::kPublicDhKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResponderHello::ResponderHello()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:securemessage.ResponderHello)
}

void ResponderHello::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  public_dh_key_ = const_cast< ::securemessage::GenericPublicKey*>(
      ::securemessage::GenericPublicKey::internal_default_instance());
#else
  public_dh_key_ = const_cast< ::securemessage::GenericPublicKey*>(&::securemessage::GenericPublicKey::default_instance());
#endif
}

ResponderHello::ResponderHello(const ResponderHello& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:securemessage.ResponderHello)
}

void ResponderHello::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  public_dh_key_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResponderHello::~ResponderHello() {
  // @@protoc_insertion_point(destructor:securemessage.ResponderHello)
  SharedDtor();
}

void ResponderHello::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete public_dh_key_;
  }
}

void ResponderHello::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ResponderHello& ResponderHello::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_securemessage_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_securemessage_2eproto();
#endif
  return *default_instance_;
}

ResponderHello* ResponderHello::default_instance_ = NULL;

ResponderHello* ResponderHello::New(::google::protobuf::Arena* arena) const {
  ResponderHello* n = new ResponderHello;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResponderHello::Clear() {
// @@protoc_insertion_point(message_clear_start:securemessage.ResponderHello)
  if (has_public_dh_key()) {
    if (public_dh_key_ != NULL) public_dh_key_->::securemessage::GenericPublicKey::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ResponderHello::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForResponderHello, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:securemessage.ResponderHello)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .securemessage.GenericPublicKey public_dh_key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_public_dh_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:securemessage.ResponderHello)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:securemessage.ResponderHello)
  return false;
#undef DO_
}

void ResponderHello::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:securemessage.ResponderHello)
  // optional .securemessage.GenericPublicKey public_dh_key = 1;
  if (has_public_dh_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->public_dh_key_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:securemessage.ResponderHello)
}

int ResponderHello::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:securemessage.ResponderHello)
  int total_size = 0;

  // optional .securemessage.GenericPublicKey public_dh_key = 1;
  if (has_public_dh_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->public_dh_key_);
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResponderHello::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ResponderHello*>(&from));
}

void ResponderHello::MergeFrom(const ResponderHello& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:securemessage.ResponderHello)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_public_dh_key()) {
      mutable_public_dh_key()->::securemessage::GenericPublicKey::MergeFrom(from.public_dh_key());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ResponderHello::CopyFrom(const ResponderHello& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:securemessage.ResponderHello)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResponderHello::IsInitialized() const {

  if (has_public_dh_key()) {
    if (!this->public_dh_key_->IsInitialized()) return false;
  }
  return true;
}

void ResponderHello::Swap(ResponderHello* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResponderHello::InternalSwap(ResponderHello* other) {
  std::swap(public_dh_key_, other->public_dh_key_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ResponderHello::GetTypeName() const {
  return "securemessage.ResponderHello";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResponderHello

// optional .securemessage.GenericPublicKey public_dh_key = 1;
bool ResponderHello::has_public_dh_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResponderHello::set_has_public_dh_key() {
  _has_bits_[0] |= 0x00000001u;
}
void ResponderHello::clear_has_public_dh_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResponderHello::clear_public_dh_key() {
  if (public_dh_key_ != NULL) public_dh_key_->::securemessage::GenericPublicKey::Clear();
  clear_has_public_dh_key();
}
const ::securemessage::GenericPublicKey& ResponderHello::public_dh_key() const {
  // @@protoc_insertion_point(field_get:securemessage.ResponderHello.public_dh_key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return public_dh_key_ != NULL ? *public_dh_key_ : *default_instance().public_dh_key_;
#else
  return public_dh_key_ != NULL ? *public_dh_key_ : *default_instance_->public_dh_key_;
#endif
}
::securemessage::GenericPublicKey* ResponderHello::mutable_public_dh_key() {
  set_has_public_dh_key();
  if (public_dh_key_ == NULL) {
    public_dh_key_ = new ::securemessage::GenericPublicKey;
  }
  // @@protoc_insertion_point(field_mutable:securemessage.ResponderHello.public_dh_key)
  return public_dh_key_;
}
::securemessage::GenericPublicKey* ResponderHello::release_public_dh_key() {
  // @@protoc_insertion_point(field_release:securemessage.ResponderHello.public_dh_key)
  clear_has_public_dh_key();
  ::securemessage::GenericPublicKey* temp = public_dh_key_;
  public_dh_key_ = NULL;
  return temp;
}
void ResponderHello::set_allocated_public_dh_key(::securemessage::GenericPublicKey* public_dh_key) {
  delete public_dh_key_;
  public_dh_key_ = public_dh_key;
  if (public_dh_key) {
    set_has_public_dh_key();
  } else {
    clear_has_public_dh_key();
  }
  // @@protoc_insertion_point(field_set_allocated:securemessage.ResponderHello.public_dh_key)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace securemessage

// @@protoc_insertion_point(global_scope)
