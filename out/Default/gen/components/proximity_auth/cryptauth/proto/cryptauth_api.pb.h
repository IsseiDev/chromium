// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cryptauth_api.proto

#ifndef PROTOBUF_cryptauth_5fapi_2eproto__INCLUDED
#define PROTOBUF_cryptauth_5fapi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace cryptauth {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_cryptauth_5fapi_2eproto();
void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

class DeviceClassifier;
class ExternalDeviceInfo;
class FindEligibleForPromotionRequest;
class FindEligibleForPromotionResponse;
class FindEligibleUnlockDevicesRequest;
class FindEligibleUnlockDevicesResponse;
class FinishEnrollmentRequest;
class FinishEnrollmentResponse;
class GcmDeviceInfo;
class GcmMetadata;
class GetMyDevicesRequest;
class GetMyDevicesResponse;
class IneligibleDevice;
class SendDeviceSyncTickleRequest;
class SendDeviceSyncTickleResponse;
class SetupEnrollmentInfo;
class SetupEnrollmentRequest;
class SetupEnrollmentResponse;
class ToggleEasyUnlockRequest;
class ToggleEasyUnlockResponse;

enum DeviceType {
  UNKNOWN = 0,
  ANDROIDOS = 1,
  CHROME = 2,
  IOS = 3,
  BROWSER = 4
};
bool DeviceType_IsValid(int value);
const DeviceType DeviceType_MIN = UNKNOWN;
const DeviceType DeviceType_MAX = BROWSER;
const int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

enum InvocationReason {
  INVOCATION_REASON_UNKNOWN = 0,
  INVOCATION_REASON_INITIALIZATION = 1,
  INVOCATION_REASON_PERIODIC = 2,
  INVOCATION_REASON_SLOW_PERIODIC = 3,
  INVOCATION_REASON_FAST_PERIODIC = 4,
  INVOCATION_REASON_EXPIRATION = 5,
  INVOCATION_REASON_FAILURE_RECOVERY = 6,
  INVOCATION_REASON_NEW_ACCOUNT = 7,
  INVOCATION_REASON_CHANGED_ACCOUNT = 8,
  INVOCATION_REASON_FEATURE_TOGGLED = 9,
  INVOCATION_REASON_SERVER_INITIATED = 10,
  INVOCATION_REASON_ADDRESS_CHANGE = 11,
  INVOCATION_REASON_SOFTWARE_UPDATE = 12,
  INVOCATION_REASON_MANUAL = 13
};
bool InvocationReason_IsValid(int value);
const InvocationReason InvocationReason_MIN = INVOCATION_REASON_UNKNOWN;
const InvocationReason InvocationReason_MAX = INVOCATION_REASON_MANUAL;
const int InvocationReason_ARRAYSIZE = InvocationReason_MAX + 1;

enum MessageType {
  ENROLLMENT = 0,
  TICKLE = 1,
  TX_REQUEST = 2,
  TX_REPLY = 3,
  TX_SYNC_REQUEST = 4,
  TX_SYNC_RESPONSE = 5,
  TX_PING = 6,
  DEVICE_INFO_UPDATE = 7,
  TX_CANCEL_REQUEST = 8,
  PROXIMITYAUTH_PAIRING = 10,
  GCMV1_IDENTITY_ASSERTION = 11,
  DEVICE_TO_DEVICE_RESPONDER_HELLO_PAYLOAD = 12,
  DEVICE_TO_DEVICE_MESSAGE = 13,
  DEVICE_PROXIMITY_CALLBACK = 14,
  UNLOCK_KEY_SIGNED_CHALLENGE = 15
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = ENROLLMENT;
const MessageType MessageType_MAX = UNLOCK_KEY_SIGNED_CHALLENGE;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

enum RegistrationTickleType {
  UNKNOWN_REGISTRATION_TICKLE_TYPE = 0,
  FORCE_ENROLLMENT = 1,
  UPDATE_ENROLLMENT = 2,
  DEVICES_SYNC = 3
};
bool RegistrationTickleType_IsValid(int value);
const RegistrationTickleType RegistrationTickleType_MIN = UNKNOWN_REGISTRATION_TICKLE_TYPE;
const RegistrationTickleType RegistrationTickleType_MAX = DEVICES_SYNC;
const int RegistrationTickleType_ARRAYSIZE = RegistrationTickleType_MAX + 1;

// ===================================================================

class DeviceClassifier : public ::google::protobuf::MessageLite {
 public:
  DeviceClassifier();
  virtual ~DeviceClassifier();

  DeviceClassifier(const DeviceClassifier& from);

  inline DeviceClassifier& operator=(const DeviceClassifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DeviceClassifier& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceClassifier* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceClassifier* other);

  // implements Message ----------------------------------------------

  inline DeviceClassifier* New() const { return New(NULL); }

  DeviceClassifier* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceClassifier& from);
  void MergeFrom(const DeviceClassifier& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceClassifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 device_os_version_code = 14;
  bool has_device_os_version_code() const;
  void clear_device_os_version_code();
  static const int kDeviceOsVersionCodeFieldNumber = 14;
  ::google::protobuf::int64 device_os_version_code() const;
  void set_device_os_version_code(::google::protobuf::int64 value);

  // optional int64 device_software_version_code = 18;
  bool has_device_software_version_code() const;
  void clear_device_software_version_code();
  static const int kDeviceSoftwareVersionCodeFieldNumber = 18;
  ::google::protobuf::int64 device_software_version_code() const;
  void set_device_software_version_code(::google::protobuf::int64 value);

  // optional string device_software_package = 19;
  bool has_device_software_package() const;
  void clear_device_software_package();
  static const int kDeviceSoftwarePackageFieldNumber = 19;
  const ::std::string& device_software_package() const;
  void set_device_software_package(const ::std::string& value);
  void set_device_software_package(const char* value);
  void set_device_software_package(const char* value, size_t size);
  ::std::string* mutable_device_software_package();
  ::std::string* release_device_software_package();
  void set_allocated_device_software_package(::std::string* device_software_package);

  // optional .cryptauth.DeviceType device_type = 32 [default = UNKNOWN];
  bool has_device_type() const;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 32;
  ::cryptauth::DeviceType device_type() const;
  void set_device_type(::cryptauth::DeviceType value);

  // @@protoc_insertion_point(class_scope:cryptauth.DeviceClassifier)
 private:
  inline void set_has_device_os_version_code();
  inline void clear_has_device_os_version_code();
  inline void set_has_device_software_version_code();
  inline void clear_has_device_software_version_code();
  inline void set_has_device_software_package();
  inline void clear_has_device_software_package();
  inline void set_has_device_type();
  inline void clear_has_device_type();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 device_os_version_code_;
  ::google::protobuf::int64 device_software_version_code_;
  ::google::protobuf::internal::ArenaStringPtr device_software_package_;
  int device_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static DeviceClassifier* default_instance_;
};
// -------------------------------------------------------------------

class ExternalDeviceInfo : public ::google::protobuf::MessageLite {
 public:
  ExternalDeviceInfo();
  virtual ~ExternalDeviceInfo();

  ExternalDeviceInfo(const ExternalDeviceInfo& from);

  inline ExternalDeviceInfo& operator=(const ExternalDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ExternalDeviceInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExternalDeviceInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ExternalDeviceInfo* other);

  // implements Message ----------------------------------------------

  inline ExternalDeviceInfo* New() const { return New(NULL); }

  ExternalDeviceInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExternalDeviceInfo& from);
  void MergeFrom(const ExternalDeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExternalDeviceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes public_key = 1;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional string friendly_device_name = 2;
  bool has_friendly_device_name() const;
  void clear_friendly_device_name();
  static const int kFriendlyDeviceNameFieldNumber = 2;
  const ::std::string& friendly_device_name() const;
  void set_friendly_device_name(const ::std::string& value);
  void set_friendly_device_name(const char* value);
  void set_friendly_device_name(const char* value, size_t size);
  ::std::string* mutable_friendly_device_name();
  ::std::string* release_friendly_device_name();
  void set_allocated_friendly_device_name(::std::string* friendly_device_name);

  // optional string bluetooth_address = 3;
  bool has_bluetooth_address() const;
  void clear_bluetooth_address();
  static const int kBluetoothAddressFieldNumber = 3;
  const ::std::string& bluetooth_address() const;
  void set_bluetooth_address(const ::std::string& value);
  void set_bluetooth_address(const char* value);
  void set_bluetooth_address(const char* value, size_t size);
  ::std::string* mutable_bluetooth_address();
  ::std::string* release_bluetooth_address();
  void set_allocated_bluetooth_address(::std::string* bluetooth_address);

  // optional bool unlock_key = 4;
  bool has_unlock_key() const;
  void clear_unlock_key();
  static const int kUnlockKeyFieldNumber = 4;
  bool unlock_key() const;
  void set_unlock_key(bool value);

  // optional bool unlockable = 5;
  bool has_unlockable() const;
  void clear_unlockable();
  static const int kUnlockableFieldNumber = 5;
  bool unlockable() const;
  void set_unlockable(bool value);

  // @@protoc_insertion_point(class_scope:cryptauth.ExternalDeviceInfo)
 private:
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_friendly_device_name();
  inline void clear_has_friendly_device_name();
  inline void set_has_bluetooth_address();
  inline void clear_has_bluetooth_address();
  inline void set_has_unlock_key();
  inline void clear_has_unlock_key();
  inline void set_has_unlockable();
  inline void clear_has_unlockable();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr friendly_device_name_;
  ::google::protobuf::internal::ArenaStringPtr bluetooth_address_;
  bool unlock_key_;
  bool unlockable_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static ExternalDeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class FindEligibleForPromotionRequest : public ::google::protobuf::MessageLite {
 public:
  FindEligibleForPromotionRequest();
  virtual ~FindEligibleForPromotionRequest();

  FindEligibleForPromotionRequest(const FindEligibleForPromotionRequest& from);

  inline FindEligibleForPromotionRequest& operator=(const FindEligibleForPromotionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FindEligibleForPromotionRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FindEligibleForPromotionRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(FindEligibleForPromotionRequest* other);

  // implements Message ----------------------------------------------

  inline FindEligibleForPromotionRequest* New() const { return New(NULL); }

  FindEligibleForPromotionRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FindEligibleForPromotionRequest& from);
  void MergeFrom(const FindEligibleForPromotionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindEligibleForPromotionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes promoter_public_key = 2;
  bool has_promoter_public_key() const;
  void clear_promoter_public_key();
  static const int kPromoterPublicKeyFieldNumber = 2;
  const ::std::string& promoter_public_key() const;
  void set_promoter_public_key(const ::std::string& value);
  void set_promoter_public_key(const char* value);
  void set_promoter_public_key(const void* value, size_t size);
  ::std::string* mutable_promoter_public_key();
  ::std::string* release_promoter_public_key();
  void set_allocated_promoter_public_key(::std::string* promoter_public_key);

  // optional .cryptauth.DeviceClassifier device_classifier = 3;
  bool has_device_classifier() const;
  void clear_device_classifier();
  static const int kDeviceClassifierFieldNumber = 3;
  const ::cryptauth::DeviceClassifier& device_classifier() const;
  ::cryptauth::DeviceClassifier* mutable_device_classifier();
  ::cryptauth::DeviceClassifier* release_device_classifier();
  void set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier);

  // @@protoc_insertion_point(class_scope:cryptauth.FindEligibleForPromotionRequest)
 private:
  inline void set_has_promoter_public_key();
  inline void clear_has_promoter_public_key();
  inline void set_has_device_classifier();
  inline void clear_has_device_classifier();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr promoter_public_key_;
  ::cryptauth::DeviceClassifier* device_classifier_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static FindEligibleForPromotionRequest* default_instance_;
};
// -------------------------------------------------------------------

class FindEligibleForPromotionResponse : public ::google::protobuf::MessageLite {
 public:
  FindEligibleForPromotionResponse();
  virtual ~FindEligibleForPromotionResponse();

  FindEligibleForPromotionResponse(const FindEligibleForPromotionResponse& from);

  inline FindEligibleForPromotionResponse& operator=(const FindEligibleForPromotionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FindEligibleForPromotionResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FindEligibleForPromotionResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(FindEligibleForPromotionResponse* other);

  // implements Message ----------------------------------------------

  inline FindEligibleForPromotionResponse* New() const { return New(NULL); }

  FindEligibleForPromotionResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FindEligibleForPromotionResponse& from);
  void MergeFrom(const FindEligibleForPromotionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindEligibleForPromotionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool may_show_promo = 1;
  bool has_may_show_promo() const;
  void clear_may_show_promo();
  static const int kMayShowPromoFieldNumber = 1;
  bool may_show_promo() const;
  void set_may_show_promo(bool value);

  // @@protoc_insertion_point(class_scope:cryptauth.FindEligibleForPromotionResponse)
 private:
  inline void set_has_may_show_promo();
  inline void clear_has_may_show_promo();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool may_show_promo_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static FindEligibleForPromotionResponse* default_instance_;
};
// -------------------------------------------------------------------

class FindEligibleUnlockDevicesRequest : public ::google::protobuf::MessageLite {
 public:
  FindEligibleUnlockDevicesRequest();
  virtual ~FindEligibleUnlockDevicesRequest();

  FindEligibleUnlockDevicesRequest(const FindEligibleUnlockDevicesRequest& from);

  inline FindEligibleUnlockDevicesRequest& operator=(const FindEligibleUnlockDevicesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FindEligibleUnlockDevicesRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FindEligibleUnlockDevicesRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(FindEligibleUnlockDevicesRequest* other);

  // implements Message ----------------------------------------------

  inline FindEligibleUnlockDevicesRequest* New() const { return New(NULL); }

  FindEligibleUnlockDevicesRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FindEligibleUnlockDevicesRequest& from);
  void MergeFrom(const FindEligibleUnlockDevicesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindEligibleUnlockDevicesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string callback_bluetooth_address = 2;
  bool has_callback_bluetooth_address() const;
  void clear_callback_bluetooth_address();
  static const int kCallbackBluetoothAddressFieldNumber = 2;
  const ::std::string& callback_bluetooth_address() const;
  void set_callback_bluetooth_address(const ::std::string& value);
  void set_callback_bluetooth_address(const char* value);
  void set_callback_bluetooth_address(const char* value, size_t size);
  ::std::string* mutable_callback_bluetooth_address();
  ::std::string* release_callback_bluetooth_address();
  void set_allocated_callback_bluetooth_address(::std::string* callback_bluetooth_address);

  // optional int32 retry_count = 3;
  bool has_retry_count() const;
  void clear_retry_count();
  static const int kRetryCountFieldNumber = 3;
  ::google::protobuf::int32 retry_count() const;
  void set_retry_count(::google::protobuf::int32 value);

  // optional int64 max_last_update_time_delta_millis = 4;
  bool has_max_last_update_time_delta_millis() const;
  void clear_max_last_update_time_delta_millis();
  static const int kMaxLastUpdateTimeDeltaMillisFieldNumber = 4;
  ::google::protobuf::int64 max_last_update_time_delta_millis() const;
  void set_max_last_update_time_delta_millis(::google::protobuf::int64 value);

  // optional bool offline_allowed = 5 [default = false];
  bool has_offline_allowed() const;
  void clear_offline_allowed();
  static const int kOfflineAllowedFieldNumber = 5;
  bool offline_allowed() const;
  void set_offline_allowed(bool value);

  // optional .cryptauth.DeviceClassifier device_classifier = 6;
  bool has_device_classifier() const;
  void clear_device_classifier();
  static const int kDeviceClassifierFieldNumber = 6;
  const ::cryptauth::DeviceClassifier& device_classifier() const;
  ::cryptauth::DeviceClassifier* mutable_device_classifier();
  ::cryptauth::DeviceClassifier* release_device_classifier();
  void set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier);

  // @@protoc_insertion_point(class_scope:cryptauth.FindEligibleUnlockDevicesRequest)
 private:
  inline void set_has_callback_bluetooth_address();
  inline void clear_has_callback_bluetooth_address();
  inline void set_has_retry_count();
  inline void clear_has_retry_count();
  inline void set_has_max_last_update_time_delta_millis();
  inline void clear_has_max_last_update_time_delta_millis();
  inline void set_has_offline_allowed();
  inline void clear_has_offline_allowed();
  inline void set_has_device_classifier();
  inline void clear_has_device_classifier();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr callback_bluetooth_address_;
  ::google::protobuf::int64 max_last_update_time_delta_millis_;
  ::google::protobuf::int32 retry_count_;
  bool offline_allowed_;
  ::cryptauth::DeviceClassifier* device_classifier_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static FindEligibleUnlockDevicesRequest* default_instance_;
};
// -------------------------------------------------------------------

class FindEligibleUnlockDevicesResponse : public ::google::protobuf::MessageLite {
 public:
  FindEligibleUnlockDevicesResponse();
  virtual ~FindEligibleUnlockDevicesResponse();

  FindEligibleUnlockDevicesResponse(const FindEligibleUnlockDevicesResponse& from);

  inline FindEligibleUnlockDevicesResponse& operator=(const FindEligibleUnlockDevicesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FindEligibleUnlockDevicesResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FindEligibleUnlockDevicesResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(FindEligibleUnlockDevicesResponse* other);

  // implements Message ----------------------------------------------

  inline FindEligibleUnlockDevicesResponse* New() const { return New(NULL); }

  FindEligibleUnlockDevicesResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FindEligibleUnlockDevicesResponse& from);
  void MergeFrom(const FindEligibleUnlockDevicesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FindEligibleUnlockDevicesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cryptauth.ExternalDeviceInfo eligible_devices = 1;
  int eligible_devices_size() const;
  void clear_eligible_devices();
  static const int kEligibleDevicesFieldNumber = 1;
  const ::cryptauth::ExternalDeviceInfo& eligible_devices(int index) const;
  ::cryptauth::ExternalDeviceInfo* mutable_eligible_devices(int index);
  ::cryptauth::ExternalDeviceInfo* add_eligible_devices();
  ::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo >*
      mutable_eligible_devices();
  const ::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo >&
      eligible_devices() const;

  // repeated .cryptauth.IneligibleDevice ineligible_devices = 2;
  int ineligible_devices_size() const;
  void clear_ineligible_devices();
  static const int kIneligibleDevicesFieldNumber = 2;
  const ::cryptauth::IneligibleDevice& ineligible_devices(int index) const;
  ::cryptauth::IneligibleDevice* mutable_ineligible_devices(int index);
  ::cryptauth::IneligibleDevice* add_ineligible_devices();
  ::google::protobuf::RepeatedPtrField< ::cryptauth::IneligibleDevice >*
      mutable_ineligible_devices();
  const ::google::protobuf::RepeatedPtrField< ::cryptauth::IneligibleDevice >&
      ineligible_devices() const;

  // @@protoc_insertion_point(class_scope:cryptauth.FindEligibleUnlockDevicesResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo > eligible_devices_;
  ::google::protobuf::RepeatedPtrField< ::cryptauth::IneligibleDevice > ineligible_devices_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static FindEligibleUnlockDevicesResponse* default_instance_;
};
// -------------------------------------------------------------------

class FinishEnrollmentRequest : public ::google::protobuf::MessageLite {
 public:
  FinishEnrollmentRequest();
  virtual ~FinishEnrollmentRequest();

  FinishEnrollmentRequest(const FinishEnrollmentRequest& from);

  inline FinishEnrollmentRequest& operator=(const FinishEnrollmentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FinishEnrollmentRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FinishEnrollmentRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(FinishEnrollmentRequest* other);

  // implements Message ----------------------------------------------

  inline FinishEnrollmentRequest* New() const { return New(NULL); }

  FinishEnrollmentRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FinishEnrollmentRequest& from);
  void MergeFrom(const FinishEnrollmentRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FinishEnrollmentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes enrollment_session_id = 2;
  bool has_enrollment_session_id() const;
  void clear_enrollment_session_id();
  static const int kEnrollmentSessionIdFieldNumber = 2;
  const ::std::string& enrollment_session_id() const;
  void set_enrollment_session_id(const ::std::string& value);
  void set_enrollment_session_id(const char* value);
  void set_enrollment_session_id(const void* value, size_t size);
  ::std::string* mutable_enrollment_session_id();
  ::std::string* release_enrollment_session_id();
  void set_allocated_enrollment_session_id(::std::string* enrollment_session_id);

  // optional bytes enrollment_message = 3;
  bool has_enrollment_message() const;
  void clear_enrollment_message();
  static const int kEnrollmentMessageFieldNumber = 3;
  const ::std::string& enrollment_message() const;
  void set_enrollment_message(const ::std::string& value);
  void set_enrollment_message(const char* value);
  void set_enrollment_message(const void* value, size_t size);
  ::std::string* mutable_enrollment_message();
  ::std::string* release_enrollment_message();
  void set_allocated_enrollment_message(::std::string* enrollment_message);

  // optional bytes device_ephemeral_key = 4;
  bool has_device_ephemeral_key() const;
  void clear_device_ephemeral_key();
  static const int kDeviceEphemeralKeyFieldNumber = 4;
  const ::std::string& device_ephemeral_key() const;
  void set_device_ephemeral_key(const ::std::string& value);
  void set_device_ephemeral_key(const char* value);
  void set_device_ephemeral_key(const void* value, size_t size);
  ::std::string* mutable_device_ephemeral_key();
  ::std::string* release_device_ephemeral_key();
  void set_allocated_device_ephemeral_key(::std::string* device_ephemeral_key);

  // optional int32 invocation_reason = 11 [default = 0];
  bool has_invocation_reason() const;
  void clear_invocation_reason();
  static const int kInvocationReasonFieldNumber = 11;
  ::google::protobuf::int32 invocation_reason() const;
  void set_invocation_reason(::google::protobuf::int32 value);

  // optional int32 retry_count = 12 [default = 0];
  bool has_retry_count() const;
  void clear_retry_count();
  static const int kRetryCountFieldNumber = 12;
  ::google::protobuf::int32 retry_count() const;
  void set_retry_count(::google::protobuf::int32 value);

  // optional .cryptauth.DeviceClassifier device_classifier = 13;
  bool has_device_classifier() const;
  void clear_device_classifier();
  static const int kDeviceClassifierFieldNumber = 13;
  const ::cryptauth::DeviceClassifier& device_classifier() const;
  ::cryptauth::DeviceClassifier* mutable_device_classifier();
  ::cryptauth::DeviceClassifier* release_device_classifier();
  void set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier);

  // @@protoc_insertion_point(class_scope:cryptauth.FinishEnrollmentRequest)
 private:
  inline void set_has_enrollment_session_id();
  inline void clear_has_enrollment_session_id();
  inline void set_has_enrollment_message();
  inline void clear_has_enrollment_message();
  inline void set_has_device_ephemeral_key();
  inline void clear_has_device_ephemeral_key();
  inline void set_has_invocation_reason();
  inline void clear_has_invocation_reason();
  inline void set_has_retry_count();
  inline void clear_has_retry_count();
  inline void set_has_device_classifier();
  inline void clear_has_device_classifier();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr enrollment_session_id_;
  ::google::protobuf::internal::ArenaStringPtr enrollment_message_;
  ::google::protobuf::internal::ArenaStringPtr device_ephemeral_key_;
  ::google::protobuf::int32 invocation_reason_;
  ::google::protobuf::int32 retry_count_;
  ::cryptauth::DeviceClassifier* device_classifier_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static FinishEnrollmentRequest* default_instance_;
};
// -------------------------------------------------------------------

class FinishEnrollmentResponse : public ::google::protobuf::MessageLite {
 public:
  FinishEnrollmentResponse();
  virtual ~FinishEnrollmentResponse();

  FinishEnrollmentResponse(const FinishEnrollmentResponse& from);

  inline FinishEnrollmentResponse& operator=(const FinishEnrollmentResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FinishEnrollmentResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FinishEnrollmentResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(FinishEnrollmentResponse* other);

  // implements Message ----------------------------------------------

  inline FinishEnrollmentResponse* New() const { return New(NULL); }

  FinishEnrollmentResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FinishEnrollmentResponse& from);
  void MergeFrom(const FinishEnrollmentResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FinishEnrollmentResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // optional string error_message = 2;
  bool has_error_message() const;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // @@protoc_insertion_point(class_scope:cryptauth.FinishEnrollmentResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_error_message();
  inline void clear_has_error_message();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static FinishEnrollmentResponse* default_instance_;
};
// -------------------------------------------------------------------

class GcmDeviceInfo : public ::google::protobuf::MessageLite {
 public:
  GcmDeviceInfo();
  virtual ~GcmDeviceInfo();

  GcmDeviceInfo(const GcmDeviceInfo& from);

  inline GcmDeviceInfo& operator=(const GcmDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GcmDeviceInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GcmDeviceInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(GcmDeviceInfo* other);

  // implements Message ----------------------------------------------

  inline GcmDeviceInfo* New() const { return New(NULL); }

  GcmDeviceInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GcmDeviceInfo& from);
  void MergeFrom(const GcmDeviceInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GcmDeviceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 android_device_id = 1;
  bool has_android_device_id() const;
  void clear_android_device_id();
  static const int kAndroidDeviceIdFieldNumber = 1;
  ::google::protobuf::uint64 android_device_id() const;
  void set_android_device_id(::google::protobuf::uint64 value);

  // optional bytes gcm_registration_id = 102;
  bool has_gcm_registration_id() const;
  void clear_gcm_registration_id();
  static const int kGcmRegistrationIdFieldNumber = 102;
  const ::std::string& gcm_registration_id() const;
  void set_gcm_registration_id(const ::std::string& value);
  void set_gcm_registration_id(const char* value);
  void set_gcm_registration_id(const void* value, size_t size);
  ::std::string* mutable_gcm_registration_id();
  ::std::string* release_gcm_registration_id();
  void set_allocated_gcm_registration_id(::std::string* gcm_registration_id);

  // optional bytes apn_registration_id = 202;
  bool has_apn_registration_id() const;
  void clear_apn_registration_id();
  static const int kApnRegistrationIdFieldNumber = 202;
  const ::std::string& apn_registration_id() const;
  void set_apn_registration_id(const ::std::string& value);
  void set_apn_registration_id(const char* value);
  void set_apn_registration_id(const void* value, size_t size);
  ::std::string* mutable_apn_registration_id();
  ::std::string* release_apn_registration_id();
  void set_allocated_apn_registration_id(::std::string* apn_registration_id);

  // optional bool apn_notification_enabled = 203 [default = false];
  bool has_apn_notification_enabled() const;
  void clear_apn_notification_enabled();
  static const int kApnNotificationEnabledFieldNumber = 203;
  bool apn_notification_enabled() const;
  void set_apn_notification_enabled(bool value);

  // optional string bluetooth_mac_address = 302;
  bool has_bluetooth_mac_address() const;
  void clear_bluetooth_mac_address();
  static const int kBluetoothMacAddressFieldNumber = 302;
  const ::std::string& bluetooth_mac_address() const;
  void set_bluetooth_mac_address(const ::std::string& value);
  void set_bluetooth_mac_address(const char* value);
  void set_bluetooth_mac_address(const char* value, size_t size);
  ::std::string* mutable_bluetooth_mac_address();
  ::std::string* release_bluetooth_mac_address();
  void set_allocated_bluetooth_mac_address(::std::string* bluetooth_mac_address);

  // optional bytes device_master_key_hash = 103;
  bool has_device_master_key_hash() const;
  void clear_device_master_key_hash();
  static const int kDeviceMasterKeyHashFieldNumber = 103;
  const ::std::string& device_master_key_hash() const;
  void set_device_master_key_hash(const ::std::string& value);
  void set_device_master_key_hash(const char* value);
  void set_device_master_key_hash(const void* value, size_t size);
  ::std::string* mutable_device_master_key_hash();
  ::std::string* release_device_master_key_hash();
  void set_allocated_device_master_key_hash(::std::string* device_master_key_hash);

  // required bytes user_public_key = 4;
  bool has_user_public_key() const;
  void clear_user_public_key();
  static const int kUserPublicKeyFieldNumber = 4;
  const ::std::string& user_public_key() const;
  void set_user_public_key(const ::std::string& value);
  void set_user_public_key(const char* value);
  void set_user_public_key(const void* value, size_t size);
  ::std::string* mutable_user_public_key();
  ::std::string* release_user_public_key();
  void set_allocated_user_public_key(::std::string* user_public_key);

  // optional string device_model = 7;
  bool has_device_model() const;
  void clear_device_model();
  static const int kDeviceModelFieldNumber = 7;
  const ::std::string& device_model() const;
  void set_device_model(const ::std::string& value);
  void set_device_model(const char* value);
  void set_device_model(const char* value, size_t size);
  ::std::string* mutable_device_model();
  ::std::string* release_device_model();
  void set_allocated_device_model(::std::string* device_model);

  // optional string locale = 8;
  bool has_locale() const;
  void clear_locale();
  static const int kLocaleFieldNumber = 8;
  const ::std::string& locale() const;
  void set_locale(const ::std::string& value);
  void set_locale(const char* value);
  void set_locale(const char* value, size_t size);
  ::std::string* mutable_locale();
  ::std::string* release_locale();
  void set_allocated_locale(::std::string* locale);

  // optional bytes key_handle = 9;
  bool has_key_handle() const;
  void clear_key_handle();
  static const int kKeyHandleFieldNumber = 9;
  const ::std::string& key_handle() const;
  void set_key_handle(const ::std::string& value);
  void set_key_handle(const char* value);
  void set_key_handle(const void* value, size_t size);
  ::std::string* mutable_key_handle();
  ::std::string* release_key_handle();
  void set_allocated_key_handle(::std::string* key_handle);

  // optional int64 counter = 12 [default = 0];
  bool has_counter() const;
  void clear_counter();
  static const int kCounterFieldNumber = 12;
  ::google::protobuf::int64 counter() const;
  void set_counter(::google::protobuf::int64 value);

  // optional string device_os_version = 13;
  bool has_device_os_version() const;
  void clear_device_os_version();
  static const int kDeviceOsVersionFieldNumber = 13;
  const ::std::string& device_os_version() const;
  void set_device_os_version(const ::std::string& value);
  void set_device_os_version(const char* value);
  void set_device_os_version(const char* value, size_t size);
  ::std::string* mutable_device_os_version();
  ::std::string* release_device_os_version();
  void set_allocated_device_os_version(::std::string* device_os_version);

  // optional int64 device_os_version_code = 14;
  bool has_device_os_version_code() const;
  void clear_device_os_version_code();
  static const int kDeviceOsVersionCodeFieldNumber = 14;
  ::google::protobuf::int64 device_os_version_code() const;
  void set_device_os_version_code(::google::protobuf::int64 value);

  // optional string device_os_release = 15;
  bool has_device_os_release() const;
  void clear_device_os_release();
  static const int kDeviceOsReleaseFieldNumber = 15;
  const ::std::string& device_os_release() const;
  void set_device_os_release(const ::std::string& value);
  void set_device_os_release(const char* value);
  void set_device_os_release(const char* value, size_t size);
  ::std::string* mutable_device_os_release();
  ::std::string* release_device_os_release();
  void set_allocated_device_os_release(::std::string* device_os_release);

  // optional string device_os_codename = 16;
  bool has_device_os_codename() const;
  void clear_device_os_codename();
  static const int kDeviceOsCodenameFieldNumber = 16;
  const ::std::string& device_os_codename() const;
  void set_device_os_codename(const ::std::string& value);
  void set_device_os_codename(const char* value);
  void set_device_os_codename(const char* value, size_t size);
  ::std::string* mutable_device_os_codename();
  ::std::string* release_device_os_codename();
  void set_allocated_device_os_codename(::std::string* device_os_codename);

  // optional string device_software_version = 17;
  bool has_device_software_version() const;
  void clear_device_software_version();
  static const int kDeviceSoftwareVersionFieldNumber = 17;
  const ::std::string& device_software_version() const;
  void set_device_software_version(const ::std::string& value);
  void set_device_software_version(const char* value);
  void set_device_software_version(const char* value, size_t size);
  ::std::string* mutable_device_software_version();
  ::std::string* release_device_software_version();
  void set_allocated_device_software_version(::std::string* device_software_version);

  // optional int64 device_software_version_code = 18;
  bool has_device_software_version_code() const;
  void clear_device_software_version_code();
  static const int kDeviceSoftwareVersionCodeFieldNumber = 18;
  ::google::protobuf::int64 device_software_version_code() const;
  void set_device_software_version_code(::google::protobuf::int64 value);

  // optional string device_software_package = 19;
  bool has_device_software_package() const;
  void clear_device_software_package();
  static const int kDeviceSoftwarePackageFieldNumber = 19;
  const ::std::string& device_software_package() const;
  void set_device_software_package(const ::std::string& value);
  void set_device_software_package(const char* value);
  void set_device_software_package(const char* value, size_t size);
  ::std::string* mutable_device_software_package();
  ::std::string* release_device_software_package();
  void set_allocated_device_software_package(::std::string* device_software_package);

  // optional int32 device_display_diagonal_mils = 22;
  bool has_device_display_diagonal_mils() const;
  void clear_device_display_diagonal_mils();
  static const int kDeviceDisplayDiagonalMilsFieldNumber = 22;
  ::google::protobuf::int32 device_display_diagonal_mils() const;
  void set_device_display_diagonal_mils(::google::protobuf::int32 value);

  // optional int32 device_authzen_version = 24;
  bool has_device_authzen_version() const;
  void clear_device_authzen_version();
  static const int kDeviceAuthzenVersionFieldNumber = 24;
  ::google::protobuf::int32 device_authzen_version() const;
  void set_device_authzen_version(::google::protobuf::int32 value);

  // optional bytes long_device_id = 29;
  bool has_long_device_id() const;
  void clear_long_device_id();
  static const int kLongDeviceIdFieldNumber = 29;
  const ::std::string& long_device_id() const;
  void set_long_device_id(const ::std::string& value);
  void set_long_device_id(const char* value);
  void set_long_device_id(const void* value, size_t size);
  ::std::string* mutable_long_device_id();
  ::std::string* release_long_device_id();
  void set_allocated_long_device_id(::std::string* long_device_id);

  // optional string device_manufacturer = 31;
  bool has_device_manufacturer() const;
  void clear_device_manufacturer();
  static const int kDeviceManufacturerFieldNumber = 31;
  const ::std::string& device_manufacturer() const;
  void set_device_manufacturer(const ::std::string& value);
  void set_device_manufacturer(const char* value);
  void set_device_manufacturer(const char* value, size_t size);
  ::std::string* mutable_device_manufacturer();
  ::std::string* release_device_manufacturer();
  void set_allocated_device_manufacturer(::std::string* device_manufacturer);

  // optional .cryptauth.DeviceType device_type = 32 [default = ANDROIDOS];
  bool has_device_type() const;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 32;
  ::cryptauth::DeviceType device_type() const;
  void set_device_type(::cryptauth::DeviceType value);

  // optional bool using_secure_screenlock = 400 [default = false];
  bool has_using_secure_screenlock() const;
  void clear_using_secure_screenlock();
  static const int kUsingSecureScreenlockFieldNumber = 400;
  bool using_secure_screenlock() const;
  void set_using_secure_screenlock(bool value);

  // optional bool auto_unlock_screenlock_supported = 401 [default = false];
  bool has_auto_unlock_screenlock_supported() const;
  void clear_auto_unlock_screenlock_supported();
  static const int kAutoUnlockScreenlockSupportedFieldNumber = 401;
  bool auto_unlock_screenlock_supported() const;
  void set_auto_unlock_screenlock_supported(bool value);

  // optional bool auto_unlock_screenlock_enabled = 402 [default = false];
  bool has_auto_unlock_screenlock_enabled() const;
  void clear_auto_unlock_screenlock_enabled();
  static const int kAutoUnlockScreenlockEnabledFieldNumber = 402;
  bool auto_unlock_screenlock_enabled() const;
  void set_auto_unlock_screenlock_enabled(bool value);

  // optional bool bluetooth_radio_supported = 403 [default = false];
  bool has_bluetooth_radio_supported() const;
  void clear_bluetooth_radio_supported();
  static const int kBluetoothRadioSupportedFieldNumber = 403;
  bool bluetooth_radio_supported() const;
  void set_bluetooth_radio_supported(bool value);

  // optional bool bluetooth_radio_enabled = 404 [default = false];
  bool has_bluetooth_radio_enabled() const;
  void clear_bluetooth_radio_enabled();
  static const int kBluetoothRadioEnabledFieldNumber = 404;
  bool bluetooth_radio_enabled() const;
  void set_bluetooth_radio_enabled(bool value);

  // optional bytes enrollment_session_id = 1000;
  bool has_enrollment_session_id() const;
  void clear_enrollment_session_id();
  static const int kEnrollmentSessionIdFieldNumber = 1000;
  const ::std::string& enrollment_session_id() const;
  void set_enrollment_session_id(const ::std::string& value);
  void set_enrollment_session_id(const char* value);
  void set_enrollment_session_id(const void* value, size_t size);
  ::std::string* mutable_enrollment_session_id();
  ::std::string* release_enrollment_session_id();
  void set_allocated_enrollment_session_id(::std::string* enrollment_session_id);

  // optional string oauth_token = 1001;
  bool has_oauth_token() const;
  void clear_oauth_token();
  static const int kOauthTokenFieldNumber = 1001;
  const ::std::string& oauth_token() const;
  void set_oauth_token(const ::std::string& value);
  void set_oauth_token(const char* value);
  void set_oauth_token(const char* value, size_t size);
  ::std::string* mutable_oauth_token();
  ::std::string* release_oauth_token();
  void set_allocated_oauth_token(::std::string* oauth_token);

  // @@protoc_insertion_point(class_scope:cryptauth.GcmDeviceInfo)
 private:
  inline void set_has_android_device_id();
  inline void clear_has_android_device_id();
  inline void set_has_gcm_registration_id();
  inline void clear_has_gcm_registration_id();
  inline void set_has_apn_registration_id();
  inline void clear_has_apn_registration_id();
  inline void set_has_apn_notification_enabled();
  inline void clear_has_apn_notification_enabled();
  inline void set_has_bluetooth_mac_address();
  inline void clear_has_bluetooth_mac_address();
  inline void set_has_device_master_key_hash();
  inline void clear_has_device_master_key_hash();
  inline void set_has_user_public_key();
  inline void clear_has_user_public_key();
  inline void set_has_device_model();
  inline void clear_has_device_model();
  inline void set_has_locale();
  inline void clear_has_locale();
  inline void set_has_key_handle();
  inline void clear_has_key_handle();
  inline void set_has_counter();
  inline void clear_has_counter();
  inline void set_has_device_os_version();
  inline void clear_has_device_os_version();
  inline void set_has_device_os_version_code();
  inline void clear_has_device_os_version_code();
  inline void set_has_device_os_release();
  inline void clear_has_device_os_release();
  inline void set_has_device_os_codename();
  inline void clear_has_device_os_codename();
  inline void set_has_device_software_version();
  inline void clear_has_device_software_version();
  inline void set_has_device_software_version_code();
  inline void clear_has_device_software_version_code();
  inline void set_has_device_software_package();
  inline void clear_has_device_software_package();
  inline void set_has_device_display_diagonal_mils();
  inline void clear_has_device_display_diagonal_mils();
  inline void set_has_device_authzen_version();
  inline void clear_has_device_authzen_version();
  inline void set_has_long_device_id();
  inline void clear_has_long_device_id();
  inline void set_has_device_manufacturer();
  inline void clear_has_device_manufacturer();
  inline void set_has_device_type();
  inline void clear_has_device_type();
  inline void set_has_using_secure_screenlock();
  inline void clear_has_using_secure_screenlock();
  inline void set_has_auto_unlock_screenlock_supported();
  inline void clear_has_auto_unlock_screenlock_supported();
  inline void set_has_auto_unlock_screenlock_enabled();
  inline void clear_has_auto_unlock_screenlock_enabled();
  inline void set_has_bluetooth_radio_supported();
  inline void clear_has_bluetooth_radio_supported();
  inline void set_has_bluetooth_radio_enabled();
  inline void clear_has_bluetooth_radio_enabled();
  inline void set_has_enrollment_session_id();
  inline void clear_has_enrollment_session_id();
  inline void set_has_oauth_token();
  inline void clear_has_oauth_token();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 android_device_id_;
  ::google::protobuf::internal::ArenaStringPtr gcm_registration_id_;
  ::google::protobuf::internal::ArenaStringPtr apn_registration_id_;
  ::google::protobuf::internal::ArenaStringPtr bluetooth_mac_address_;
  ::google::protobuf::internal::ArenaStringPtr device_master_key_hash_;
  ::google::protobuf::internal::ArenaStringPtr user_public_key_;
  ::google::protobuf::internal::ArenaStringPtr device_model_;
  ::google::protobuf::internal::ArenaStringPtr locale_;
  ::google::protobuf::internal::ArenaStringPtr key_handle_;
  ::google::protobuf::int64 counter_;
  ::google::protobuf::internal::ArenaStringPtr device_os_version_;
  ::google::protobuf::int64 device_os_version_code_;
  ::google::protobuf::internal::ArenaStringPtr device_os_release_;
  ::google::protobuf::internal::ArenaStringPtr device_os_codename_;
  ::google::protobuf::internal::ArenaStringPtr device_software_version_;
  ::google::protobuf::int64 device_software_version_code_;
  ::google::protobuf::internal::ArenaStringPtr device_software_package_;
  ::google::protobuf::int32 device_display_diagonal_mils_;
  bool apn_notification_enabled_;
  bool using_secure_screenlock_;
  bool auto_unlock_screenlock_supported_;
  bool auto_unlock_screenlock_enabled_;
  ::google::protobuf::internal::ArenaStringPtr long_device_id_;
  ::google::protobuf::int32 device_authzen_version_;
  int device_type_;
  ::google::protobuf::internal::ArenaStringPtr device_manufacturer_;
  ::google::protobuf::internal::ArenaStringPtr enrollment_session_id_;
  ::google::protobuf::internal::ArenaStringPtr oauth_token_;
  bool bluetooth_radio_supported_;
  bool bluetooth_radio_enabled_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static GcmDeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class GcmMetadata : public ::google::protobuf::MessageLite {
 public:
  GcmMetadata();
  virtual ~GcmMetadata();

  GcmMetadata(const GcmMetadata& from);

  inline GcmMetadata& operator=(const GcmMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GcmMetadata& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GcmMetadata* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(GcmMetadata* other);

  // implements Message ----------------------------------------------

  inline GcmMetadata* New() const { return New(NULL); }

  GcmMetadata* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GcmMetadata& from);
  void MergeFrom(const GcmMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GcmMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .cryptauth.MessageType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::cryptauth::MessageType type() const;
  void set_type(::cryptauth::MessageType value);

  // optional int32 version = 2 [default = 0];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cryptauth.GcmMetadata)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::int32 version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static GcmMetadata* default_instance_;
};
// -------------------------------------------------------------------

class GetMyDevicesRequest : public ::google::protobuf::MessageLite {
 public:
  GetMyDevicesRequest();
  virtual ~GetMyDevicesRequest();

  GetMyDevicesRequest(const GetMyDevicesRequest& from);

  inline GetMyDevicesRequest& operator=(const GetMyDevicesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetMyDevicesRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetMyDevicesRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(GetMyDevicesRequest* other);

  // implements Message ----------------------------------------------

  inline GetMyDevicesRequest* New() const { return New(NULL); }

  GetMyDevicesRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetMyDevicesRequest& from);
  void MergeFrom(const GetMyDevicesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetMyDevicesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool approved_for_unlock_required = 2;
  bool has_approved_for_unlock_required() const;
  void clear_approved_for_unlock_required();
  static const int kApprovedForUnlockRequiredFieldNumber = 2;
  bool approved_for_unlock_required() const;
  void set_approved_for_unlock_required(bool value);

  // optional bool allow_stale_read = 3 [default = false];
  bool has_allow_stale_read() const;
  void clear_allow_stale_read();
  static const int kAllowStaleReadFieldNumber = 3;
  bool allow_stale_read() const;
  void set_allow_stale_read(bool value);

  // optional int32 invocation_reason = 4 [default = 0];
  bool has_invocation_reason() const;
  void clear_invocation_reason();
  static const int kInvocationReasonFieldNumber = 4;
  ::google::protobuf::int32 invocation_reason() const;
  void set_invocation_reason(::google::protobuf::int32 value);

  // optional int32 retry_count = 5 [default = 0];
  bool has_retry_count() const;
  void clear_retry_count();
  static const int kRetryCountFieldNumber = 5;
  ::google::protobuf::int32 retry_count() const;
  void set_retry_count(::google::protobuf::int32 value);

  // optional .cryptauth.DeviceClassifier device_classifier = 6;
  bool has_device_classifier() const;
  void clear_device_classifier();
  static const int kDeviceClassifierFieldNumber = 6;
  const ::cryptauth::DeviceClassifier& device_classifier() const;
  ::cryptauth::DeviceClassifier* mutable_device_classifier();
  ::cryptauth::DeviceClassifier* release_device_classifier();
  void set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier);

  // @@protoc_insertion_point(class_scope:cryptauth.GetMyDevicesRequest)
 private:
  inline void set_has_approved_for_unlock_required();
  inline void clear_has_approved_for_unlock_required();
  inline void set_has_allow_stale_read();
  inline void clear_has_allow_stale_read();
  inline void set_has_invocation_reason();
  inline void clear_has_invocation_reason();
  inline void set_has_retry_count();
  inline void clear_has_retry_count();
  inline void set_has_device_classifier();
  inline void clear_has_device_classifier();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool approved_for_unlock_required_;
  bool allow_stale_read_;
  ::google::protobuf::int32 invocation_reason_;
  ::cryptauth::DeviceClassifier* device_classifier_;
  ::google::protobuf::int32 retry_count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static GetMyDevicesRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetMyDevicesResponse : public ::google::protobuf::MessageLite {
 public:
  GetMyDevicesResponse();
  virtual ~GetMyDevicesResponse();

  GetMyDevicesResponse(const GetMyDevicesResponse& from);

  inline GetMyDevicesResponse& operator=(const GetMyDevicesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetMyDevicesResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetMyDevicesResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(GetMyDevicesResponse* other);

  // implements Message ----------------------------------------------

  inline GetMyDevicesResponse* New() const { return New(NULL); }

  GetMyDevicesResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetMyDevicesResponse& from);
  void MergeFrom(const GetMyDevicesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetMyDevicesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .cryptauth.ExternalDeviceInfo devices = 1;
  int devices_size() const;
  void clear_devices();
  static const int kDevicesFieldNumber = 1;
  const ::cryptauth::ExternalDeviceInfo& devices(int index) const;
  ::cryptauth::ExternalDeviceInfo* mutable_devices(int index);
  ::cryptauth::ExternalDeviceInfo* add_devices();
  ::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo >*
      mutable_devices();
  const ::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo >&
      devices() const;

  // @@protoc_insertion_point(class_scope:cryptauth.GetMyDevicesResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo > devices_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static GetMyDevicesResponse* default_instance_;
};
// -------------------------------------------------------------------

class IneligibleDevice : public ::google::protobuf::MessageLite {
 public:
  IneligibleDevice();
  virtual ~IneligibleDevice();

  IneligibleDevice(const IneligibleDevice& from);

  inline IneligibleDevice& operator=(const IneligibleDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const IneligibleDevice& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IneligibleDevice* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(IneligibleDevice* other);

  // implements Message ----------------------------------------------

  inline IneligibleDevice* New() const { return New(NULL); }

  IneligibleDevice* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IneligibleDevice& from);
  void MergeFrom(const IneligibleDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IneligibleDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cryptauth.ExternalDeviceInfo device = 1;
  bool has_device() const;
  void clear_device();
  static const int kDeviceFieldNumber = 1;
  const ::cryptauth::ExternalDeviceInfo& device() const;
  ::cryptauth::ExternalDeviceInfo* mutable_device();
  ::cryptauth::ExternalDeviceInfo* release_device();
  void set_allocated_device(::cryptauth::ExternalDeviceInfo* device);

  // repeated string reasons = 2;
  int reasons_size() const;
  void clear_reasons();
  static const int kReasonsFieldNumber = 2;
  const ::std::string& reasons(int index) const;
  ::std::string* mutable_reasons(int index);
  void set_reasons(int index, const ::std::string& value);
  void set_reasons(int index, const char* value);
  void set_reasons(int index, const char* value, size_t size);
  ::std::string* add_reasons();
  void add_reasons(const ::std::string& value);
  void add_reasons(const char* value);
  void add_reasons(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& reasons() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_reasons();

  // @@protoc_insertion_point(class_scope:cryptauth.IneligibleDevice)
 private:
  inline void set_has_device();
  inline void clear_has_device();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cryptauth::ExternalDeviceInfo* device_;
  ::google::protobuf::RepeatedPtrField< ::std::string> reasons_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static IneligibleDevice* default_instance_;
};
// -------------------------------------------------------------------

class SendDeviceSyncTickleRequest : public ::google::protobuf::MessageLite {
 public:
  SendDeviceSyncTickleRequest();
  virtual ~SendDeviceSyncTickleRequest();

  SendDeviceSyncTickleRequest(const SendDeviceSyncTickleRequest& from);

  inline SendDeviceSyncTickleRequest& operator=(const SendDeviceSyncTickleRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SendDeviceSyncTickleRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendDeviceSyncTickleRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(SendDeviceSyncTickleRequest* other);

  // implements Message ----------------------------------------------

  inline SendDeviceSyncTickleRequest* New() const { return New(NULL); }

  SendDeviceSyncTickleRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendDeviceSyncTickleRequest& from);
  void MergeFrom(const SendDeviceSyncTickleRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendDeviceSyncTickleRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .cryptauth.RegistrationTickleType tickle_type = 3;
  bool has_tickle_type() const;
  void clear_tickle_type();
  static const int kTickleTypeFieldNumber = 3;
  ::cryptauth::RegistrationTickleType tickle_type() const;
  void set_tickle_type(::cryptauth::RegistrationTickleType value);

  // optional .cryptauth.DeviceClassifier device_classifier = 4;
  bool has_device_classifier() const;
  void clear_device_classifier();
  static const int kDeviceClassifierFieldNumber = 4;
  const ::cryptauth::DeviceClassifier& device_classifier() const;
  ::cryptauth::DeviceClassifier* mutable_device_classifier();
  ::cryptauth::DeviceClassifier* release_device_classifier();
  void set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier);

  // @@protoc_insertion_point(class_scope:cryptauth.SendDeviceSyncTickleRequest)
 private:
  inline void set_has_tickle_type();
  inline void clear_has_tickle_type();
  inline void set_has_device_classifier();
  inline void clear_has_device_classifier();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::cryptauth::DeviceClassifier* device_classifier_;
  int tickle_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static SendDeviceSyncTickleRequest* default_instance_;
};
// -------------------------------------------------------------------

class SendDeviceSyncTickleResponse : public ::google::protobuf::MessageLite {
 public:
  SendDeviceSyncTickleResponse();
  virtual ~SendDeviceSyncTickleResponse();

  SendDeviceSyncTickleResponse(const SendDeviceSyncTickleResponse& from);

  inline SendDeviceSyncTickleResponse& operator=(const SendDeviceSyncTickleResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SendDeviceSyncTickleResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SendDeviceSyncTickleResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(SendDeviceSyncTickleResponse* other);

  // implements Message ----------------------------------------------

  inline SendDeviceSyncTickleResponse* New() const { return New(NULL); }

  SendDeviceSyncTickleResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SendDeviceSyncTickleResponse& from);
  void MergeFrom(const SendDeviceSyncTickleResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendDeviceSyncTickleResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cryptauth.SendDeviceSyncTickleResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static SendDeviceSyncTickleResponse* default_instance_;
};
// -------------------------------------------------------------------

class SetupEnrollmentInfo : public ::google::protobuf::MessageLite {
 public:
  SetupEnrollmentInfo();
  virtual ~SetupEnrollmentInfo();

  SetupEnrollmentInfo(const SetupEnrollmentInfo& from);

  inline SetupEnrollmentInfo& operator=(const SetupEnrollmentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SetupEnrollmentInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetupEnrollmentInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(SetupEnrollmentInfo* other);

  // implements Message ----------------------------------------------

  inline SetupEnrollmentInfo* New() const { return New(NULL); }

  SetupEnrollmentInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetupEnrollmentInfo& from);
  void MergeFrom(const SetupEnrollmentInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetupEnrollmentInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional bytes enrollment_session_id = 2;
  bool has_enrollment_session_id() const;
  void clear_enrollment_session_id();
  static const int kEnrollmentSessionIdFieldNumber = 2;
  const ::std::string& enrollment_session_id() const;
  void set_enrollment_session_id(const ::std::string& value);
  void set_enrollment_session_id(const char* value);
  void set_enrollment_session_id(const void* value, size_t size);
  ::std::string* mutable_enrollment_session_id();
  ::std::string* release_enrollment_session_id();
  void set_allocated_enrollment_session_id(::std::string* enrollment_session_id);

  // optional bytes server_ephemeral_key = 3;
  bool has_server_ephemeral_key() const;
  void clear_server_ephemeral_key();
  static const int kServerEphemeralKeyFieldNumber = 3;
  const ::std::string& server_ephemeral_key() const;
  void set_server_ephemeral_key(const ::std::string& value);
  void set_server_ephemeral_key(const char* value);
  void set_server_ephemeral_key(const void* value, size_t size);
  ::std::string* mutable_server_ephemeral_key();
  ::std::string* release_server_ephemeral_key();
  void set_allocated_server_ephemeral_key(::std::string* server_ephemeral_key);

  // @@protoc_insertion_point(class_scope:cryptauth.SetupEnrollmentInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_enrollment_session_id();
  inline void clear_has_enrollment_session_id();
  inline void set_has_server_ephemeral_key();
  inline void clear_has_server_ephemeral_key();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr enrollment_session_id_;
  ::google::protobuf::internal::ArenaStringPtr server_ephemeral_key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static SetupEnrollmentInfo* default_instance_;
};
// -------------------------------------------------------------------

class SetupEnrollmentRequest : public ::google::protobuf::MessageLite {
 public:
  SetupEnrollmentRequest();
  virtual ~SetupEnrollmentRequest();

  SetupEnrollmentRequest(const SetupEnrollmentRequest& from);

  inline SetupEnrollmentRequest& operator=(const SetupEnrollmentRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SetupEnrollmentRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetupEnrollmentRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(SetupEnrollmentRequest* other);

  // implements Message ----------------------------------------------

  inline SetupEnrollmentRequest* New() const { return New(NULL); }

  SetupEnrollmentRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetupEnrollmentRequest& from);
  void MergeFrom(const SetupEnrollmentRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetupEnrollmentRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string origin = 2;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 2;
  const ::std::string& origin() const;
  void set_origin(const ::std::string& value);
  void set_origin(const char* value);
  void set_origin(const char* value, size_t size);
  ::std::string* mutable_origin();
  ::std::string* release_origin();
  void set_allocated_origin(::std::string* origin);

  // repeated string types = 3;
  int types_size() const;
  void clear_types();
  static const int kTypesFieldNumber = 3;
  const ::std::string& types(int index) const;
  ::std::string* mutable_types(int index);
  void set_types(int index, const ::std::string& value);
  void set_types(int index, const char* value);
  void set_types(int index, const char* value, size_t size);
  ::std::string* add_types();
  void add_types(const ::std::string& value);
  void add_types(const char* value);
  void add_types(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& types() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_types();

  // optional bool use_legacy_crypto = 4;
  bool has_use_legacy_crypto() const;
  void clear_use_legacy_crypto();
  static const int kUseLegacyCryptoFieldNumber = 4;
  bool use_legacy_crypto() const;
  void set_use_legacy_crypto(bool value);

  // optional string application_id = 5;
  bool has_application_id() const;
  void clear_application_id();
  static const int kApplicationIdFieldNumber = 5;
  const ::std::string& application_id() const;
  void set_application_id(const ::std::string& value);
  void set_application_id(const char* value);
  void set_application_id(const char* value, size_t size);
  ::std::string* mutable_application_id();
  ::std::string* release_application_id();
  void set_allocated_application_id(::std::string* application_id);

  // optional int32 invocation_reason = 6 [default = 0];
  bool has_invocation_reason() const;
  void clear_invocation_reason();
  static const int kInvocationReasonFieldNumber = 6;
  ::google::protobuf::int32 invocation_reason() const;
  void set_invocation_reason(::google::protobuf::int32 value);

  // optional int32 retry_count = 7 [default = 0];
  bool has_retry_count() const;
  void clear_retry_count();
  static const int kRetryCountFieldNumber = 7;
  ::google::protobuf::int32 retry_count() const;
  void set_retry_count(::google::protobuf::int32 value);

  // optional .cryptauth.DeviceClassifier device_classifier = 8;
  bool has_device_classifier() const;
  void clear_device_classifier();
  static const int kDeviceClassifierFieldNumber = 8;
  const ::cryptauth::DeviceClassifier& device_classifier() const;
  ::cryptauth::DeviceClassifier* mutable_device_classifier();
  ::cryptauth::DeviceClassifier* release_device_classifier();
  void set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier);

  // @@protoc_insertion_point(class_scope:cryptauth.SetupEnrollmentRequest)
 private:
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_use_legacy_crypto();
  inline void clear_has_use_legacy_crypto();
  inline void set_has_application_id();
  inline void clear_has_application_id();
  inline void set_has_invocation_reason();
  inline void clear_has_invocation_reason();
  inline void set_has_retry_count();
  inline void clear_has_retry_count();
  inline void set_has_device_classifier();
  inline void clear_has_device_classifier();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr origin_;
  ::google::protobuf::RepeatedPtrField< ::std::string> types_;
  ::google::protobuf::internal::ArenaStringPtr application_id_;
  bool use_legacy_crypto_;
  ::google::protobuf::int32 invocation_reason_;
  ::cryptauth::DeviceClassifier* device_classifier_;
  ::google::protobuf::int32 retry_count_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static SetupEnrollmentRequest* default_instance_;
};
// -------------------------------------------------------------------

class SetupEnrollmentResponse : public ::google::protobuf::MessageLite {
 public:
  SetupEnrollmentResponse();
  virtual ~SetupEnrollmentResponse();

  SetupEnrollmentResponse(const SetupEnrollmentResponse& from);

  inline SetupEnrollmentResponse& operator=(const SetupEnrollmentResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SetupEnrollmentResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SetupEnrollmentResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(SetupEnrollmentResponse* other);

  // implements Message ----------------------------------------------

  inline SetupEnrollmentResponse* New() const { return New(NULL); }

  SetupEnrollmentResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SetupEnrollmentResponse& from);
  void MergeFrom(const SetupEnrollmentResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SetupEnrollmentResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // repeated .cryptauth.SetupEnrollmentInfo infos = 2;
  int infos_size() const;
  void clear_infos();
  static const int kInfosFieldNumber = 2;
  const ::cryptauth::SetupEnrollmentInfo& infos(int index) const;
  ::cryptauth::SetupEnrollmentInfo* mutable_infos(int index);
  ::cryptauth::SetupEnrollmentInfo* add_infos();
  ::google::protobuf::RepeatedPtrField< ::cryptauth::SetupEnrollmentInfo >*
      mutable_infos();
  const ::google::protobuf::RepeatedPtrField< ::cryptauth::SetupEnrollmentInfo >&
      infos() const;

  // @@protoc_insertion_point(class_scope:cryptauth.SetupEnrollmentResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::RepeatedPtrField< ::cryptauth::SetupEnrollmentInfo > infos_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static SetupEnrollmentResponse* default_instance_;
};
// -------------------------------------------------------------------

class ToggleEasyUnlockRequest : public ::google::protobuf::MessageLite {
 public:
  ToggleEasyUnlockRequest();
  virtual ~ToggleEasyUnlockRequest();

  ToggleEasyUnlockRequest(const ToggleEasyUnlockRequest& from);

  inline ToggleEasyUnlockRequest& operator=(const ToggleEasyUnlockRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ToggleEasyUnlockRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ToggleEasyUnlockRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ToggleEasyUnlockRequest* other);

  // implements Message ----------------------------------------------

  inline ToggleEasyUnlockRequest* New() const { return New(NULL); }

  ToggleEasyUnlockRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ToggleEasyUnlockRequest& from);
  void MergeFrom(const ToggleEasyUnlockRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ToggleEasyUnlockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable = 1;
  bool has_enable() const;
  void clear_enable();
  static const int kEnableFieldNumber = 1;
  bool enable() const;
  void set_enable(bool value);

  // optional bytes public_key = 2;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional bool apply_to_all = 3;
  bool has_apply_to_all() const;
  void clear_apply_to_all();
  static const int kApplyToAllFieldNumber = 3;
  bool apply_to_all() const;
  void set_apply_to_all(bool value);

  // optional .cryptauth.DeviceClassifier device_classifier = 4;
  bool has_device_classifier() const;
  void clear_device_classifier();
  static const int kDeviceClassifierFieldNumber = 4;
  const ::cryptauth::DeviceClassifier& device_classifier() const;
  ::cryptauth::DeviceClassifier* mutable_device_classifier();
  ::cryptauth::DeviceClassifier* release_device_classifier();
  void set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier);

  // @@protoc_insertion_point(class_scope:cryptauth.ToggleEasyUnlockRequest)
 private:
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_public_key();
  inline void clear_has_public_key();
  inline void set_has_apply_to_all();
  inline void clear_has_apply_to_all();
  inline void set_has_device_classifier();
  inline void clear_has_device_classifier();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::cryptauth::DeviceClassifier* device_classifier_;
  bool enable_;
  bool apply_to_all_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static ToggleEasyUnlockRequest* default_instance_;
};
// -------------------------------------------------------------------

class ToggleEasyUnlockResponse : public ::google::protobuf::MessageLite {
 public:
  ToggleEasyUnlockResponse();
  virtual ~ToggleEasyUnlockResponse();

  ToggleEasyUnlockResponse(const ToggleEasyUnlockResponse& from);

  inline ToggleEasyUnlockResponse& operator=(const ToggleEasyUnlockResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ToggleEasyUnlockResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ToggleEasyUnlockResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ToggleEasyUnlockResponse* other);

  // implements Message ----------------------------------------------

  inline ToggleEasyUnlockResponse* New() const { return New(NULL); }

  ToggleEasyUnlockResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ToggleEasyUnlockResponse& from);
  void MergeFrom(const ToggleEasyUnlockResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ToggleEasyUnlockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cryptauth.ToggleEasyUnlockResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_cryptauth_5fapi_2eproto();
  #endif
  friend void protobuf_AssignDesc_cryptauth_5fapi_2eproto();
  friend void protobuf_ShutdownFile_cryptauth_5fapi_2eproto();

  void InitAsDefaultInstance();
  static ToggleEasyUnlockResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// DeviceClassifier

// optional int64 device_os_version_code = 14;
inline bool DeviceClassifier::has_device_os_version_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceClassifier::set_has_device_os_version_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceClassifier::clear_has_device_os_version_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceClassifier::clear_device_os_version_code() {
  device_os_version_code_ = GOOGLE_LONGLONG(0);
  clear_has_device_os_version_code();
}
inline ::google::protobuf::int64 DeviceClassifier::device_os_version_code() const {
  // @@protoc_insertion_point(field_get:cryptauth.DeviceClassifier.device_os_version_code)
  return device_os_version_code_;
}
inline void DeviceClassifier::set_device_os_version_code(::google::protobuf::int64 value) {
  set_has_device_os_version_code();
  device_os_version_code_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.DeviceClassifier.device_os_version_code)
}

// optional int64 device_software_version_code = 18;
inline bool DeviceClassifier::has_device_software_version_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceClassifier::set_has_device_software_version_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceClassifier::clear_has_device_software_version_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceClassifier::clear_device_software_version_code() {
  device_software_version_code_ = GOOGLE_LONGLONG(0);
  clear_has_device_software_version_code();
}
inline ::google::protobuf::int64 DeviceClassifier::device_software_version_code() const {
  // @@protoc_insertion_point(field_get:cryptauth.DeviceClassifier.device_software_version_code)
  return device_software_version_code_;
}
inline void DeviceClassifier::set_device_software_version_code(::google::protobuf::int64 value) {
  set_has_device_software_version_code();
  device_software_version_code_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.DeviceClassifier.device_software_version_code)
}

// optional string device_software_package = 19;
inline bool DeviceClassifier::has_device_software_package() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceClassifier::set_has_device_software_package() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceClassifier::clear_has_device_software_package() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceClassifier::clear_device_software_package() {
  device_software_package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_software_package();
}
inline const ::std::string& DeviceClassifier::device_software_package() const {
  // @@protoc_insertion_point(field_get:cryptauth.DeviceClassifier.device_software_package)
  return device_software_package_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceClassifier::set_device_software_package(const ::std::string& value) {
  set_has_device_software_package();
  device_software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.DeviceClassifier.device_software_package)
}
inline void DeviceClassifier::set_device_software_package(const char* value) {
  set_has_device_software_package();
  device_software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.DeviceClassifier.device_software_package)
}
inline void DeviceClassifier::set_device_software_package(const char* value, size_t size) {
  set_has_device_software_package();
  device_software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.DeviceClassifier.device_software_package)
}
inline ::std::string* DeviceClassifier::mutable_device_software_package() {
  set_has_device_software_package();
  // @@protoc_insertion_point(field_mutable:cryptauth.DeviceClassifier.device_software_package)
  return device_software_package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceClassifier::release_device_software_package() {
  // @@protoc_insertion_point(field_release:cryptauth.DeviceClassifier.device_software_package)
  clear_has_device_software_package();
  return device_software_package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceClassifier::set_allocated_device_software_package(::std::string* device_software_package) {
  if (device_software_package != NULL) {
    set_has_device_software_package();
  } else {
    clear_has_device_software_package();
  }
  device_software_package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_software_package);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.DeviceClassifier.device_software_package)
}

// optional .cryptauth.DeviceType device_type = 32 [default = UNKNOWN];
inline bool DeviceClassifier::has_device_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceClassifier::set_has_device_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceClassifier::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceClassifier::clear_device_type() {
  device_type_ = 0;
  clear_has_device_type();
}
inline ::cryptauth::DeviceType DeviceClassifier::device_type() const {
  // @@protoc_insertion_point(field_get:cryptauth.DeviceClassifier.device_type)
  return static_cast< ::cryptauth::DeviceType >(device_type_);
}
inline void DeviceClassifier::set_device_type(::cryptauth::DeviceType value) {
  assert(::cryptauth::DeviceType_IsValid(value));
  set_has_device_type();
  device_type_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.DeviceClassifier.device_type)
}

// -------------------------------------------------------------------

// ExternalDeviceInfo

// optional bytes public_key = 1;
inline bool ExternalDeviceInfo::has_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExternalDeviceInfo::set_has_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExternalDeviceInfo::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExternalDeviceInfo::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
inline const ::std::string& ExternalDeviceInfo::public_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.ExternalDeviceInfo.public_key)
  return public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternalDeviceInfo::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.ExternalDeviceInfo.public_key)
}
inline void ExternalDeviceInfo::set_public_key(const char* value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.ExternalDeviceInfo.public_key)
}
inline void ExternalDeviceInfo::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.ExternalDeviceInfo.public_key)
}
inline ::std::string* ExternalDeviceInfo::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:cryptauth.ExternalDeviceInfo.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExternalDeviceInfo::release_public_key() {
  // @@protoc_insertion_point(field_release:cryptauth.ExternalDeviceInfo.public_key)
  clear_has_public_key();
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternalDeviceInfo::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.ExternalDeviceInfo.public_key)
}

// optional string friendly_device_name = 2;
inline bool ExternalDeviceInfo::has_friendly_device_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExternalDeviceInfo::set_has_friendly_device_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExternalDeviceInfo::clear_has_friendly_device_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExternalDeviceInfo::clear_friendly_device_name() {
  friendly_device_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_friendly_device_name();
}
inline const ::std::string& ExternalDeviceInfo::friendly_device_name() const {
  // @@protoc_insertion_point(field_get:cryptauth.ExternalDeviceInfo.friendly_device_name)
  return friendly_device_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternalDeviceInfo::set_friendly_device_name(const ::std::string& value) {
  set_has_friendly_device_name();
  friendly_device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.ExternalDeviceInfo.friendly_device_name)
}
inline void ExternalDeviceInfo::set_friendly_device_name(const char* value) {
  set_has_friendly_device_name();
  friendly_device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.ExternalDeviceInfo.friendly_device_name)
}
inline void ExternalDeviceInfo::set_friendly_device_name(const char* value, size_t size) {
  set_has_friendly_device_name();
  friendly_device_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.ExternalDeviceInfo.friendly_device_name)
}
inline ::std::string* ExternalDeviceInfo::mutable_friendly_device_name() {
  set_has_friendly_device_name();
  // @@protoc_insertion_point(field_mutable:cryptauth.ExternalDeviceInfo.friendly_device_name)
  return friendly_device_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExternalDeviceInfo::release_friendly_device_name() {
  // @@protoc_insertion_point(field_release:cryptauth.ExternalDeviceInfo.friendly_device_name)
  clear_has_friendly_device_name();
  return friendly_device_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternalDeviceInfo::set_allocated_friendly_device_name(::std::string* friendly_device_name) {
  if (friendly_device_name != NULL) {
    set_has_friendly_device_name();
  } else {
    clear_has_friendly_device_name();
  }
  friendly_device_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), friendly_device_name);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.ExternalDeviceInfo.friendly_device_name)
}

// optional string bluetooth_address = 3;
inline bool ExternalDeviceInfo::has_bluetooth_address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExternalDeviceInfo::set_has_bluetooth_address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExternalDeviceInfo::clear_has_bluetooth_address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExternalDeviceInfo::clear_bluetooth_address() {
  bluetooth_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bluetooth_address();
}
inline const ::std::string& ExternalDeviceInfo::bluetooth_address() const {
  // @@protoc_insertion_point(field_get:cryptauth.ExternalDeviceInfo.bluetooth_address)
  return bluetooth_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternalDeviceInfo::set_bluetooth_address(const ::std::string& value) {
  set_has_bluetooth_address();
  bluetooth_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.ExternalDeviceInfo.bluetooth_address)
}
inline void ExternalDeviceInfo::set_bluetooth_address(const char* value) {
  set_has_bluetooth_address();
  bluetooth_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.ExternalDeviceInfo.bluetooth_address)
}
inline void ExternalDeviceInfo::set_bluetooth_address(const char* value, size_t size) {
  set_has_bluetooth_address();
  bluetooth_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.ExternalDeviceInfo.bluetooth_address)
}
inline ::std::string* ExternalDeviceInfo::mutable_bluetooth_address() {
  set_has_bluetooth_address();
  // @@protoc_insertion_point(field_mutable:cryptauth.ExternalDeviceInfo.bluetooth_address)
  return bluetooth_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExternalDeviceInfo::release_bluetooth_address() {
  // @@protoc_insertion_point(field_release:cryptauth.ExternalDeviceInfo.bluetooth_address)
  clear_has_bluetooth_address();
  return bluetooth_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternalDeviceInfo::set_allocated_bluetooth_address(::std::string* bluetooth_address) {
  if (bluetooth_address != NULL) {
    set_has_bluetooth_address();
  } else {
    clear_has_bluetooth_address();
  }
  bluetooth_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bluetooth_address);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.ExternalDeviceInfo.bluetooth_address)
}

// optional bool unlock_key = 4;
inline bool ExternalDeviceInfo::has_unlock_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExternalDeviceInfo::set_has_unlock_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExternalDeviceInfo::clear_has_unlock_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExternalDeviceInfo::clear_unlock_key() {
  unlock_key_ = false;
  clear_has_unlock_key();
}
inline bool ExternalDeviceInfo::unlock_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.ExternalDeviceInfo.unlock_key)
  return unlock_key_;
}
inline void ExternalDeviceInfo::set_unlock_key(bool value) {
  set_has_unlock_key();
  unlock_key_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.ExternalDeviceInfo.unlock_key)
}

// optional bool unlockable = 5;
inline bool ExternalDeviceInfo::has_unlockable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExternalDeviceInfo::set_has_unlockable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExternalDeviceInfo::clear_has_unlockable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExternalDeviceInfo::clear_unlockable() {
  unlockable_ = false;
  clear_has_unlockable();
}
inline bool ExternalDeviceInfo::unlockable() const {
  // @@protoc_insertion_point(field_get:cryptauth.ExternalDeviceInfo.unlockable)
  return unlockable_;
}
inline void ExternalDeviceInfo::set_unlockable(bool value) {
  set_has_unlockable();
  unlockable_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.ExternalDeviceInfo.unlockable)
}

// -------------------------------------------------------------------

// FindEligibleForPromotionRequest

// optional bytes promoter_public_key = 2;
inline bool FindEligibleForPromotionRequest::has_promoter_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindEligibleForPromotionRequest::set_has_promoter_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindEligibleForPromotionRequest::clear_has_promoter_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindEligibleForPromotionRequest::clear_promoter_public_key() {
  promoter_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_promoter_public_key();
}
inline const ::std::string& FindEligibleForPromotionRequest::promoter_public_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
  return promoter_public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FindEligibleForPromotionRequest::set_promoter_public_key(const ::std::string& value) {
  set_has_promoter_public_key();
  promoter_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
}
inline void FindEligibleForPromotionRequest::set_promoter_public_key(const char* value) {
  set_has_promoter_public_key();
  promoter_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
}
inline void FindEligibleForPromotionRequest::set_promoter_public_key(const void* value, size_t size) {
  set_has_promoter_public_key();
  promoter_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
}
inline ::std::string* FindEligibleForPromotionRequest::mutable_promoter_public_key() {
  set_has_promoter_public_key();
  // @@protoc_insertion_point(field_mutable:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
  return promoter_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FindEligibleForPromotionRequest::release_promoter_public_key() {
  // @@protoc_insertion_point(field_release:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
  clear_has_promoter_public_key();
  return promoter_public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FindEligibleForPromotionRequest::set_allocated_promoter_public_key(::std::string* promoter_public_key) {
  if (promoter_public_key != NULL) {
    set_has_promoter_public_key();
  } else {
    clear_has_promoter_public_key();
  }
  promoter_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), promoter_public_key);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FindEligibleForPromotionRequest.promoter_public_key)
}

// optional .cryptauth.DeviceClassifier device_classifier = 3;
inline bool FindEligibleForPromotionRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindEligibleForPromotionRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindEligibleForPromotionRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindEligibleForPromotionRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
inline const ::cryptauth::DeviceClassifier& FindEligibleForPromotionRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleForPromotionRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
inline ::cryptauth::DeviceClassifier* FindEligibleForPromotionRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.FindEligibleForPromotionRequest.device_classifier)
  return device_classifier_;
}
inline ::cryptauth::DeviceClassifier* FindEligibleForPromotionRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.FindEligibleForPromotionRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
inline void FindEligibleForPromotionRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FindEligibleForPromotionRequest.device_classifier)
}

// -------------------------------------------------------------------

// FindEligibleForPromotionResponse

// optional bool may_show_promo = 1;
inline bool FindEligibleForPromotionResponse::has_may_show_promo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindEligibleForPromotionResponse::set_has_may_show_promo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindEligibleForPromotionResponse::clear_has_may_show_promo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindEligibleForPromotionResponse::clear_may_show_promo() {
  may_show_promo_ = false;
  clear_has_may_show_promo();
}
inline bool FindEligibleForPromotionResponse::may_show_promo() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleForPromotionResponse.may_show_promo)
  return may_show_promo_;
}
inline void FindEligibleForPromotionResponse::set_may_show_promo(bool value) {
  set_has_may_show_promo();
  may_show_promo_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.FindEligibleForPromotionResponse.may_show_promo)
}

// -------------------------------------------------------------------

// FindEligibleUnlockDevicesRequest

// optional string callback_bluetooth_address = 2;
inline bool FindEligibleUnlockDevicesRequest::has_callback_bluetooth_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindEligibleUnlockDevicesRequest::set_has_callback_bluetooth_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindEligibleUnlockDevicesRequest::clear_has_callback_bluetooth_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindEligibleUnlockDevicesRequest::clear_callback_bluetooth_address() {
  callback_bluetooth_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_callback_bluetooth_address();
}
inline const ::std::string& FindEligibleUnlockDevicesRequest::callback_bluetooth_address() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
  return callback_bluetooth_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FindEligibleUnlockDevicesRequest::set_callback_bluetooth_address(const ::std::string& value) {
  set_has_callback_bluetooth_address();
  callback_bluetooth_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
}
inline void FindEligibleUnlockDevicesRequest::set_callback_bluetooth_address(const char* value) {
  set_has_callback_bluetooth_address();
  callback_bluetooth_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
}
inline void FindEligibleUnlockDevicesRequest::set_callback_bluetooth_address(const char* value, size_t size) {
  set_has_callback_bluetooth_address();
  callback_bluetooth_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
}
inline ::std::string* FindEligibleUnlockDevicesRequest::mutable_callback_bluetooth_address() {
  set_has_callback_bluetooth_address();
  // @@protoc_insertion_point(field_mutable:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
  return callback_bluetooth_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FindEligibleUnlockDevicesRequest::release_callback_bluetooth_address() {
  // @@protoc_insertion_point(field_release:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
  clear_has_callback_bluetooth_address();
  return callback_bluetooth_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FindEligibleUnlockDevicesRequest::set_allocated_callback_bluetooth_address(::std::string* callback_bluetooth_address) {
  if (callback_bluetooth_address != NULL) {
    set_has_callback_bluetooth_address();
  } else {
    clear_has_callback_bluetooth_address();
  }
  callback_bluetooth_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), callback_bluetooth_address);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FindEligibleUnlockDevicesRequest.callback_bluetooth_address)
}

// optional int32 retry_count = 3;
inline bool FindEligibleUnlockDevicesRequest::has_retry_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindEligibleUnlockDevicesRequest::set_has_retry_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindEligibleUnlockDevicesRequest::clear_has_retry_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindEligibleUnlockDevicesRequest::clear_retry_count() {
  retry_count_ = 0;
  clear_has_retry_count();
}
inline ::google::protobuf::int32 FindEligibleUnlockDevicesRequest::retry_count() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesRequest.retry_count)
  return retry_count_;
}
inline void FindEligibleUnlockDevicesRequest::set_retry_count(::google::protobuf::int32 value) {
  set_has_retry_count();
  retry_count_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.FindEligibleUnlockDevicesRequest.retry_count)
}

// optional int64 max_last_update_time_delta_millis = 4;
inline bool FindEligibleUnlockDevicesRequest::has_max_last_update_time_delta_millis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FindEligibleUnlockDevicesRequest::set_has_max_last_update_time_delta_millis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FindEligibleUnlockDevicesRequest::clear_has_max_last_update_time_delta_millis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FindEligibleUnlockDevicesRequest::clear_max_last_update_time_delta_millis() {
  max_last_update_time_delta_millis_ = GOOGLE_LONGLONG(0);
  clear_has_max_last_update_time_delta_millis();
}
inline ::google::protobuf::int64 FindEligibleUnlockDevicesRequest::max_last_update_time_delta_millis() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesRequest.max_last_update_time_delta_millis)
  return max_last_update_time_delta_millis_;
}
inline void FindEligibleUnlockDevicesRequest::set_max_last_update_time_delta_millis(::google::protobuf::int64 value) {
  set_has_max_last_update_time_delta_millis();
  max_last_update_time_delta_millis_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.FindEligibleUnlockDevicesRequest.max_last_update_time_delta_millis)
}

// optional bool offline_allowed = 5 [default = false];
inline bool FindEligibleUnlockDevicesRequest::has_offline_allowed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FindEligibleUnlockDevicesRequest::set_has_offline_allowed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FindEligibleUnlockDevicesRequest::clear_has_offline_allowed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FindEligibleUnlockDevicesRequest::clear_offline_allowed() {
  offline_allowed_ = false;
  clear_has_offline_allowed();
}
inline bool FindEligibleUnlockDevicesRequest::offline_allowed() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesRequest.offline_allowed)
  return offline_allowed_;
}
inline void FindEligibleUnlockDevicesRequest::set_offline_allowed(bool value) {
  set_has_offline_allowed();
  offline_allowed_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.FindEligibleUnlockDevicesRequest.offline_allowed)
}

// optional .cryptauth.DeviceClassifier device_classifier = 6;
inline bool FindEligibleUnlockDevicesRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FindEligibleUnlockDevicesRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FindEligibleUnlockDevicesRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FindEligibleUnlockDevicesRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
inline const ::cryptauth::DeviceClassifier& FindEligibleUnlockDevicesRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
inline ::cryptauth::DeviceClassifier* FindEligibleUnlockDevicesRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.FindEligibleUnlockDevicesRequest.device_classifier)
  return device_classifier_;
}
inline ::cryptauth::DeviceClassifier* FindEligibleUnlockDevicesRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.FindEligibleUnlockDevicesRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
inline void FindEligibleUnlockDevicesRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FindEligibleUnlockDevicesRequest.device_classifier)
}

// -------------------------------------------------------------------

// FindEligibleUnlockDevicesResponse

// repeated .cryptauth.ExternalDeviceInfo eligible_devices = 1;
inline int FindEligibleUnlockDevicesResponse::eligible_devices_size() const {
  return eligible_devices_.size();
}
inline void FindEligibleUnlockDevicesResponse::clear_eligible_devices() {
  eligible_devices_.Clear();
}
inline const ::cryptauth::ExternalDeviceInfo& FindEligibleUnlockDevicesResponse::eligible_devices(int index) const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesResponse.eligible_devices)
  return eligible_devices_.Get(index);
}
inline ::cryptauth::ExternalDeviceInfo* FindEligibleUnlockDevicesResponse::mutable_eligible_devices(int index) {
  // @@protoc_insertion_point(field_mutable:cryptauth.FindEligibleUnlockDevicesResponse.eligible_devices)
  return eligible_devices_.Mutable(index);
}
inline ::cryptauth::ExternalDeviceInfo* FindEligibleUnlockDevicesResponse::add_eligible_devices() {
  // @@protoc_insertion_point(field_add:cryptauth.FindEligibleUnlockDevicesResponse.eligible_devices)
  return eligible_devices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo >*
FindEligibleUnlockDevicesResponse::mutable_eligible_devices() {
  // @@protoc_insertion_point(field_mutable_list:cryptauth.FindEligibleUnlockDevicesResponse.eligible_devices)
  return &eligible_devices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo >&
FindEligibleUnlockDevicesResponse::eligible_devices() const {
  // @@protoc_insertion_point(field_list:cryptauth.FindEligibleUnlockDevicesResponse.eligible_devices)
  return eligible_devices_;
}

// repeated .cryptauth.IneligibleDevice ineligible_devices = 2;
inline int FindEligibleUnlockDevicesResponse::ineligible_devices_size() const {
  return ineligible_devices_.size();
}
inline void FindEligibleUnlockDevicesResponse::clear_ineligible_devices() {
  ineligible_devices_.Clear();
}
inline const ::cryptauth::IneligibleDevice& FindEligibleUnlockDevicesResponse::ineligible_devices(int index) const {
  // @@protoc_insertion_point(field_get:cryptauth.FindEligibleUnlockDevicesResponse.ineligible_devices)
  return ineligible_devices_.Get(index);
}
inline ::cryptauth::IneligibleDevice* FindEligibleUnlockDevicesResponse::mutable_ineligible_devices(int index) {
  // @@protoc_insertion_point(field_mutable:cryptauth.FindEligibleUnlockDevicesResponse.ineligible_devices)
  return ineligible_devices_.Mutable(index);
}
inline ::cryptauth::IneligibleDevice* FindEligibleUnlockDevicesResponse::add_ineligible_devices() {
  // @@protoc_insertion_point(field_add:cryptauth.FindEligibleUnlockDevicesResponse.ineligible_devices)
  return ineligible_devices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cryptauth::IneligibleDevice >*
FindEligibleUnlockDevicesResponse::mutable_ineligible_devices() {
  // @@protoc_insertion_point(field_mutable_list:cryptauth.FindEligibleUnlockDevicesResponse.ineligible_devices)
  return &ineligible_devices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cryptauth::IneligibleDevice >&
FindEligibleUnlockDevicesResponse::ineligible_devices() const {
  // @@protoc_insertion_point(field_list:cryptauth.FindEligibleUnlockDevicesResponse.ineligible_devices)
  return ineligible_devices_;
}

// -------------------------------------------------------------------

// FinishEnrollmentRequest

// optional bytes enrollment_session_id = 2;
inline bool FinishEnrollmentRequest::has_enrollment_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FinishEnrollmentRequest::set_has_enrollment_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FinishEnrollmentRequest::clear_has_enrollment_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FinishEnrollmentRequest::clear_enrollment_session_id() {
  enrollment_session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_enrollment_session_id();
}
inline const ::std::string& FinishEnrollmentRequest::enrollment_session_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
  return enrollment_session_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FinishEnrollmentRequest::set_enrollment_session_id(const ::std::string& value) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
}
inline void FinishEnrollmentRequest::set_enrollment_session_id(const char* value) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
}
inline void FinishEnrollmentRequest::set_enrollment_session_id(const void* value, size_t size) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
}
inline ::std::string* FinishEnrollmentRequest::mutable_enrollment_session_id() {
  set_has_enrollment_session_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
  return enrollment_session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FinishEnrollmentRequest::release_enrollment_session_id() {
  // @@protoc_insertion_point(field_release:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
  clear_has_enrollment_session_id();
  return enrollment_session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FinishEnrollmentRequest::set_allocated_enrollment_session_id(::std::string* enrollment_session_id) {
  if (enrollment_session_id != NULL) {
    set_has_enrollment_session_id();
  } else {
    clear_has_enrollment_session_id();
  }
  enrollment_session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enrollment_session_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FinishEnrollmentRequest.enrollment_session_id)
}

// optional bytes enrollment_message = 3;
inline bool FinishEnrollmentRequest::has_enrollment_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FinishEnrollmentRequest::set_has_enrollment_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FinishEnrollmentRequest::clear_has_enrollment_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FinishEnrollmentRequest::clear_enrollment_message() {
  enrollment_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_enrollment_message();
}
inline const ::std::string& FinishEnrollmentRequest::enrollment_message() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentRequest.enrollment_message)
  return enrollment_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FinishEnrollmentRequest::set_enrollment_message(const ::std::string& value) {
  set_has_enrollment_message();
  enrollment_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentRequest.enrollment_message)
}
inline void FinishEnrollmentRequest::set_enrollment_message(const char* value) {
  set_has_enrollment_message();
  enrollment_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FinishEnrollmentRequest.enrollment_message)
}
inline void FinishEnrollmentRequest::set_enrollment_message(const void* value, size_t size) {
  set_has_enrollment_message();
  enrollment_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FinishEnrollmentRequest.enrollment_message)
}
inline ::std::string* FinishEnrollmentRequest::mutable_enrollment_message() {
  set_has_enrollment_message();
  // @@protoc_insertion_point(field_mutable:cryptauth.FinishEnrollmentRequest.enrollment_message)
  return enrollment_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FinishEnrollmentRequest::release_enrollment_message() {
  // @@protoc_insertion_point(field_release:cryptauth.FinishEnrollmentRequest.enrollment_message)
  clear_has_enrollment_message();
  return enrollment_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FinishEnrollmentRequest::set_allocated_enrollment_message(::std::string* enrollment_message) {
  if (enrollment_message != NULL) {
    set_has_enrollment_message();
  } else {
    clear_has_enrollment_message();
  }
  enrollment_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enrollment_message);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FinishEnrollmentRequest.enrollment_message)
}

// optional bytes device_ephemeral_key = 4;
inline bool FinishEnrollmentRequest::has_device_ephemeral_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FinishEnrollmentRequest::set_has_device_ephemeral_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FinishEnrollmentRequest::clear_has_device_ephemeral_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FinishEnrollmentRequest::clear_device_ephemeral_key() {
  device_ephemeral_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_ephemeral_key();
}
inline const ::std::string& FinishEnrollmentRequest::device_ephemeral_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
  return device_ephemeral_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FinishEnrollmentRequest::set_device_ephemeral_key(const ::std::string& value) {
  set_has_device_ephemeral_key();
  device_ephemeral_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
}
inline void FinishEnrollmentRequest::set_device_ephemeral_key(const char* value) {
  set_has_device_ephemeral_key();
  device_ephemeral_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
}
inline void FinishEnrollmentRequest::set_device_ephemeral_key(const void* value, size_t size) {
  set_has_device_ephemeral_key();
  device_ephemeral_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
}
inline ::std::string* FinishEnrollmentRequest::mutable_device_ephemeral_key() {
  set_has_device_ephemeral_key();
  // @@protoc_insertion_point(field_mutable:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
  return device_ephemeral_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FinishEnrollmentRequest::release_device_ephemeral_key() {
  // @@protoc_insertion_point(field_release:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
  clear_has_device_ephemeral_key();
  return device_ephemeral_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FinishEnrollmentRequest::set_allocated_device_ephemeral_key(::std::string* device_ephemeral_key) {
  if (device_ephemeral_key != NULL) {
    set_has_device_ephemeral_key();
  } else {
    clear_has_device_ephemeral_key();
  }
  device_ephemeral_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_ephemeral_key);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FinishEnrollmentRequest.device_ephemeral_key)
}

// optional int32 invocation_reason = 11 [default = 0];
inline bool FinishEnrollmentRequest::has_invocation_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FinishEnrollmentRequest::set_has_invocation_reason() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FinishEnrollmentRequest::clear_has_invocation_reason() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FinishEnrollmentRequest::clear_invocation_reason() {
  invocation_reason_ = 0;
  clear_has_invocation_reason();
}
inline ::google::protobuf::int32 FinishEnrollmentRequest::invocation_reason() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentRequest.invocation_reason)
  return invocation_reason_;
}
inline void FinishEnrollmentRequest::set_invocation_reason(::google::protobuf::int32 value) {
  set_has_invocation_reason();
  invocation_reason_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentRequest.invocation_reason)
}

// optional int32 retry_count = 12 [default = 0];
inline bool FinishEnrollmentRequest::has_retry_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FinishEnrollmentRequest::set_has_retry_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FinishEnrollmentRequest::clear_has_retry_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FinishEnrollmentRequest::clear_retry_count() {
  retry_count_ = 0;
  clear_has_retry_count();
}
inline ::google::protobuf::int32 FinishEnrollmentRequest::retry_count() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentRequest.retry_count)
  return retry_count_;
}
inline void FinishEnrollmentRequest::set_retry_count(::google::protobuf::int32 value) {
  set_has_retry_count();
  retry_count_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentRequest.retry_count)
}

// optional .cryptauth.DeviceClassifier device_classifier = 13;
inline bool FinishEnrollmentRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FinishEnrollmentRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FinishEnrollmentRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FinishEnrollmentRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
inline const ::cryptauth::DeviceClassifier& FinishEnrollmentRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
inline ::cryptauth::DeviceClassifier* FinishEnrollmentRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.FinishEnrollmentRequest.device_classifier)
  return device_classifier_;
}
inline ::cryptauth::DeviceClassifier* FinishEnrollmentRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.FinishEnrollmentRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
inline void FinishEnrollmentRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FinishEnrollmentRequest.device_classifier)
}

// -------------------------------------------------------------------

// FinishEnrollmentResponse

// optional string status = 1;
inline bool FinishEnrollmentResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FinishEnrollmentResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FinishEnrollmentResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FinishEnrollmentResponse::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& FinishEnrollmentResponse::status() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentResponse.status)
  return status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FinishEnrollmentResponse::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentResponse.status)
}
inline void FinishEnrollmentResponse::set_status(const char* value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FinishEnrollmentResponse.status)
}
inline void FinishEnrollmentResponse::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FinishEnrollmentResponse.status)
}
inline ::std::string* FinishEnrollmentResponse::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:cryptauth.FinishEnrollmentResponse.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FinishEnrollmentResponse::release_status() {
  // @@protoc_insertion_point(field_release:cryptauth.FinishEnrollmentResponse.status)
  clear_has_status();
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FinishEnrollmentResponse::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FinishEnrollmentResponse.status)
}

// optional string error_message = 2;
inline bool FinishEnrollmentResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FinishEnrollmentResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FinishEnrollmentResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FinishEnrollmentResponse::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_message();
}
inline const ::std::string& FinishEnrollmentResponse::error_message() const {
  // @@protoc_insertion_point(field_get:cryptauth.FinishEnrollmentResponse.error_message)
  return error_message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FinishEnrollmentResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.FinishEnrollmentResponse.error_message)
}
inline void FinishEnrollmentResponse::set_error_message(const char* value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.FinishEnrollmentResponse.error_message)
}
inline void FinishEnrollmentResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.FinishEnrollmentResponse.error_message)
}
inline ::std::string* FinishEnrollmentResponse::mutable_error_message() {
  set_has_error_message();
  // @@protoc_insertion_point(field_mutable:cryptauth.FinishEnrollmentResponse.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FinishEnrollmentResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:cryptauth.FinishEnrollmentResponse.error_message)
  clear_has_error_message();
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FinishEnrollmentResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    set_has_error_message();
  } else {
    clear_has_error_message();
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.FinishEnrollmentResponse.error_message)
}

// -------------------------------------------------------------------

// GcmDeviceInfo

// optional fixed64 android_device_id = 1;
inline bool GcmDeviceInfo::has_android_device_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GcmDeviceInfo::set_has_android_device_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GcmDeviceInfo::clear_has_android_device_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GcmDeviceInfo::clear_android_device_id() {
  android_device_id_ = GOOGLE_ULONGLONG(0);
  clear_has_android_device_id();
}
inline ::google::protobuf::uint64 GcmDeviceInfo::android_device_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.android_device_id)
  return android_device_id_;
}
inline void GcmDeviceInfo::set_android_device_id(::google::protobuf::uint64 value) {
  set_has_android_device_id();
  android_device_id_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.android_device_id)
}

// optional bytes gcm_registration_id = 102;
inline bool GcmDeviceInfo::has_gcm_registration_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GcmDeviceInfo::set_has_gcm_registration_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GcmDeviceInfo::clear_has_gcm_registration_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GcmDeviceInfo::clear_gcm_registration_id() {
  gcm_registration_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gcm_registration_id();
}
inline const ::std::string& GcmDeviceInfo::gcm_registration_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.gcm_registration_id)
  return gcm_registration_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_gcm_registration_id(const ::std::string& value) {
  set_has_gcm_registration_id();
  gcm_registration_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.gcm_registration_id)
}
inline void GcmDeviceInfo::set_gcm_registration_id(const char* value) {
  set_has_gcm_registration_id();
  gcm_registration_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.gcm_registration_id)
}
inline void GcmDeviceInfo::set_gcm_registration_id(const void* value, size_t size) {
  set_has_gcm_registration_id();
  gcm_registration_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.gcm_registration_id)
}
inline ::std::string* GcmDeviceInfo::mutable_gcm_registration_id() {
  set_has_gcm_registration_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.gcm_registration_id)
  return gcm_registration_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_gcm_registration_id() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.gcm_registration_id)
  clear_has_gcm_registration_id();
  return gcm_registration_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_gcm_registration_id(::std::string* gcm_registration_id) {
  if (gcm_registration_id != NULL) {
    set_has_gcm_registration_id();
  } else {
    clear_has_gcm_registration_id();
  }
  gcm_registration_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gcm_registration_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.gcm_registration_id)
}

// optional bytes apn_registration_id = 202;
inline bool GcmDeviceInfo::has_apn_registration_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GcmDeviceInfo::set_has_apn_registration_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GcmDeviceInfo::clear_has_apn_registration_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GcmDeviceInfo::clear_apn_registration_id() {
  apn_registration_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_apn_registration_id();
}
inline const ::std::string& GcmDeviceInfo::apn_registration_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.apn_registration_id)
  return apn_registration_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_apn_registration_id(const ::std::string& value) {
  set_has_apn_registration_id();
  apn_registration_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.apn_registration_id)
}
inline void GcmDeviceInfo::set_apn_registration_id(const char* value) {
  set_has_apn_registration_id();
  apn_registration_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.apn_registration_id)
}
inline void GcmDeviceInfo::set_apn_registration_id(const void* value, size_t size) {
  set_has_apn_registration_id();
  apn_registration_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.apn_registration_id)
}
inline ::std::string* GcmDeviceInfo::mutable_apn_registration_id() {
  set_has_apn_registration_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.apn_registration_id)
  return apn_registration_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_apn_registration_id() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.apn_registration_id)
  clear_has_apn_registration_id();
  return apn_registration_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_apn_registration_id(::std::string* apn_registration_id) {
  if (apn_registration_id != NULL) {
    set_has_apn_registration_id();
  } else {
    clear_has_apn_registration_id();
  }
  apn_registration_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), apn_registration_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.apn_registration_id)
}

// optional bool apn_notification_enabled = 203 [default = false];
inline bool GcmDeviceInfo::has_apn_notification_enabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GcmDeviceInfo::set_has_apn_notification_enabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GcmDeviceInfo::clear_has_apn_notification_enabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GcmDeviceInfo::clear_apn_notification_enabled() {
  apn_notification_enabled_ = false;
  clear_has_apn_notification_enabled();
}
inline bool GcmDeviceInfo::apn_notification_enabled() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.apn_notification_enabled)
  return apn_notification_enabled_;
}
inline void GcmDeviceInfo::set_apn_notification_enabled(bool value) {
  set_has_apn_notification_enabled();
  apn_notification_enabled_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.apn_notification_enabled)
}

// optional string bluetooth_mac_address = 302;
inline bool GcmDeviceInfo::has_bluetooth_mac_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GcmDeviceInfo::set_has_bluetooth_mac_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GcmDeviceInfo::clear_has_bluetooth_mac_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GcmDeviceInfo::clear_bluetooth_mac_address() {
  bluetooth_mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bluetooth_mac_address();
}
inline const ::std::string& GcmDeviceInfo::bluetooth_mac_address() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
  return bluetooth_mac_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_bluetooth_mac_address(const ::std::string& value) {
  set_has_bluetooth_mac_address();
  bluetooth_mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
}
inline void GcmDeviceInfo::set_bluetooth_mac_address(const char* value) {
  set_has_bluetooth_mac_address();
  bluetooth_mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
}
inline void GcmDeviceInfo::set_bluetooth_mac_address(const char* value, size_t size) {
  set_has_bluetooth_mac_address();
  bluetooth_mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
}
inline ::std::string* GcmDeviceInfo::mutable_bluetooth_mac_address() {
  set_has_bluetooth_mac_address();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
  return bluetooth_mac_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_bluetooth_mac_address() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
  clear_has_bluetooth_mac_address();
  return bluetooth_mac_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_bluetooth_mac_address(::std::string* bluetooth_mac_address) {
  if (bluetooth_mac_address != NULL) {
    set_has_bluetooth_mac_address();
  } else {
    clear_has_bluetooth_mac_address();
  }
  bluetooth_mac_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bluetooth_mac_address);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.bluetooth_mac_address)
}

// optional bytes device_master_key_hash = 103;
inline bool GcmDeviceInfo::has_device_master_key_hash() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GcmDeviceInfo::set_has_device_master_key_hash() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GcmDeviceInfo::clear_has_device_master_key_hash() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GcmDeviceInfo::clear_device_master_key_hash() {
  device_master_key_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_master_key_hash();
}
inline const ::std::string& GcmDeviceInfo::device_master_key_hash() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_master_key_hash)
  return device_master_key_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_device_master_key_hash(const ::std::string& value) {
  set_has_device_master_key_hash();
  device_master_key_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_master_key_hash)
}
inline void GcmDeviceInfo::set_device_master_key_hash(const char* value) {
  set_has_device_master_key_hash();
  device_master_key_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_master_key_hash)
}
inline void GcmDeviceInfo::set_device_master_key_hash(const void* value, size_t size) {
  set_has_device_master_key_hash();
  device_master_key_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_master_key_hash)
}
inline ::std::string* GcmDeviceInfo::mutable_device_master_key_hash() {
  set_has_device_master_key_hash();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_master_key_hash)
  return device_master_key_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_device_master_key_hash() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_master_key_hash)
  clear_has_device_master_key_hash();
  return device_master_key_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_device_master_key_hash(::std::string* device_master_key_hash) {
  if (device_master_key_hash != NULL) {
    set_has_device_master_key_hash();
  } else {
    clear_has_device_master_key_hash();
  }
  device_master_key_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_master_key_hash);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_master_key_hash)
}

// required bytes user_public_key = 4;
inline bool GcmDeviceInfo::has_user_public_key() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GcmDeviceInfo::set_has_user_public_key() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GcmDeviceInfo::clear_has_user_public_key() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GcmDeviceInfo::clear_user_public_key() {
  user_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_public_key();
}
inline const ::std::string& GcmDeviceInfo::user_public_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.user_public_key)
  return user_public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_user_public_key(const ::std::string& value) {
  set_has_user_public_key();
  user_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.user_public_key)
}
inline void GcmDeviceInfo::set_user_public_key(const char* value) {
  set_has_user_public_key();
  user_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.user_public_key)
}
inline void GcmDeviceInfo::set_user_public_key(const void* value, size_t size) {
  set_has_user_public_key();
  user_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.user_public_key)
}
inline ::std::string* GcmDeviceInfo::mutable_user_public_key() {
  set_has_user_public_key();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.user_public_key)
  return user_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_user_public_key() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.user_public_key)
  clear_has_user_public_key();
  return user_public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_user_public_key(::std::string* user_public_key) {
  if (user_public_key != NULL) {
    set_has_user_public_key();
  } else {
    clear_has_user_public_key();
  }
  user_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_public_key);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.user_public_key)
}

// optional string device_model = 7;
inline bool GcmDeviceInfo::has_device_model() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GcmDeviceInfo::set_has_device_model() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GcmDeviceInfo::clear_has_device_model() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GcmDeviceInfo::clear_device_model() {
  device_model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_model();
}
inline const ::std::string& GcmDeviceInfo::device_model() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_model)
  return device_model_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_device_model(const ::std::string& value) {
  set_has_device_model();
  device_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_model)
}
inline void GcmDeviceInfo::set_device_model(const char* value) {
  set_has_device_model();
  device_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_model)
}
inline void GcmDeviceInfo::set_device_model(const char* value, size_t size) {
  set_has_device_model();
  device_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_model)
}
inline ::std::string* GcmDeviceInfo::mutable_device_model() {
  set_has_device_model();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_model)
  return device_model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_device_model() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_model)
  clear_has_device_model();
  return device_model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_device_model(::std::string* device_model) {
  if (device_model != NULL) {
    set_has_device_model();
  } else {
    clear_has_device_model();
  }
  device_model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_model);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_model)
}

// optional string locale = 8;
inline bool GcmDeviceInfo::has_locale() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GcmDeviceInfo::set_has_locale() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GcmDeviceInfo::clear_has_locale() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GcmDeviceInfo::clear_locale() {
  locale_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_locale();
}
inline const ::std::string& GcmDeviceInfo::locale() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.locale)
  return locale_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_locale(const ::std::string& value) {
  set_has_locale();
  locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.locale)
}
inline void GcmDeviceInfo::set_locale(const char* value) {
  set_has_locale();
  locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.locale)
}
inline void GcmDeviceInfo::set_locale(const char* value, size_t size) {
  set_has_locale();
  locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.locale)
}
inline ::std::string* GcmDeviceInfo::mutable_locale() {
  set_has_locale();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.locale)
  return locale_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_locale() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.locale)
  clear_has_locale();
  return locale_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_locale(::std::string* locale) {
  if (locale != NULL) {
    set_has_locale();
  } else {
    clear_has_locale();
  }
  locale_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), locale);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.locale)
}

// optional bytes key_handle = 9;
inline bool GcmDeviceInfo::has_key_handle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GcmDeviceInfo::set_has_key_handle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GcmDeviceInfo::clear_has_key_handle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GcmDeviceInfo::clear_key_handle() {
  key_handle_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key_handle();
}
inline const ::std::string& GcmDeviceInfo::key_handle() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.key_handle)
  return key_handle_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_key_handle(const ::std::string& value) {
  set_has_key_handle();
  key_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.key_handle)
}
inline void GcmDeviceInfo::set_key_handle(const char* value) {
  set_has_key_handle();
  key_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.key_handle)
}
inline void GcmDeviceInfo::set_key_handle(const void* value, size_t size) {
  set_has_key_handle();
  key_handle_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.key_handle)
}
inline ::std::string* GcmDeviceInfo::mutable_key_handle() {
  set_has_key_handle();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.key_handle)
  return key_handle_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_key_handle() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.key_handle)
  clear_has_key_handle();
  return key_handle_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_key_handle(::std::string* key_handle) {
  if (key_handle != NULL) {
    set_has_key_handle();
  } else {
    clear_has_key_handle();
  }
  key_handle_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_handle);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.key_handle)
}

// optional int64 counter = 12 [default = 0];
inline bool GcmDeviceInfo::has_counter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GcmDeviceInfo::set_has_counter() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GcmDeviceInfo::clear_has_counter() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GcmDeviceInfo::clear_counter() {
  counter_ = GOOGLE_LONGLONG(0);
  clear_has_counter();
}
inline ::google::protobuf::int64 GcmDeviceInfo::counter() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.counter)
  return counter_;
}
inline void GcmDeviceInfo::set_counter(::google::protobuf::int64 value) {
  set_has_counter();
  counter_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.counter)
}

// optional string device_os_version = 13;
inline bool GcmDeviceInfo::has_device_os_version() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GcmDeviceInfo::set_has_device_os_version() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GcmDeviceInfo::clear_has_device_os_version() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GcmDeviceInfo::clear_device_os_version() {
  device_os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_os_version();
}
inline const ::std::string& GcmDeviceInfo::device_os_version() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_os_version)
  return device_os_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_device_os_version(const ::std::string& value) {
  set_has_device_os_version();
  device_os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_os_version)
}
inline void GcmDeviceInfo::set_device_os_version(const char* value) {
  set_has_device_os_version();
  device_os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_os_version)
}
inline void GcmDeviceInfo::set_device_os_version(const char* value, size_t size) {
  set_has_device_os_version();
  device_os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_os_version)
}
inline ::std::string* GcmDeviceInfo::mutable_device_os_version() {
  set_has_device_os_version();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_os_version)
  return device_os_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_device_os_version() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_os_version)
  clear_has_device_os_version();
  return device_os_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_device_os_version(::std::string* device_os_version) {
  if (device_os_version != NULL) {
    set_has_device_os_version();
  } else {
    clear_has_device_os_version();
  }
  device_os_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_os_version);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_os_version)
}

// optional int64 device_os_version_code = 14;
inline bool GcmDeviceInfo::has_device_os_version_code() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GcmDeviceInfo::set_has_device_os_version_code() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GcmDeviceInfo::clear_has_device_os_version_code() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GcmDeviceInfo::clear_device_os_version_code() {
  device_os_version_code_ = GOOGLE_LONGLONG(0);
  clear_has_device_os_version_code();
}
inline ::google::protobuf::int64 GcmDeviceInfo::device_os_version_code() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_os_version_code)
  return device_os_version_code_;
}
inline void GcmDeviceInfo::set_device_os_version_code(::google::protobuf::int64 value) {
  set_has_device_os_version_code();
  device_os_version_code_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_os_version_code)
}

// optional string device_os_release = 15;
inline bool GcmDeviceInfo::has_device_os_release() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GcmDeviceInfo::set_has_device_os_release() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GcmDeviceInfo::clear_has_device_os_release() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GcmDeviceInfo::clear_device_os_release() {
  device_os_release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_os_release();
}
inline const ::std::string& GcmDeviceInfo::device_os_release() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_os_release)
  return device_os_release_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_device_os_release(const ::std::string& value) {
  set_has_device_os_release();
  device_os_release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_os_release)
}
inline void GcmDeviceInfo::set_device_os_release(const char* value) {
  set_has_device_os_release();
  device_os_release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_os_release)
}
inline void GcmDeviceInfo::set_device_os_release(const char* value, size_t size) {
  set_has_device_os_release();
  device_os_release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_os_release)
}
inline ::std::string* GcmDeviceInfo::mutable_device_os_release() {
  set_has_device_os_release();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_os_release)
  return device_os_release_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_device_os_release() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_os_release)
  clear_has_device_os_release();
  return device_os_release_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_device_os_release(::std::string* device_os_release) {
  if (device_os_release != NULL) {
    set_has_device_os_release();
  } else {
    clear_has_device_os_release();
  }
  device_os_release_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_os_release);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_os_release)
}

// optional string device_os_codename = 16;
inline bool GcmDeviceInfo::has_device_os_codename() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GcmDeviceInfo::set_has_device_os_codename() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GcmDeviceInfo::clear_has_device_os_codename() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GcmDeviceInfo::clear_device_os_codename() {
  device_os_codename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_os_codename();
}
inline const ::std::string& GcmDeviceInfo::device_os_codename() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_os_codename)
  return device_os_codename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_device_os_codename(const ::std::string& value) {
  set_has_device_os_codename();
  device_os_codename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_os_codename)
}
inline void GcmDeviceInfo::set_device_os_codename(const char* value) {
  set_has_device_os_codename();
  device_os_codename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_os_codename)
}
inline void GcmDeviceInfo::set_device_os_codename(const char* value, size_t size) {
  set_has_device_os_codename();
  device_os_codename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_os_codename)
}
inline ::std::string* GcmDeviceInfo::mutable_device_os_codename() {
  set_has_device_os_codename();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_os_codename)
  return device_os_codename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_device_os_codename() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_os_codename)
  clear_has_device_os_codename();
  return device_os_codename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_device_os_codename(::std::string* device_os_codename) {
  if (device_os_codename != NULL) {
    set_has_device_os_codename();
  } else {
    clear_has_device_os_codename();
  }
  device_os_codename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_os_codename);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_os_codename)
}

// optional string device_software_version = 17;
inline bool GcmDeviceInfo::has_device_software_version() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GcmDeviceInfo::set_has_device_software_version() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GcmDeviceInfo::clear_has_device_software_version() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GcmDeviceInfo::clear_device_software_version() {
  device_software_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_software_version();
}
inline const ::std::string& GcmDeviceInfo::device_software_version() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_software_version)
  return device_software_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_device_software_version(const ::std::string& value) {
  set_has_device_software_version();
  device_software_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_software_version)
}
inline void GcmDeviceInfo::set_device_software_version(const char* value) {
  set_has_device_software_version();
  device_software_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_software_version)
}
inline void GcmDeviceInfo::set_device_software_version(const char* value, size_t size) {
  set_has_device_software_version();
  device_software_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_software_version)
}
inline ::std::string* GcmDeviceInfo::mutable_device_software_version() {
  set_has_device_software_version();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_software_version)
  return device_software_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_device_software_version() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_software_version)
  clear_has_device_software_version();
  return device_software_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_device_software_version(::std::string* device_software_version) {
  if (device_software_version != NULL) {
    set_has_device_software_version();
  } else {
    clear_has_device_software_version();
  }
  device_software_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_software_version);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_software_version)
}

// optional int64 device_software_version_code = 18;
inline bool GcmDeviceInfo::has_device_software_version_code() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GcmDeviceInfo::set_has_device_software_version_code() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GcmDeviceInfo::clear_has_device_software_version_code() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GcmDeviceInfo::clear_device_software_version_code() {
  device_software_version_code_ = GOOGLE_LONGLONG(0);
  clear_has_device_software_version_code();
}
inline ::google::protobuf::int64 GcmDeviceInfo::device_software_version_code() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_software_version_code)
  return device_software_version_code_;
}
inline void GcmDeviceInfo::set_device_software_version_code(::google::protobuf::int64 value) {
  set_has_device_software_version_code();
  device_software_version_code_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_software_version_code)
}

// optional string device_software_package = 19;
inline bool GcmDeviceInfo::has_device_software_package() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GcmDeviceInfo::set_has_device_software_package() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GcmDeviceInfo::clear_has_device_software_package() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GcmDeviceInfo::clear_device_software_package() {
  device_software_package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_software_package();
}
inline const ::std::string& GcmDeviceInfo::device_software_package() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_software_package)
  return device_software_package_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_device_software_package(const ::std::string& value) {
  set_has_device_software_package();
  device_software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_software_package)
}
inline void GcmDeviceInfo::set_device_software_package(const char* value) {
  set_has_device_software_package();
  device_software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_software_package)
}
inline void GcmDeviceInfo::set_device_software_package(const char* value, size_t size) {
  set_has_device_software_package();
  device_software_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_software_package)
}
inline ::std::string* GcmDeviceInfo::mutable_device_software_package() {
  set_has_device_software_package();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_software_package)
  return device_software_package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_device_software_package() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_software_package)
  clear_has_device_software_package();
  return device_software_package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_device_software_package(::std::string* device_software_package) {
  if (device_software_package != NULL) {
    set_has_device_software_package();
  } else {
    clear_has_device_software_package();
  }
  device_software_package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_software_package);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_software_package)
}

// optional int32 device_display_diagonal_mils = 22;
inline bool GcmDeviceInfo::has_device_display_diagonal_mils() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GcmDeviceInfo::set_has_device_display_diagonal_mils() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GcmDeviceInfo::clear_has_device_display_diagonal_mils() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GcmDeviceInfo::clear_device_display_diagonal_mils() {
  device_display_diagonal_mils_ = 0;
  clear_has_device_display_diagonal_mils();
}
inline ::google::protobuf::int32 GcmDeviceInfo::device_display_diagonal_mils() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_display_diagonal_mils)
  return device_display_diagonal_mils_;
}
inline void GcmDeviceInfo::set_device_display_diagonal_mils(::google::protobuf::int32 value) {
  set_has_device_display_diagonal_mils();
  device_display_diagonal_mils_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_display_diagonal_mils)
}

// optional int32 device_authzen_version = 24;
inline bool GcmDeviceInfo::has_device_authzen_version() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GcmDeviceInfo::set_has_device_authzen_version() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GcmDeviceInfo::clear_has_device_authzen_version() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GcmDeviceInfo::clear_device_authzen_version() {
  device_authzen_version_ = 0;
  clear_has_device_authzen_version();
}
inline ::google::protobuf::int32 GcmDeviceInfo::device_authzen_version() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_authzen_version)
  return device_authzen_version_;
}
inline void GcmDeviceInfo::set_device_authzen_version(::google::protobuf::int32 value) {
  set_has_device_authzen_version();
  device_authzen_version_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_authzen_version)
}

// optional bytes long_device_id = 29;
inline bool GcmDeviceInfo::has_long_device_id() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GcmDeviceInfo::set_has_long_device_id() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GcmDeviceInfo::clear_has_long_device_id() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GcmDeviceInfo::clear_long_device_id() {
  long_device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_long_device_id();
}
inline const ::std::string& GcmDeviceInfo::long_device_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.long_device_id)
  return long_device_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_long_device_id(const ::std::string& value) {
  set_has_long_device_id();
  long_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.long_device_id)
}
inline void GcmDeviceInfo::set_long_device_id(const char* value) {
  set_has_long_device_id();
  long_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.long_device_id)
}
inline void GcmDeviceInfo::set_long_device_id(const void* value, size_t size) {
  set_has_long_device_id();
  long_device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.long_device_id)
}
inline ::std::string* GcmDeviceInfo::mutable_long_device_id() {
  set_has_long_device_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.long_device_id)
  return long_device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_long_device_id() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.long_device_id)
  clear_has_long_device_id();
  return long_device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_long_device_id(::std::string* long_device_id) {
  if (long_device_id != NULL) {
    set_has_long_device_id();
  } else {
    clear_has_long_device_id();
  }
  long_device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), long_device_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.long_device_id)
}

// optional string device_manufacturer = 31;
inline bool GcmDeviceInfo::has_device_manufacturer() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GcmDeviceInfo::set_has_device_manufacturer() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GcmDeviceInfo::clear_has_device_manufacturer() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GcmDeviceInfo::clear_device_manufacturer() {
  device_manufacturer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_manufacturer();
}
inline const ::std::string& GcmDeviceInfo::device_manufacturer() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_manufacturer)
  return device_manufacturer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_device_manufacturer(const ::std::string& value) {
  set_has_device_manufacturer();
  device_manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_manufacturer)
}
inline void GcmDeviceInfo::set_device_manufacturer(const char* value) {
  set_has_device_manufacturer();
  device_manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.device_manufacturer)
}
inline void GcmDeviceInfo::set_device_manufacturer(const char* value, size_t size) {
  set_has_device_manufacturer();
  device_manufacturer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.device_manufacturer)
}
inline ::std::string* GcmDeviceInfo::mutable_device_manufacturer() {
  set_has_device_manufacturer();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.device_manufacturer)
  return device_manufacturer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_device_manufacturer() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.device_manufacturer)
  clear_has_device_manufacturer();
  return device_manufacturer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_device_manufacturer(::std::string* device_manufacturer) {
  if (device_manufacturer != NULL) {
    set_has_device_manufacturer();
  } else {
    clear_has_device_manufacturer();
  }
  device_manufacturer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_manufacturer);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.device_manufacturer)
}

// optional .cryptauth.DeviceType device_type = 32 [default = ANDROIDOS];
inline bool GcmDeviceInfo::has_device_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GcmDeviceInfo::set_has_device_type() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GcmDeviceInfo::clear_has_device_type() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GcmDeviceInfo::clear_device_type() {
  device_type_ = 1;
  clear_has_device_type();
}
inline ::cryptauth::DeviceType GcmDeviceInfo::device_type() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.device_type)
  return static_cast< ::cryptauth::DeviceType >(device_type_);
}
inline void GcmDeviceInfo::set_device_type(::cryptauth::DeviceType value) {
  assert(::cryptauth::DeviceType_IsValid(value));
  set_has_device_type();
  device_type_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.device_type)
}

// optional bool using_secure_screenlock = 400 [default = false];
inline bool GcmDeviceInfo::has_using_secure_screenlock() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GcmDeviceInfo::set_has_using_secure_screenlock() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GcmDeviceInfo::clear_has_using_secure_screenlock() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GcmDeviceInfo::clear_using_secure_screenlock() {
  using_secure_screenlock_ = false;
  clear_has_using_secure_screenlock();
}
inline bool GcmDeviceInfo::using_secure_screenlock() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.using_secure_screenlock)
  return using_secure_screenlock_;
}
inline void GcmDeviceInfo::set_using_secure_screenlock(bool value) {
  set_has_using_secure_screenlock();
  using_secure_screenlock_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.using_secure_screenlock)
}

// optional bool auto_unlock_screenlock_supported = 401 [default = false];
inline bool GcmDeviceInfo::has_auto_unlock_screenlock_supported() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GcmDeviceInfo::set_has_auto_unlock_screenlock_supported() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GcmDeviceInfo::clear_has_auto_unlock_screenlock_supported() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GcmDeviceInfo::clear_auto_unlock_screenlock_supported() {
  auto_unlock_screenlock_supported_ = false;
  clear_has_auto_unlock_screenlock_supported();
}
inline bool GcmDeviceInfo::auto_unlock_screenlock_supported() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.auto_unlock_screenlock_supported)
  return auto_unlock_screenlock_supported_;
}
inline void GcmDeviceInfo::set_auto_unlock_screenlock_supported(bool value) {
  set_has_auto_unlock_screenlock_supported();
  auto_unlock_screenlock_supported_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.auto_unlock_screenlock_supported)
}

// optional bool auto_unlock_screenlock_enabled = 402 [default = false];
inline bool GcmDeviceInfo::has_auto_unlock_screenlock_enabled() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GcmDeviceInfo::set_has_auto_unlock_screenlock_enabled() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GcmDeviceInfo::clear_has_auto_unlock_screenlock_enabled() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GcmDeviceInfo::clear_auto_unlock_screenlock_enabled() {
  auto_unlock_screenlock_enabled_ = false;
  clear_has_auto_unlock_screenlock_enabled();
}
inline bool GcmDeviceInfo::auto_unlock_screenlock_enabled() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.auto_unlock_screenlock_enabled)
  return auto_unlock_screenlock_enabled_;
}
inline void GcmDeviceInfo::set_auto_unlock_screenlock_enabled(bool value) {
  set_has_auto_unlock_screenlock_enabled();
  auto_unlock_screenlock_enabled_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.auto_unlock_screenlock_enabled)
}

// optional bool bluetooth_radio_supported = 403 [default = false];
inline bool GcmDeviceInfo::has_bluetooth_radio_supported() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void GcmDeviceInfo::set_has_bluetooth_radio_supported() {
  _has_bits_[0] |= 0x04000000u;
}
inline void GcmDeviceInfo::clear_has_bluetooth_radio_supported() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void GcmDeviceInfo::clear_bluetooth_radio_supported() {
  bluetooth_radio_supported_ = false;
  clear_has_bluetooth_radio_supported();
}
inline bool GcmDeviceInfo::bluetooth_radio_supported() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.bluetooth_radio_supported)
  return bluetooth_radio_supported_;
}
inline void GcmDeviceInfo::set_bluetooth_radio_supported(bool value) {
  set_has_bluetooth_radio_supported();
  bluetooth_radio_supported_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.bluetooth_radio_supported)
}

// optional bool bluetooth_radio_enabled = 404 [default = false];
inline bool GcmDeviceInfo::has_bluetooth_radio_enabled() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void GcmDeviceInfo::set_has_bluetooth_radio_enabled() {
  _has_bits_[0] |= 0x08000000u;
}
inline void GcmDeviceInfo::clear_has_bluetooth_radio_enabled() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void GcmDeviceInfo::clear_bluetooth_radio_enabled() {
  bluetooth_radio_enabled_ = false;
  clear_has_bluetooth_radio_enabled();
}
inline bool GcmDeviceInfo::bluetooth_radio_enabled() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.bluetooth_radio_enabled)
  return bluetooth_radio_enabled_;
}
inline void GcmDeviceInfo::set_bluetooth_radio_enabled(bool value) {
  set_has_bluetooth_radio_enabled();
  bluetooth_radio_enabled_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.bluetooth_radio_enabled)
}

// optional bytes enrollment_session_id = 1000;
inline bool GcmDeviceInfo::has_enrollment_session_id() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void GcmDeviceInfo::set_has_enrollment_session_id() {
  _has_bits_[0] |= 0x10000000u;
}
inline void GcmDeviceInfo::clear_has_enrollment_session_id() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void GcmDeviceInfo::clear_enrollment_session_id() {
  enrollment_session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_enrollment_session_id();
}
inline const ::std::string& GcmDeviceInfo::enrollment_session_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.enrollment_session_id)
  return enrollment_session_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_enrollment_session_id(const ::std::string& value) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.enrollment_session_id)
}
inline void GcmDeviceInfo::set_enrollment_session_id(const char* value) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.enrollment_session_id)
}
inline void GcmDeviceInfo::set_enrollment_session_id(const void* value, size_t size) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.enrollment_session_id)
}
inline ::std::string* GcmDeviceInfo::mutable_enrollment_session_id() {
  set_has_enrollment_session_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.enrollment_session_id)
  return enrollment_session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_enrollment_session_id() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.enrollment_session_id)
  clear_has_enrollment_session_id();
  return enrollment_session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_enrollment_session_id(::std::string* enrollment_session_id) {
  if (enrollment_session_id != NULL) {
    set_has_enrollment_session_id();
  } else {
    clear_has_enrollment_session_id();
  }
  enrollment_session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enrollment_session_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.enrollment_session_id)
}

// optional string oauth_token = 1001;
inline bool GcmDeviceInfo::has_oauth_token() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void GcmDeviceInfo::set_has_oauth_token() {
  _has_bits_[0] |= 0x20000000u;
}
inline void GcmDeviceInfo::clear_has_oauth_token() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void GcmDeviceInfo::clear_oauth_token() {
  oauth_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_oauth_token();
}
inline const ::std::string& GcmDeviceInfo::oauth_token() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmDeviceInfo.oauth_token)
  return oauth_token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_oauth_token(const ::std::string& value) {
  set_has_oauth_token();
  oauth_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.GcmDeviceInfo.oauth_token)
}
inline void GcmDeviceInfo::set_oauth_token(const char* value) {
  set_has_oauth_token();
  oauth_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.GcmDeviceInfo.oauth_token)
}
inline void GcmDeviceInfo::set_oauth_token(const char* value, size_t size) {
  set_has_oauth_token();
  oauth_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.GcmDeviceInfo.oauth_token)
}
inline ::std::string* GcmDeviceInfo::mutable_oauth_token() {
  set_has_oauth_token();
  // @@protoc_insertion_point(field_mutable:cryptauth.GcmDeviceInfo.oauth_token)
  return oauth_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GcmDeviceInfo::release_oauth_token() {
  // @@protoc_insertion_point(field_release:cryptauth.GcmDeviceInfo.oauth_token)
  clear_has_oauth_token();
  return oauth_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GcmDeviceInfo::set_allocated_oauth_token(::std::string* oauth_token) {
  if (oauth_token != NULL) {
    set_has_oauth_token();
  } else {
    clear_has_oauth_token();
  }
  oauth_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oauth_token);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GcmDeviceInfo.oauth_token)
}

// -------------------------------------------------------------------

// GcmMetadata

// required .cryptauth.MessageType type = 1;
inline bool GcmMetadata::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GcmMetadata::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GcmMetadata::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GcmMetadata::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::cryptauth::MessageType GcmMetadata::type() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmMetadata.type)
  return static_cast< ::cryptauth::MessageType >(type_);
}
inline void GcmMetadata::set_type(::cryptauth::MessageType value) {
  assert(::cryptauth::MessageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmMetadata.type)
}

// optional int32 version = 2 [default = 0];
inline bool GcmMetadata::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GcmMetadata::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GcmMetadata::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GcmMetadata::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 GcmMetadata::version() const {
  // @@protoc_insertion_point(field_get:cryptauth.GcmMetadata.version)
  return version_;
}
inline void GcmMetadata::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GcmMetadata.version)
}

// -------------------------------------------------------------------

// GetMyDevicesRequest

// optional bool approved_for_unlock_required = 2;
inline bool GetMyDevicesRequest::has_approved_for_unlock_required() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMyDevicesRequest::set_has_approved_for_unlock_required() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMyDevicesRequest::clear_has_approved_for_unlock_required() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMyDevicesRequest::clear_approved_for_unlock_required() {
  approved_for_unlock_required_ = false;
  clear_has_approved_for_unlock_required();
}
inline bool GetMyDevicesRequest::approved_for_unlock_required() const {
  // @@protoc_insertion_point(field_get:cryptauth.GetMyDevicesRequest.approved_for_unlock_required)
  return approved_for_unlock_required_;
}
inline void GetMyDevicesRequest::set_approved_for_unlock_required(bool value) {
  set_has_approved_for_unlock_required();
  approved_for_unlock_required_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GetMyDevicesRequest.approved_for_unlock_required)
}

// optional bool allow_stale_read = 3 [default = false];
inline bool GetMyDevicesRequest::has_allow_stale_read() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMyDevicesRequest::set_has_allow_stale_read() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMyDevicesRequest::clear_has_allow_stale_read() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMyDevicesRequest::clear_allow_stale_read() {
  allow_stale_read_ = false;
  clear_has_allow_stale_read();
}
inline bool GetMyDevicesRequest::allow_stale_read() const {
  // @@protoc_insertion_point(field_get:cryptauth.GetMyDevicesRequest.allow_stale_read)
  return allow_stale_read_;
}
inline void GetMyDevicesRequest::set_allow_stale_read(bool value) {
  set_has_allow_stale_read();
  allow_stale_read_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GetMyDevicesRequest.allow_stale_read)
}

// optional int32 invocation_reason = 4 [default = 0];
inline bool GetMyDevicesRequest::has_invocation_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetMyDevicesRequest::set_has_invocation_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetMyDevicesRequest::clear_has_invocation_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetMyDevicesRequest::clear_invocation_reason() {
  invocation_reason_ = 0;
  clear_has_invocation_reason();
}
inline ::google::protobuf::int32 GetMyDevicesRequest::invocation_reason() const {
  // @@protoc_insertion_point(field_get:cryptauth.GetMyDevicesRequest.invocation_reason)
  return invocation_reason_;
}
inline void GetMyDevicesRequest::set_invocation_reason(::google::protobuf::int32 value) {
  set_has_invocation_reason();
  invocation_reason_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GetMyDevicesRequest.invocation_reason)
}

// optional int32 retry_count = 5 [default = 0];
inline bool GetMyDevicesRequest::has_retry_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetMyDevicesRequest::set_has_retry_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetMyDevicesRequest::clear_has_retry_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetMyDevicesRequest::clear_retry_count() {
  retry_count_ = 0;
  clear_has_retry_count();
}
inline ::google::protobuf::int32 GetMyDevicesRequest::retry_count() const {
  // @@protoc_insertion_point(field_get:cryptauth.GetMyDevicesRequest.retry_count)
  return retry_count_;
}
inline void GetMyDevicesRequest::set_retry_count(::google::protobuf::int32 value) {
  set_has_retry_count();
  retry_count_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.GetMyDevicesRequest.retry_count)
}

// optional .cryptauth.DeviceClassifier device_classifier = 6;
inline bool GetMyDevicesRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetMyDevicesRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetMyDevicesRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetMyDevicesRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
inline const ::cryptauth::DeviceClassifier& GetMyDevicesRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.GetMyDevicesRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
inline ::cryptauth::DeviceClassifier* GetMyDevicesRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.GetMyDevicesRequest.device_classifier)
  return device_classifier_;
}
inline ::cryptauth::DeviceClassifier* GetMyDevicesRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.GetMyDevicesRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
inline void GetMyDevicesRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.GetMyDevicesRequest.device_classifier)
}

// -------------------------------------------------------------------

// GetMyDevicesResponse

// repeated .cryptauth.ExternalDeviceInfo devices = 1;
inline int GetMyDevicesResponse::devices_size() const {
  return devices_.size();
}
inline void GetMyDevicesResponse::clear_devices() {
  devices_.Clear();
}
inline const ::cryptauth::ExternalDeviceInfo& GetMyDevicesResponse::devices(int index) const {
  // @@protoc_insertion_point(field_get:cryptauth.GetMyDevicesResponse.devices)
  return devices_.Get(index);
}
inline ::cryptauth::ExternalDeviceInfo* GetMyDevicesResponse::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:cryptauth.GetMyDevicesResponse.devices)
  return devices_.Mutable(index);
}
inline ::cryptauth::ExternalDeviceInfo* GetMyDevicesResponse::add_devices() {
  // @@protoc_insertion_point(field_add:cryptauth.GetMyDevicesResponse.devices)
  return devices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo >*
GetMyDevicesResponse::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:cryptauth.GetMyDevicesResponse.devices)
  return &devices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cryptauth::ExternalDeviceInfo >&
GetMyDevicesResponse::devices() const {
  // @@protoc_insertion_point(field_list:cryptauth.GetMyDevicesResponse.devices)
  return devices_;
}

// -------------------------------------------------------------------

// IneligibleDevice

// optional .cryptauth.ExternalDeviceInfo device = 1;
inline bool IneligibleDevice::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IneligibleDevice::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IneligibleDevice::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IneligibleDevice::clear_device() {
  if (device_ != NULL) device_->::cryptauth::ExternalDeviceInfo::Clear();
  clear_has_device();
}
inline const ::cryptauth::ExternalDeviceInfo& IneligibleDevice::device() const {
  // @@protoc_insertion_point(field_get:cryptauth.IneligibleDevice.device)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_ != NULL ? *device_ : *default_instance().device_;
#else
  return device_ != NULL ? *device_ : *default_instance_->device_;
#endif
}
inline ::cryptauth::ExternalDeviceInfo* IneligibleDevice::mutable_device() {
  set_has_device();
  if (device_ == NULL) {
    device_ = new ::cryptauth::ExternalDeviceInfo;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.IneligibleDevice.device)
  return device_;
}
inline ::cryptauth::ExternalDeviceInfo* IneligibleDevice::release_device() {
  // @@protoc_insertion_point(field_release:cryptauth.IneligibleDevice.device)
  clear_has_device();
  ::cryptauth::ExternalDeviceInfo* temp = device_;
  device_ = NULL;
  return temp;
}
inline void IneligibleDevice::set_allocated_device(::cryptauth::ExternalDeviceInfo* device) {
  delete device_;
  device_ = device;
  if (device) {
    set_has_device();
  } else {
    clear_has_device();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.IneligibleDevice.device)
}

// repeated string reasons = 2;
inline int IneligibleDevice::reasons_size() const {
  return reasons_.size();
}
inline void IneligibleDevice::clear_reasons() {
  reasons_.Clear();
}
inline const ::std::string& IneligibleDevice::reasons(int index) const {
  // @@protoc_insertion_point(field_get:cryptauth.IneligibleDevice.reasons)
  return reasons_.Get(index);
}
inline ::std::string* IneligibleDevice::mutable_reasons(int index) {
  // @@protoc_insertion_point(field_mutable:cryptauth.IneligibleDevice.reasons)
  return reasons_.Mutable(index);
}
inline void IneligibleDevice::set_reasons(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cryptauth.IneligibleDevice.reasons)
  reasons_.Mutable(index)->assign(value);
}
inline void IneligibleDevice::set_reasons(int index, const char* value) {
  reasons_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cryptauth.IneligibleDevice.reasons)
}
inline void IneligibleDevice::set_reasons(int index, const char* value, size_t size) {
  reasons_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cryptauth.IneligibleDevice.reasons)
}
inline ::std::string* IneligibleDevice::add_reasons() {
  // @@protoc_insertion_point(field_add_mutable:cryptauth.IneligibleDevice.reasons)
  return reasons_.Add();
}
inline void IneligibleDevice::add_reasons(const ::std::string& value) {
  reasons_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cryptauth.IneligibleDevice.reasons)
}
inline void IneligibleDevice::add_reasons(const char* value) {
  reasons_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cryptauth.IneligibleDevice.reasons)
}
inline void IneligibleDevice::add_reasons(const char* value, size_t size) {
  reasons_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cryptauth.IneligibleDevice.reasons)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IneligibleDevice::reasons() const {
  // @@protoc_insertion_point(field_list:cryptauth.IneligibleDevice.reasons)
  return reasons_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IneligibleDevice::mutable_reasons() {
  // @@protoc_insertion_point(field_mutable_list:cryptauth.IneligibleDevice.reasons)
  return &reasons_;
}

// -------------------------------------------------------------------

// SendDeviceSyncTickleRequest

// optional .cryptauth.RegistrationTickleType tickle_type = 3;
inline bool SendDeviceSyncTickleRequest::has_tickle_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendDeviceSyncTickleRequest::set_has_tickle_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendDeviceSyncTickleRequest::clear_has_tickle_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendDeviceSyncTickleRequest::clear_tickle_type() {
  tickle_type_ = 0;
  clear_has_tickle_type();
}
inline ::cryptauth::RegistrationTickleType SendDeviceSyncTickleRequest::tickle_type() const {
  // @@protoc_insertion_point(field_get:cryptauth.SendDeviceSyncTickleRequest.tickle_type)
  return static_cast< ::cryptauth::RegistrationTickleType >(tickle_type_);
}
inline void SendDeviceSyncTickleRequest::set_tickle_type(::cryptauth::RegistrationTickleType value) {
  assert(::cryptauth::RegistrationTickleType_IsValid(value));
  set_has_tickle_type();
  tickle_type_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.SendDeviceSyncTickleRequest.tickle_type)
}

// optional .cryptauth.DeviceClassifier device_classifier = 4;
inline bool SendDeviceSyncTickleRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendDeviceSyncTickleRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendDeviceSyncTickleRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendDeviceSyncTickleRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
inline const ::cryptauth::DeviceClassifier& SendDeviceSyncTickleRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.SendDeviceSyncTickleRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
inline ::cryptauth::DeviceClassifier* SendDeviceSyncTickleRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.SendDeviceSyncTickleRequest.device_classifier)
  return device_classifier_;
}
inline ::cryptauth::DeviceClassifier* SendDeviceSyncTickleRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.SendDeviceSyncTickleRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
inline void SendDeviceSyncTickleRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SendDeviceSyncTickleRequest.device_classifier)
}

// -------------------------------------------------------------------

// SendDeviceSyncTickleResponse

// -------------------------------------------------------------------

// SetupEnrollmentInfo

// optional string type = 1;
inline bool SetupEnrollmentInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetupEnrollmentInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetupEnrollmentInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetupEnrollmentInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& SetupEnrollmentInfo::type() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentInfo.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetupEnrollmentInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentInfo.type)
}
inline void SetupEnrollmentInfo::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentInfo.type)
}
inline void SetupEnrollmentInfo::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentInfo.type)
}
inline ::std::string* SetupEnrollmentInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetupEnrollmentInfo::release_type() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentInfo.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetupEnrollmentInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentInfo.type)
}

// optional bytes enrollment_session_id = 2;
inline bool SetupEnrollmentInfo::has_enrollment_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetupEnrollmentInfo::set_has_enrollment_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetupEnrollmentInfo::clear_has_enrollment_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetupEnrollmentInfo::clear_enrollment_session_id() {
  enrollment_session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_enrollment_session_id();
}
inline const ::std::string& SetupEnrollmentInfo::enrollment_session_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
  return enrollment_session_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetupEnrollmentInfo::set_enrollment_session_id(const ::std::string& value) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
}
inline void SetupEnrollmentInfo::set_enrollment_session_id(const char* value) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
}
inline void SetupEnrollmentInfo::set_enrollment_session_id(const void* value, size_t size) {
  set_has_enrollment_session_id();
  enrollment_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
}
inline ::std::string* SetupEnrollmentInfo::mutable_enrollment_session_id() {
  set_has_enrollment_session_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
  return enrollment_session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetupEnrollmentInfo::release_enrollment_session_id() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
  clear_has_enrollment_session_id();
  return enrollment_session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetupEnrollmentInfo::set_allocated_enrollment_session_id(::std::string* enrollment_session_id) {
  if (enrollment_session_id != NULL) {
    set_has_enrollment_session_id();
  } else {
    clear_has_enrollment_session_id();
  }
  enrollment_session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enrollment_session_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentInfo.enrollment_session_id)
}

// optional bytes server_ephemeral_key = 3;
inline bool SetupEnrollmentInfo::has_server_ephemeral_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetupEnrollmentInfo::set_has_server_ephemeral_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetupEnrollmentInfo::clear_has_server_ephemeral_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetupEnrollmentInfo::clear_server_ephemeral_key() {
  server_ephemeral_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_server_ephemeral_key();
}
inline const ::std::string& SetupEnrollmentInfo::server_ephemeral_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
  return server_ephemeral_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetupEnrollmentInfo::set_server_ephemeral_key(const ::std::string& value) {
  set_has_server_ephemeral_key();
  server_ephemeral_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
}
inline void SetupEnrollmentInfo::set_server_ephemeral_key(const char* value) {
  set_has_server_ephemeral_key();
  server_ephemeral_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
}
inline void SetupEnrollmentInfo::set_server_ephemeral_key(const void* value, size_t size) {
  set_has_server_ephemeral_key();
  server_ephemeral_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
}
inline ::std::string* SetupEnrollmentInfo::mutable_server_ephemeral_key() {
  set_has_server_ephemeral_key();
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
  return server_ephemeral_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetupEnrollmentInfo::release_server_ephemeral_key() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
  clear_has_server_ephemeral_key();
  return server_ephemeral_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetupEnrollmentInfo::set_allocated_server_ephemeral_key(::std::string* server_ephemeral_key) {
  if (server_ephemeral_key != NULL) {
    set_has_server_ephemeral_key();
  } else {
    clear_has_server_ephemeral_key();
  }
  server_ephemeral_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_ephemeral_key);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentInfo.server_ephemeral_key)
}

// -------------------------------------------------------------------

// SetupEnrollmentRequest

// optional string origin = 2;
inline bool SetupEnrollmentRequest::has_origin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetupEnrollmentRequest::set_has_origin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetupEnrollmentRequest::clear_has_origin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetupEnrollmentRequest::clear_origin() {
  origin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_origin();
}
inline const ::std::string& SetupEnrollmentRequest::origin() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.origin)
  return origin_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetupEnrollmentRequest::set_origin(const ::std::string& value) {
  set_has_origin();
  origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentRequest.origin)
}
inline void SetupEnrollmentRequest::set_origin(const char* value) {
  set_has_origin();
  origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentRequest.origin)
}
inline void SetupEnrollmentRequest::set_origin(const char* value, size_t size) {
  set_has_origin();
  origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentRequest.origin)
}
inline ::std::string* SetupEnrollmentRequest::mutable_origin() {
  set_has_origin();
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentRequest.origin)
  return origin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetupEnrollmentRequest::release_origin() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentRequest.origin)
  clear_has_origin();
  return origin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetupEnrollmentRequest::set_allocated_origin(::std::string* origin) {
  if (origin != NULL) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  origin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), origin);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentRequest.origin)
}

// repeated string types = 3;
inline int SetupEnrollmentRequest::types_size() const {
  return types_.size();
}
inline void SetupEnrollmentRequest::clear_types() {
  types_.Clear();
}
inline const ::std::string& SetupEnrollmentRequest::types(int index) const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.types)
  return types_.Get(index);
}
inline ::std::string* SetupEnrollmentRequest::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentRequest.types)
  return types_.Mutable(index);
}
inline void SetupEnrollmentRequest::set_types(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentRequest.types)
  types_.Mutable(index)->assign(value);
}
inline void SetupEnrollmentRequest::set_types(int index, const char* value) {
  types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentRequest.types)
}
inline void SetupEnrollmentRequest::set_types(int index, const char* value, size_t size) {
  types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentRequest.types)
}
inline ::std::string* SetupEnrollmentRequest::add_types() {
  // @@protoc_insertion_point(field_add_mutable:cryptauth.SetupEnrollmentRequest.types)
  return types_.Add();
}
inline void SetupEnrollmentRequest::add_types(const ::std::string& value) {
  types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:cryptauth.SetupEnrollmentRequest.types)
}
inline void SetupEnrollmentRequest::add_types(const char* value) {
  types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:cryptauth.SetupEnrollmentRequest.types)
}
inline void SetupEnrollmentRequest::add_types(const char* value, size_t size) {
  types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:cryptauth.SetupEnrollmentRequest.types)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SetupEnrollmentRequest::types() const {
  // @@protoc_insertion_point(field_list:cryptauth.SetupEnrollmentRequest.types)
  return types_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SetupEnrollmentRequest::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:cryptauth.SetupEnrollmentRequest.types)
  return &types_;
}

// optional bool use_legacy_crypto = 4;
inline bool SetupEnrollmentRequest::has_use_legacy_crypto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetupEnrollmentRequest::set_has_use_legacy_crypto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetupEnrollmentRequest::clear_has_use_legacy_crypto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetupEnrollmentRequest::clear_use_legacy_crypto() {
  use_legacy_crypto_ = false;
  clear_has_use_legacy_crypto();
}
inline bool SetupEnrollmentRequest::use_legacy_crypto() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.use_legacy_crypto)
  return use_legacy_crypto_;
}
inline void SetupEnrollmentRequest::set_use_legacy_crypto(bool value) {
  set_has_use_legacy_crypto();
  use_legacy_crypto_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentRequest.use_legacy_crypto)
}

// optional string application_id = 5;
inline bool SetupEnrollmentRequest::has_application_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetupEnrollmentRequest::set_has_application_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetupEnrollmentRequest::clear_has_application_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetupEnrollmentRequest::clear_application_id() {
  application_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_application_id();
}
inline const ::std::string& SetupEnrollmentRequest::application_id() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.application_id)
  return application_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetupEnrollmentRequest::set_application_id(const ::std::string& value) {
  set_has_application_id();
  application_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentRequest.application_id)
}
inline void SetupEnrollmentRequest::set_application_id(const char* value) {
  set_has_application_id();
  application_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentRequest.application_id)
}
inline void SetupEnrollmentRequest::set_application_id(const char* value, size_t size) {
  set_has_application_id();
  application_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentRequest.application_id)
}
inline ::std::string* SetupEnrollmentRequest::mutable_application_id() {
  set_has_application_id();
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentRequest.application_id)
  return application_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetupEnrollmentRequest::release_application_id() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentRequest.application_id)
  clear_has_application_id();
  return application_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetupEnrollmentRequest::set_allocated_application_id(::std::string* application_id) {
  if (application_id != NULL) {
    set_has_application_id();
  } else {
    clear_has_application_id();
  }
  application_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application_id);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentRequest.application_id)
}

// optional int32 invocation_reason = 6 [default = 0];
inline bool SetupEnrollmentRequest::has_invocation_reason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetupEnrollmentRequest::set_has_invocation_reason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetupEnrollmentRequest::clear_has_invocation_reason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetupEnrollmentRequest::clear_invocation_reason() {
  invocation_reason_ = 0;
  clear_has_invocation_reason();
}
inline ::google::protobuf::int32 SetupEnrollmentRequest::invocation_reason() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.invocation_reason)
  return invocation_reason_;
}
inline void SetupEnrollmentRequest::set_invocation_reason(::google::protobuf::int32 value) {
  set_has_invocation_reason();
  invocation_reason_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentRequest.invocation_reason)
}

// optional int32 retry_count = 7 [default = 0];
inline bool SetupEnrollmentRequest::has_retry_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SetupEnrollmentRequest::set_has_retry_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SetupEnrollmentRequest::clear_has_retry_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SetupEnrollmentRequest::clear_retry_count() {
  retry_count_ = 0;
  clear_has_retry_count();
}
inline ::google::protobuf::int32 SetupEnrollmentRequest::retry_count() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.retry_count)
  return retry_count_;
}
inline void SetupEnrollmentRequest::set_retry_count(::google::protobuf::int32 value) {
  set_has_retry_count();
  retry_count_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentRequest.retry_count)
}

// optional .cryptauth.DeviceClassifier device_classifier = 8;
inline bool SetupEnrollmentRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SetupEnrollmentRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SetupEnrollmentRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SetupEnrollmentRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
inline const ::cryptauth::DeviceClassifier& SetupEnrollmentRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
inline ::cryptauth::DeviceClassifier* SetupEnrollmentRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentRequest.device_classifier)
  return device_classifier_;
}
inline ::cryptauth::DeviceClassifier* SetupEnrollmentRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
inline void SetupEnrollmentRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentRequest.device_classifier)
}

// -------------------------------------------------------------------

// SetupEnrollmentResponse

// optional string status = 1;
inline bool SetupEnrollmentResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetupEnrollmentResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetupEnrollmentResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetupEnrollmentResponse::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& SetupEnrollmentResponse::status() const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentResponse.status)
  return status_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetupEnrollmentResponse::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.SetupEnrollmentResponse.status)
}
inline void SetupEnrollmentResponse::set_status(const char* value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.SetupEnrollmentResponse.status)
}
inline void SetupEnrollmentResponse::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.SetupEnrollmentResponse.status)
}
inline ::std::string* SetupEnrollmentResponse::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentResponse.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetupEnrollmentResponse::release_status() {
  // @@protoc_insertion_point(field_release:cryptauth.SetupEnrollmentResponse.status)
  clear_has_status();
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetupEnrollmentResponse::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.SetupEnrollmentResponse.status)
}

// repeated .cryptauth.SetupEnrollmentInfo infos = 2;
inline int SetupEnrollmentResponse::infos_size() const {
  return infos_.size();
}
inline void SetupEnrollmentResponse::clear_infos() {
  infos_.Clear();
}
inline const ::cryptauth::SetupEnrollmentInfo& SetupEnrollmentResponse::infos(int index) const {
  // @@protoc_insertion_point(field_get:cryptauth.SetupEnrollmentResponse.infos)
  return infos_.Get(index);
}
inline ::cryptauth::SetupEnrollmentInfo* SetupEnrollmentResponse::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:cryptauth.SetupEnrollmentResponse.infos)
  return infos_.Mutable(index);
}
inline ::cryptauth::SetupEnrollmentInfo* SetupEnrollmentResponse::add_infos() {
  // @@protoc_insertion_point(field_add:cryptauth.SetupEnrollmentResponse.infos)
  return infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::cryptauth::SetupEnrollmentInfo >*
SetupEnrollmentResponse::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:cryptauth.SetupEnrollmentResponse.infos)
  return &infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::cryptauth::SetupEnrollmentInfo >&
SetupEnrollmentResponse::infos() const {
  // @@protoc_insertion_point(field_list:cryptauth.SetupEnrollmentResponse.infos)
  return infos_;
}

// -------------------------------------------------------------------

// ToggleEasyUnlockRequest

// optional bool enable = 1;
inline bool ToggleEasyUnlockRequest::has_enable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ToggleEasyUnlockRequest::set_has_enable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ToggleEasyUnlockRequest::clear_has_enable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ToggleEasyUnlockRequest::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool ToggleEasyUnlockRequest::enable() const {
  // @@protoc_insertion_point(field_get:cryptauth.ToggleEasyUnlockRequest.enable)
  return enable_;
}
inline void ToggleEasyUnlockRequest::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.ToggleEasyUnlockRequest.enable)
}

// optional bytes public_key = 2;
inline bool ToggleEasyUnlockRequest::has_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ToggleEasyUnlockRequest::set_has_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ToggleEasyUnlockRequest::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ToggleEasyUnlockRequest::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
inline const ::std::string& ToggleEasyUnlockRequest::public_key() const {
  // @@protoc_insertion_point(field_get:cryptauth.ToggleEasyUnlockRequest.public_key)
  return public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ToggleEasyUnlockRequest::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cryptauth.ToggleEasyUnlockRequest.public_key)
}
inline void ToggleEasyUnlockRequest::set_public_key(const char* value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cryptauth.ToggleEasyUnlockRequest.public_key)
}
inline void ToggleEasyUnlockRequest::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cryptauth.ToggleEasyUnlockRequest.public_key)
}
inline ::std::string* ToggleEasyUnlockRequest::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:cryptauth.ToggleEasyUnlockRequest.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ToggleEasyUnlockRequest::release_public_key() {
  // @@protoc_insertion_point(field_release:cryptauth.ToggleEasyUnlockRequest.public_key)
  clear_has_public_key();
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ToggleEasyUnlockRequest::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:cryptauth.ToggleEasyUnlockRequest.public_key)
}

// optional bool apply_to_all = 3;
inline bool ToggleEasyUnlockRequest::has_apply_to_all() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ToggleEasyUnlockRequest::set_has_apply_to_all() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ToggleEasyUnlockRequest::clear_has_apply_to_all() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ToggleEasyUnlockRequest::clear_apply_to_all() {
  apply_to_all_ = false;
  clear_has_apply_to_all();
}
inline bool ToggleEasyUnlockRequest::apply_to_all() const {
  // @@protoc_insertion_point(field_get:cryptauth.ToggleEasyUnlockRequest.apply_to_all)
  return apply_to_all_;
}
inline void ToggleEasyUnlockRequest::set_apply_to_all(bool value) {
  set_has_apply_to_all();
  apply_to_all_ = value;
  // @@protoc_insertion_point(field_set:cryptauth.ToggleEasyUnlockRequest.apply_to_all)
}

// optional .cryptauth.DeviceClassifier device_classifier = 4;
inline bool ToggleEasyUnlockRequest::has_device_classifier() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ToggleEasyUnlockRequest::set_has_device_classifier() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ToggleEasyUnlockRequest::clear_has_device_classifier() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ToggleEasyUnlockRequest::clear_device_classifier() {
  if (device_classifier_ != NULL) device_classifier_->::cryptauth::DeviceClassifier::Clear();
  clear_has_device_classifier();
}
inline const ::cryptauth::DeviceClassifier& ToggleEasyUnlockRequest::device_classifier() const {
  // @@protoc_insertion_point(field_get:cryptauth.ToggleEasyUnlockRequest.device_classifier)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance().device_classifier_;
#else
  return device_classifier_ != NULL ? *device_classifier_ : *default_instance_->device_classifier_;
#endif
}
inline ::cryptauth::DeviceClassifier* ToggleEasyUnlockRequest::mutable_device_classifier() {
  set_has_device_classifier();
  if (device_classifier_ == NULL) {
    device_classifier_ = new ::cryptauth::DeviceClassifier;
  }
  // @@protoc_insertion_point(field_mutable:cryptauth.ToggleEasyUnlockRequest.device_classifier)
  return device_classifier_;
}
inline ::cryptauth::DeviceClassifier* ToggleEasyUnlockRequest::release_device_classifier() {
  // @@protoc_insertion_point(field_release:cryptauth.ToggleEasyUnlockRequest.device_classifier)
  clear_has_device_classifier();
  ::cryptauth::DeviceClassifier* temp = device_classifier_;
  device_classifier_ = NULL;
  return temp;
}
inline void ToggleEasyUnlockRequest::set_allocated_device_classifier(::cryptauth::DeviceClassifier* device_classifier) {
  delete device_classifier_;
  device_classifier_ = device_classifier;
  if (device_classifier) {
    set_has_device_classifier();
  } else {
    clear_has_device_classifier();
  }
  // @@protoc_insertion_point(field_set_allocated:cryptauth.ToggleEasyUnlockRequest.device_classifier)
}

// -------------------------------------------------------------------

// ToggleEasyUnlockResponse

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace cryptauth

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cryptauth::DeviceType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::cryptauth::InvocationReason> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::cryptauth::MessageType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::cryptauth::RegistrationTickleType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cryptauth_5fapi_2eproto__INCLUDED
