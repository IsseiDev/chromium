// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: securemessage.proto

#ifndef PROTOBUF_securemessage_2eproto__INCLUDED
#define PROTOBUF_securemessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace securemessage {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_securemessage_2eproto();
void protobuf_AssignDesc_securemessage_2eproto();
void protobuf_ShutdownFile_securemessage_2eproto();

class DeviceToDeviceMessage;
class DhPublicKey;
class EcP256PublicKey;
class GenericPublicKey;
class Header;
class HeaderAndBody;
class InitiatorHello;
class ResponderHello;
class SecureMessage;
class SimpleRsaPublicKey;

enum SigScheme {
  HMAC_SHA256 = 1,
  ECDSA_P256_SHA256 = 2,
  RSA2048_SHA256 = 3
};
bool SigScheme_IsValid(int value);
const SigScheme SigScheme_MIN = HMAC_SHA256;
const SigScheme SigScheme_MAX = RSA2048_SHA256;
const int SigScheme_ARRAYSIZE = SigScheme_MAX + 1;

enum EncScheme {
  NONE = 1,
  AES_256_CBC = 2
};
bool EncScheme_IsValid(int value);
const EncScheme EncScheme_MIN = NONE;
const EncScheme EncScheme_MAX = AES_256_CBC;
const int EncScheme_ARRAYSIZE = EncScheme_MAX + 1;

enum PublicKeyType {
  EC_P256 = 1,
  RSA2048 = 2,
  DH2048_MODP = 3
};
bool PublicKeyType_IsValid(int value);
const PublicKeyType PublicKeyType_MIN = EC_P256;
const PublicKeyType PublicKeyType_MAX = DH2048_MODP;
const int PublicKeyType_ARRAYSIZE = PublicKeyType_MAX + 1;

// ===================================================================

class SecureMessage : public ::google::protobuf::MessageLite {
 public:
  SecureMessage();
  virtual ~SecureMessage();

  SecureMessage(const SecureMessage& from);

  inline SecureMessage& operator=(const SecureMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SecureMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SecureMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(SecureMessage* other);

  // implements Message ----------------------------------------------

  inline SecureMessage* New() const { return New(NULL); }

  SecureMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SecureMessage& from);
  void MergeFrom(const SecureMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SecureMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes header_and_body = 1;
  bool has_header_and_body() const;
  void clear_header_and_body();
  static const int kHeaderAndBodyFieldNumber = 1;
  const ::std::string& header_and_body() const;
  void set_header_and_body(const ::std::string& value);
  void set_header_and_body(const char* value);
  void set_header_and_body(const void* value, size_t size);
  ::std::string* mutable_header_and_body();
  ::std::string* release_header_and_body();
  void set_allocated_header_and_body(::std::string* header_and_body);

  // required bytes signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:securemessage.SecureMessage)
 private:
  inline void set_has_header_and_body();
  inline void clear_has_header_and_body();
  inline void set_has_signature();
  inline void clear_has_signature();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr header_and_body_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_securemessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_securemessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_securemessage_2eproto();
  friend void protobuf_ShutdownFile_securemessage_2eproto();

  void InitAsDefaultInstance();
  static SecureMessage* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::MessageLite {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Header& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Header* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(Header* other);

  // implements Message ----------------------------------------------

  inline Header* New() const { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .securemessage.SigScheme signature_scheme = 1;
  bool has_signature_scheme() const;
  void clear_signature_scheme();
  static const int kSignatureSchemeFieldNumber = 1;
  ::securemessage::SigScheme signature_scheme() const;
  void set_signature_scheme(::securemessage::SigScheme value);

  // required .securemessage.EncScheme encryption_scheme = 2;
  bool has_encryption_scheme() const;
  void clear_encryption_scheme();
  static const int kEncryptionSchemeFieldNumber = 2;
  ::securemessage::EncScheme encryption_scheme() const;
  void set_encryption_scheme(::securemessage::EncScheme value);

  // optional bytes verification_key_id = 3;
  bool has_verification_key_id() const;
  void clear_verification_key_id();
  static const int kVerificationKeyIdFieldNumber = 3;
  const ::std::string& verification_key_id() const;
  void set_verification_key_id(const ::std::string& value);
  void set_verification_key_id(const char* value);
  void set_verification_key_id(const void* value, size_t size);
  ::std::string* mutable_verification_key_id();
  ::std::string* release_verification_key_id();
  void set_allocated_verification_key_id(::std::string* verification_key_id);

  // optional bytes decryption_key_id = 4;
  bool has_decryption_key_id() const;
  void clear_decryption_key_id();
  static const int kDecryptionKeyIdFieldNumber = 4;
  const ::std::string& decryption_key_id() const;
  void set_decryption_key_id(const ::std::string& value);
  void set_decryption_key_id(const char* value);
  void set_decryption_key_id(const void* value, size_t size);
  ::std::string* mutable_decryption_key_id();
  ::std::string* release_decryption_key_id();
  void set_allocated_decryption_key_id(::std::string* decryption_key_id);

  // optional bytes iv = 5;
  bool has_iv() const;
  void clear_iv();
  static const int kIvFieldNumber = 5;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // optional bytes public_metadata = 6;
  bool has_public_metadata() const;
  void clear_public_metadata();
  static const int kPublicMetadataFieldNumber = 6;
  const ::std::string& public_metadata() const;
  void set_public_metadata(const ::std::string& value);
  void set_public_metadata(const char* value);
  void set_public_metadata(const void* value, size_t size);
  ::std::string* mutable_public_metadata();
  ::std::string* release_public_metadata();
  void set_allocated_public_metadata(::std::string* public_metadata);

  // optional uint32 associated_data_length = 7 [default = 0];
  bool has_associated_data_length() const;
  void clear_associated_data_length();
  static const int kAssociatedDataLengthFieldNumber = 7;
  ::google::protobuf::uint32 associated_data_length() const;
  void set_associated_data_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:securemessage.Header)
 private:
  inline void set_has_signature_scheme();
  inline void clear_has_signature_scheme();
  inline void set_has_encryption_scheme();
  inline void clear_has_encryption_scheme();
  inline void set_has_verification_key_id();
  inline void clear_has_verification_key_id();
  inline void set_has_decryption_key_id();
  inline void clear_has_decryption_key_id();
  inline void set_has_iv();
  inline void clear_has_iv();
  inline void set_has_public_metadata();
  inline void clear_has_public_metadata();
  inline void set_has_associated_data_length();
  inline void clear_has_associated_data_length();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int signature_scheme_;
  int encryption_scheme_;
  ::google::protobuf::internal::ArenaStringPtr verification_key_id_;
  ::google::protobuf::internal::ArenaStringPtr decryption_key_id_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  ::google::protobuf::internal::ArenaStringPtr public_metadata_;
  ::google::protobuf::uint32 associated_data_length_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_securemessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_securemessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_securemessage_2eproto();
  friend void protobuf_ShutdownFile_securemessage_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class HeaderAndBody : public ::google::protobuf::MessageLite {
 public:
  HeaderAndBody();
  virtual ~HeaderAndBody();

  HeaderAndBody(const HeaderAndBody& from);

  inline HeaderAndBody& operator=(const HeaderAndBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const HeaderAndBody& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeaderAndBody* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(HeaderAndBody* other);

  // implements Message ----------------------------------------------

  inline HeaderAndBody* New() const { return New(NULL); }

  HeaderAndBody* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeaderAndBody& from);
  void MergeFrom(const HeaderAndBody& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeaderAndBody* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .securemessage.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::securemessage::Header& header() const;
  ::securemessage::Header* mutable_header();
  ::securemessage::Header* release_header();
  void set_allocated_header(::securemessage::Header* header);

  // required bytes body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  const ::std::string& body() const;
  void set_body(const ::std::string& value);
  void set_body(const char* value);
  void set_body(const void* value, size_t size);
  ::std::string* mutable_body();
  ::std::string* release_body();
  void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:securemessage.HeaderAndBody)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::securemessage::Header* header_;
  ::google::protobuf::internal::ArenaStringPtr body_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_securemessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_securemessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_securemessage_2eproto();
  friend void protobuf_ShutdownFile_securemessage_2eproto();

  void InitAsDefaultInstance();
  static HeaderAndBody* default_instance_;
};
// -------------------------------------------------------------------

class EcP256PublicKey : public ::google::protobuf::MessageLite {
 public:
  EcP256PublicKey();
  virtual ~EcP256PublicKey();

  EcP256PublicKey(const EcP256PublicKey& from);

  inline EcP256PublicKey& operator=(const EcP256PublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EcP256PublicKey& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EcP256PublicKey* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(EcP256PublicKey* other);

  // implements Message ----------------------------------------------

  inline EcP256PublicKey* New() const { return New(NULL); }

  EcP256PublicKey* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EcP256PublicKey& from);
  void MergeFrom(const EcP256PublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EcP256PublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  const ::std::string& x() const;
  void set_x(const ::std::string& value);
  void set_x(const char* value);
  void set_x(const void* value, size_t size);
  ::std::string* mutable_x();
  ::std::string* release_x();
  void set_allocated_x(::std::string* x);

  // required bytes y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  const ::std::string& y() const;
  void set_y(const ::std::string& value);
  void set_y(const char* value);
  void set_y(const void* value, size_t size);
  ::std::string* mutable_y();
  ::std::string* release_y();
  void set_allocated_y(::std::string* y);

  // @@protoc_insertion_point(class_scope:securemessage.EcP256PublicKey)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr x_;
  ::google::protobuf::internal::ArenaStringPtr y_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_securemessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_securemessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_securemessage_2eproto();
  friend void protobuf_ShutdownFile_securemessage_2eproto();

  void InitAsDefaultInstance();
  static EcP256PublicKey* default_instance_;
};
// -------------------------------------------------------------------

class SimpleRsaPublicKey : public ::google::protobuf::MessageLite {
 public:
  SimpleRsaPublicKey();
  virtual ~SimpleRsaPublicKey();

  SimpleRsaPublicKey(const SimpleRsaPublicKey& from);

  inline SimpleRsaPublicKey& operator=(const SimpleRsaPublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SimpleRsaPublicKey& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SimpleRsaPublicKey* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(SimpleRsaPublicKey* other);

  // implements Message ----------------------------------------------

  inline SimpleRsaPublicKey* New() const { return New(NULL); }

  SimpleRsaPublicKey* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SimpleRsaPublicKey& from);
  void MergeFrom(const SimpleRsaPublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SimpleRsaPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes n = 1;
  bool has_n() const;
  void clear_n();
  static const int kNFieldNumber = 1;
  const ::std::string& n() const;
  void set_n(const ::std::string& value);
  void set_n(const char* value);
  void set_n(const void* value, size_t size);
  ::std::string* mutable_n();
  ::std::string* release_n();
  void set_allocated_n(::std::string* n);

  // optional int32 e = 2 [default = 65537];
  bool has_e() const;
  void clear_e();
  static const int kEFieldNumber = 2;
  ::google::protobuf::int32 e() const;
  void set_e(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:securemessage.SimpleRsaPublicKey)
 private:
  inline void set_has_n();
  inline void clear_has_n();
  inline void set_has_e();
  inline void clear_has_e();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr n_;
  ::google::protobuf::int32 e_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_securemessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_securemessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_securemessage_2eproto();
  friend void protobuf_ShutdownFile_securemessage_2eproto();

  void InitAsDefaultInstance();
  static SimpleRsaPublicKey* default_instance_;
};
// -------------------------------------------------------------------

class DhPublicKey : public ::google::protobuf::MessageLite {
 public:
  DhPublicKey();
  virtual ~DhPublicKey();

  DhPublicKey(const DhPublicKey& from);

  inline DhPublicKey& operator=(const DhPublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DhPublicKey& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DhPublicKey* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(DhPublicKey* other);

  // implements Message ----------------------------------------------

  inline DhPublicKey* New() const { return New(NULL); }

  DhPublicKey* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DhPublicKey& from);
  void MergeFrom(const DhPublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DhPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes y = 1;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 1;
  const ::std::string& y() const;
  void set_y(const ::std::string& value);
  void set_y(const char* value);
  void set_y(const void* value, size_t size);
  ::std::string* mutable_y();
  ::std::string* release_y();
  void set_allocated_y(::std::string* y);

  // @@protoc_insertion_point(class_scope:securemessage.DhPublicKey)
 private:
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr y_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_securemessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_securemessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_securemessage_2eproto();
  friend void protobuf_ShutdownFile_securemessage_2eproto();

  void InitAsDefaultInstance();
  static DhPublicKey* default_instance_;
};
// -------------------------------------------------------------------

class GenericPublicKey : public ::google::protobuf::MessageLite {
 public:
  GenericPublicKey();
  virtual ~GenericPublicKey();

  GenericPublicKey(const GenericPublicKey& from);

  inline GenericPublicKey& operator=(const GenericPublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GenericPublicKey& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GenericPublicKey* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(GenericPublicKey* other);

  // implements Message ----------------------------------------------

  inline GenericPublicKey* New() const { return New(NULL); }

  GenericPublicKey* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GenericPublicKey& from);
  void MergeFrom(const GenericPublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GenericPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .securemessage.PublicKeyType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::securemessage::PublicKeyType type() const;
  void set_type(::securemessage::PublicKeyType value);

  // optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;
  bool has_ec_p256_public_key() const;
  void clear_ec_p256_public_key();
  static const int kEcP256PublicKeyFieldNumber = 2;
  const ::securemessage::EcP256PublicKey& ec_p256_public_key() const;
  ::securemessage::EcP256PublicKey* mutable_ec_p256_public_key();
  ::securemessage::EcP256PublicKey* release_ec_p256_public_key();
  void set_allocated_ec_p256_public_key(::securemessage::EcP256PublicKey* ec_p256_public_key);

  // optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;
  bool has_rsa2048_public_key() const;
  void clear_rsa2048_public_key();
  static const int kRsa2048PublicKeyFieldNumber = 3;
  const ::securemessage::SimpleRsaPublicKey& rsa2048_public_key() const;
  ::securemessage::SimpleRsaPublicKey* mutable_rsa2048_public_key();
  ::securemessage::SimpleRsaPublicKey* release_rsa2048_public_key();
  void set_allocated_rsa2048_public_key(::securemessage::SimpleRsaPublicKey* rsa2048_public_key);

  // optional .securemessage.DhPublicKey dh2048_public_key = 4;
  bool has_dh2048_public_key() const;
  void clear_dh2048_public_key();
  static const int kDh2048PublicKeyFieldNumber = 4;
  const ::securemessage::DhPublicKey& dh2048_public_key() const;
  ::securemessage::DhPublicKey* mutable_dh2048_public_key();
  ::securemessage::DhPublicKey* release_dh2048_public_key();
  void set_allocated_dh2048_public_key(::securemessage::DhPublicKey* dh2048_public_key);

  // @@protoc_insertion_point(class_scope:securemessage.GenericPublicKey)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ec_p256_public_key();
  inline void clear_has_ec_p256_public_key();
  inline void set_has_rsa2048_public_key();
  inline void clear_has_rsa2048_public_key();
  inline void set_has_dh2048_public_key();
  inline void clear_has_dh2048_public_key();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::securemessage::EcP256PublicKey* ec_p256_public_key_;
  ::securemessage::SimpleRsaPublicKey* rsa2048_public_key_;
  ::securemessage::DhPublicKey* dh2048_public_key_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_securemessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_securemessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_securemessage_2eproto();
  friend void protobuf_ShutdownFile_securemessage_2eproto();

  void InitAsDefaultInstance();
  static GenericPublicKey* default_instance_;
};
// -------------------------------------------------------------------

class DeviceToDeviceMessage : public ::google::protobuf::MessageLite {
 public:
  DeviceToDeviceMessage();
  virtual ~DeviceToDeviceMessage();

  DeviceToDeviceMessage(const DeviceToDeviceMessage& from);

  inline DeviceToDeviceMessage& operator=(const DeviceToDeviceMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DeviceToDeviceMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeviceToDeviceMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(DeviceToDeviceMessage* other);

  // implements Message ----------------------------------------------

  inline DeviceToDeviceMessage* New() const { return New(NULL); }

  DeviceToDeviceMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeviceToDeviceMessage& from);
  void MergeFrom(const DeviceToDeviceMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeviceToDeviceMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional int32 sequence_number = 2;
  bool has_sequence_number() const;
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 2;
  ::google::protobuf::int32 sequence_number() const;
  void set_sequence_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:securemessage.DeviceToDeviceMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_sequence_number();
  inline void clear_has_sequence_number();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::int32 sequence_number_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_securemessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_securemessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_securemessage_2eproto();
  friend void protobuf_ShutdownFile_securemessage_2eproto();

  void InitAsDefaultInstance();
  static DeviceToDeviceMessage* default_instance_;
};
// -------------------------------------------------------------------

class InitiatorHello : public ::google::protobuf::MessageLite {
 public:
  InitiatorHello();
  virtual ~InitiatorHello();

  InitiatorHello(const InitiatorHello& from);

  inline InitiatorHello& operator=(const InitiatorHello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InitiatorHello& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InitiatorHello* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(InitiatorHello* other);

  // implements Message ----------------------------------------------

  inline InitiatorHello* New() const { return New(NULL); }

  InitiatorHello* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitiatorHello& from);
  void MergeFrom(const InitiatorHello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitiatorHello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .securemessage.GenericPublicKey public_dh_key = 1;
  bool has_public_dh_key() const;
  void clear_public_dh_key();
  static const int kPublicDhKeyFieldNumber = 1;
  const ::securemessage::GenericPublicKey& public_dh_key() const;
  ::securemessage::GenericPublicKey* mutable_public_dh_key();
  ::securemessage::GenericPublicKey* release_public_dh_key();
  void set_allocated_public_dh_key(::securemessage::GenericPublicKey* public_dh_key);

  // @@protoc_insertion_point(class_scope:securemessage.InitiatorHello)
 private:
  inline void set_has_public_dh_key();
  inline void clear_has_public_dh_key();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::securemessage::GenericPublicKey* public_dh_key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_securemessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_securemessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_securemessage_2eproto();
  friend void protobuf_ShutdownFile_securemessage_2eproto();

  void InitAsDefaultInstance();
  static InitiatorHello* default_instance_;
};
// -------------------------------------------------------------------

class ResponderHello : public ::google::protobuf::MessageLite {
 public:
  ResponderHello();
  virtual ~ResponderHello();

  ResponderHello(const ResponderHello& from);

  inline ResponderHello& operator=(const ResponderHello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ResponderHello& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResponderHello* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ResponderHello* other);

  // implements Message ----------------------------------------------

  inline ResponderHello* New() const { return New(NULL); }

  ResponderHello* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResponderHello& from);
  void MergeFrom(const ResponderHello& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResponderHello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .securemessage.GenericPublicKey public_dh_key = 1;
  bool has_public_dh_key() const;
  void clear_public_dh_key();
  static const int kPublicDhKeyFieldNumber = 1;
  const ::securemessage::GenericPublicKey& public_dh_key() const;
  ::securemessage::GenericPublicKey* mutable_public_dh_key();
  ::securemessage::GenericPublicKey* release_public_dh_key();
  void set_allocated_public_dh_key(::securemessage::GenericPublicKey* public_dh_key);

  // @@protoc_insertion_point(class_scope:securemessage.ResponderHello)
 private:
  inline void set_has_public_dh_key();
  inline void clear_has_public_dh_key();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::securemessage::GenericPublicKey* public_dh_key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_securemessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_securemessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_securemessage_2eproto();
  friend void protobuf_ShutdownFile_securemessage_2eproto();

  void InitAsDefaultInstance();
  static ResponderHello* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// SecureMessage

// required bytes header_and_body = 1;
inline bool SecureMessage::has_header_and_body() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecureMessage::set_has_header_and_body() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecureMessage::clear_has_header_and_body() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecureMessage::clear_header_and_body() {
  header_and_body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_header_and_body();
}
inline const ::std::string& SecureMessage::header_and_body() const {
  // @@protoc_insertion_point(field_get:securemessage.SecureMessage.header_and_body)
  return header_and_body_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecureMessage::set_header_and_body(const ::std::string& value) {
  set_has_header_and_body();
  header_and_body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.SecureMessage.header_and_body)
}
inline void SecureMessage::set_header_and_body(const char* value) {
  set_has_header_and_body();
  header_and_body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.SecureMessage.header_and_body)
}
inline void SecureMessage::set_header_and_body(const void* value, size_t size) {
  set_has_header_and_body();
  header_and_body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.SecureMessage.header_and_body)
}
inline ::std::string* SecureMessage::mutable_header_and_body() {
  set_has_header_and_body();
  // @@protoc_insertion_point(field_mutable:securemessage.SecureMessage.header_and_body)
  return header_and_body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecureMessage::release_header_and_body() {
  // @@protoc_insertion_point(field_release:securemessage.SecureMessage.header_and_body)
  clear_has_header_and_body();
  return header_and_body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecureMessage::set_allocated_header_and_body(::std::string* header_and_body) {
  if (header_and_body != NULL) {
    set_has_header_and_body();
  } else {
    clear_has_header_and_body();
  }
  header_and_body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), header_and_body);
  // @@protoc_insertion_point(field_set_allocated:securemessage.SecureMessage.header_and_body)
}

// required bytes signature = 2;
inline bool SecureMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecureMessage::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecureMessage::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecureMessage::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_signature();
}
inline const ::std::string& SecureMessage::signature() const {
  // @@protoc_insertion_point(field_get:securemessage.SecureMessage.signature)
  return signature_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecureMessage::set_signature(const ::std::string& value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.SecureMessage.signature)
}
inline void SecureMessage::set_signature(const char* value) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.SecureMessage.signature)
}
inline void SecureMessage::set_signature(const void* value, size_t size) {
  set_has_signature();
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.SecureMessage.signature)
}
inline ::std::string* SecureMessage::mutable_signature() {
  set_has_signature();
  // @@protoc_insertion_point(field_mutable:securemessage.SecureMessage.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SecureMessage::release_signature() {
  // @@protoc_insertion_point(field_release:securemessage.SecureMessage.signature)
  clear_has_signature();
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SecureMessage::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:securemessage.SecureMessage.signature)
}

// -------------------------------------------------------------------

// Header

// required .securemessage.SigScheme signature_scheme = 1;
inline bool Header::has_signature_scheme() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_signature_scheme() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_signature_scheme() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_signature_scheme() {
  signature_scheme_ = 1;
  clear_has_signature_scheme();
}
inline ::securemessage::SigScheme Header::signature_scheme() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.signature_scheme)
  return static_cast< ::securemessage::SigScheme >(signature_scheme_);
}
inline void Header::set_signature_scheme(::securemessage::SigScheme value) {
  assert(::securemessage::SigScheme_IsValid(value));
  set_has_signature_scheme();
  signature_scheme_ = value;
  // @@protoc_insertion_point(field_set:securemessage.Header.signature_scheme)
}

// required .securemessage.EncScheme encryption_scheme = 2;
inline bool Header::has_encryption_scheme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_encryption_scheme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_encryption_scheme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_encryption_scheme() {
  encryption_scheme_ = 1;
  clear_has_encryption_scheme();
}
inline ::securemessage::EncScheme Header::encryption_scheme() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.encryption_scheme)
  return static_cast< ::securemessage::EncScheme >(encryption_scheme_);
}
inline void Header::set_encryption_scheme(::securemessage::EncScheme value) {
  assert(::securemessage::EncScheme_IsValid(value));
  set_has_encryption_scheme();
  encryption_scheme_ = value;
  // @@protoc_insertion_point(field_set:securemessage.Header.encryption_scheme)
}

// optional bytes verification_key_id = 3;
inline bool Header::has_verification_key_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_verification_key_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_verification_key_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_verification_key_id() {
  verification_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_verification_key_id();
}
inline const ::std::string& Header::verification_key_id() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.verification_key_id)
  return verification_key_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_verification_key_id(const ::std::string& value) {
  set_has_verification_key_id();
  verification_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.Header.verification_key_id)
}
inline void Header::set_verification_key_id(const char* value) {
  set_has_verification_key_id();
  verification_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.Header.verification_key_id)
}
inline void Header::set_verification_key_id(const void* value, size_t size) {
  set_has_verification_key_id();
  verification_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.Header.verification_key_id)
}
inline ::std::string* Header::mutable_verification_key_id() {
  set_has_verification_key_id();
  // @@protoc_insertion_point(field_mutable:securemessage.Header.verification_key_id)
  return verification_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_verification_key_id() {
  // @@protoc_insertion_point(field_release:securemessage.Header.verification_key_id)
  clear_has_verification_key_id();
  return verification_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_verification_key_id(::std::string* verification_key_id) {
  if (verification_key_id != NULL) {
    set_has_verification_key_id();
  } else {
    clear_has_verification_key_id();
  }
  verification_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verification_key_id);
  // @@protoc_insertion_point(field_set_allocated:securemessage.Header.verification_key_id)
}

// optional bytes decryption_key_id = 4;
inline bool Header::has_decryption_key_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_decryption_key_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_decryption_key_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_decryption_key_id() {
  decryption_key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_decryption_key_id();
}
inline const ::std::string& Header::decryption_key_id() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.decryption_key_id)
  return decryption_key_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_decryption_key_id(const ::std::string& value) {
  set_has_decryption_key_id();
  decryption_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.Header.decryption_key_id)
}
inline void Header::set_decryption_key_id(const char* value) {
  set_has_decryption_key_id();
  decryption_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.Header.decryption_key_id)
}
inline void Header::set_decryption_key_id(const void* value, size_t size) {
  set_has_decryption_key_id();
  decryption_key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.Header.decryption_key_id)
}
inline ::std::string* Header::mutable_decryption_key_id() {
  set_has_decryption_key_id();
  // @@protoc_insertion_point(field_mutable:securemessage.Header.decryption_key_id)
  return decryption_key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_decryption_key_id() {
  // @@protoc_insertion_point(field_release:securemessage.Header.decryption_key_id)
  clear_has_decryption_key_id();
  return decryption_key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_decryption_key_id(::std::string* decryption_key_id) {
  if (decryption_key_id != NULL) {
    set_has_decryption_key_id();
  } else {
    clear_has_decryption_key_id();
  }
  decryption_key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), decryption_key_id);
  // @@protoc_insertion_point(field_set_allocated:securemessage.Header.decryption_key_id)
}

// optional bytes iv = 5;
inline bool Header::has_iv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_iv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_iv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_iv();
}
inline const ::std::string& Header::iv() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.iv)
  return iv_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_iv(const ::std::string& value) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.Header.iv)
}
inline void Header::set_iv(const char* value) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.Header.iv)
}
inline void Header::set_iv(const void* value, size_t size) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.Header.iv)
}
inline ::std::string* Header::mutable_iv() {
  set_has_iv();
  // @@protoc_insertion_point(field_mutable:securemessage.Header.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_iv() {
  // @@protoc_insertion_point(field_release:securemessage.Header.iv)
  clear_has_iv();
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    set_has_iv();
  } else {
    clear_has_iv();
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:securemessage.Header.iv)
}

// optional bytes public_metadata = 6;
inline bool Header::has_public_metadata() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Header::set_has_public_metadata() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Header::clear_has_public_metadata() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Header::clear_public_metadata() {
  public_metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_metadata();
}
inline const ::std::string& Header::public_metadata() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.public_metadata)
  return public_metadata_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_public_metadata(const ::std::string& value) {
  set_has_public_metadata();
  public_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.Header.public_metadata)
}
inline void Header::set_public_metadata(const char* value) {
  set_has_public_metadata();
  public_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.Header.public_metadata)
}
inline void Header::set_public_metadata(const void* value, size_t size) {
  set_has_public_metadata();
  public_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.Header.public_metadata)
}
inline ::std::string* Header::mutable_public_metadata() {
  set_has_public_metadata();
  // @@protoc_insertion_point(field_mutable:securemessage.Header.public_metadata)
  return public_metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_public_metadata() {
  // @@protoc_insertion_point(field_release:securemessage.Header.public_metadata)
  clear_has_public_metadata();
  return public_metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_public_metadata(::std::string* public_metadata) {
  if (public_metadata != NULL) {
    set_has_public_metadata();
  } else {
    clear_has_public_metadata();
  }
  public_metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_metadata);
  // @@protoc_insertion_point(field_set_allocated:securemessage.Header.public_metadata)
}

// optional uint32 associated_data_length = 7 [default = 0];
inline bool Header::has_associated_data_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Header::set_has_associated_data_length() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Header::clear_has_associated_data_length() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Header::clear_associated_data_length() {
  associated_data_length_ = 0u;
  clear_has_associated_data_length();
}
inline ::google::protobuf::uint32 Header::associated_data_length() const {
  // @@protoc_insertion_point(field_get:securemessage.Header.associated_data_length)
  return associated_data_length_;
}
inline void Header::set_associated_data_length(::google::protobuf::uint32 value) {
  set_has_associated_data_length();
  associated_data_length_ = value;
  // @@protoc_insertion_point(field_set:securemessage.Header.associated_data_length)
}

// -------------------------------------------------------------------

// HeaderAndBody

// required .securemessage.Header header = 1;
inline bool HeaderAndBody::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeaderAndBody::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeaderAndBody::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeaderAndBody::clear_header() {
  if (header_ != NULL) header_->::securemessage::Header::Clear();
  clear_has_header();
}
inline const ::securemessage::Header& HeaderAndBody::header() const {
  // @@protoc_insertion_point(field_get:securemessage.HeaderAndBody.header)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return header_ != NULL ? *header_ : *default_instance().header_;
#else
  return header_ != NULL ? *header_ : *default_instance_->header_;
#endif
}
inline ::securemessage::Header* HeaderAndBody::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::securemessage::Header;
  }
  // @@protoc_insertion_point(field_mutable:securemessage.HeaderAndBody.header)
  return header_;
}
inline ::securemessage::Header* HeaderAndBody::release_header() {
  // @@protoc_insertion_point(field_release:securemessage.HeaderAndBody.header)
  clear_has_header();
  ::securemessage::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void HeaderAndBody::set_allocated_header(::securemessage::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:securemessage.HeaderAndBody.header)
}

// required bytes body = 2;
inline bool HeaderAndBody::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeaderAndBody::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeaderAndBody::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeaderAndBody::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_body();
}
inline const ::std::string& HeaderAndBody::body() const {
  // @@protoc_insertion_point(field_get:securemessage.HeaderAndBody.body)
  return body_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeaderAndBody::set_body(const ::std::string& value) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.HeaderAndBody.body)
}
inline void HeaderAndBody::set_body(const char* value) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.HeaderAndBody.body)
}
inline void HeaderAndBody::set_body(const void* value, size_t size) {
  set_has_body();
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.HeaderAndBody.body)
}
inline ::std::string* HeaderAndBody::mutable_body() {
  set_has_body();
  // @@protoc_insertion_point(field_mutable:securemessage.HeaderAndBody.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeaderAndBody::release_body() {
  // @@protoc_insertion_point(field_release:securemessage.HeaderAndBody.body)
  clear_has_body();
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeaderAndBody::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    set_has_body();
  } else {
    clear_has_body();
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:securemessage.HeaderAndBody.body)
}

// -------------------------------------------------------------------

// EcP256PublicKey

// required bytes x = 1;
inline bool EcP256PublicKey::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EcP256PublicKey::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EcP256PublicKey::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EcP256PublicKey::clear_x() {
  x_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_x();
}
inline const ::std::string& EcP256PublicKey::x() const {
  // @@protoc_insertion_point(field_get:securemessage.EcP256PublicKey.x)
  return x_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EcP256PublicKey::set_x(const ::std::string& value) {
  set_has_x();
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.EcP256PublicKey.x)
}
inline void EcP256PublicKey::set_x(const char* value) {
  set_has_x();
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.EcP256PublicKey.x)
}
inline void EcP256PublicKey::set_x(const void* value, size_t size) {
  set_has_x();
  x_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.EcP256PublicKey.x)
}
inline ::std::string* EcP256PublicKey::mutable_x() {
  set_has_x();
  // @@protoc_insertion_point(field_mutable:securemessage.EcP256PublicKey.x)
  return x_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EcP256PublicKey::release_x() {
  // @@protoc_insertion_point(field_release:securemessage.EcP256PublicKey.x)
  clear_has_x();
  return x_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EcP256PublicKey::set_allocated_x(::std::string* x) {
  if (x != NULL) {
    set_has_x();
  } else {
    clear_has_x();
  }
  x_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), x);
  // @@protoc_insertion_point(field_set_allocated:securemessage.EcP256PublicKey.x)
}

// required bytes y = 2;
inline bool EcP256PublicKey::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EcP256PublicKey::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EcP256PublicKey::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EcP256PublicKey::clear_y() {
  y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_y();
}
inline const ::std::string& EcP256PublicKey::y() const {
  // @@protoc_insertion_point(field_get:securemessage.EcP256PublicKey.y)
  return y_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EcP256PublicKey::set_y(const ::std::string& value) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.EcP256PublicKey.y)
}
inline void EcP256PublicKey::set_y(const char* value) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.EcP256PublicKey.y)
}
inline void EcP256PublicKey::set_y(const void* value, size_t size) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.EcP256PublicKey.y)
}
inline ::std::string* EcP256PublicKey::mutable_y() {
  set_has_y();
  // @@protoc_insertion_point(field_mutable:securemessage.EcP256PublicKey.y)
  return y_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EcP256PublicKey::release_y() {
  // @@protoc_insertion_point(field_release:securemessage.EcP256PublicKey.y)
  clear_has_y();
  return y_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EcP256PublicKey::set_allocated_y(::std::string* y) {
  if (y != NULL) {
    set_has_y();
  } else {
    clear_has_y();
  }
  y_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:securemessage.EcP256PublicKey.y)
}

// -------------------------------------------------------------------

// SimpleRsaPublicKey

// required bytes n = 1;
inline bool SimpleRsaPublicKey::has_n() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimpleRsaPublicKey::set_has_n() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimpleRsaPublicKey::clear_has_n() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimpleRsaPublicKey::clear_n() {
  n_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_n();
}
inline const ::std::string& SimpleRsaPublicKey::n() const {
  // @@protoc_insertion_point(field_get:securemessage.SimpleRsaPublicKey.n)
  return n_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleRsaPublicKey::set_n(const ::std::string& value) {
  set_has_n();
  n_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.SimpleRsaPublicKey.n)
}
inline void SimpleRsaPublicKey::set_n(const char* value) {
  set_has_n();
  n_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.SimpleRsaPublicKey.n)
}
inline void SimpleRsaPublicKey::set_n(const void* value, size_t size) {
  set_has_n();
  n_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.SimpleRsaPublicKey.n)
}
inline ::std::string* SimpleRsaPublicKey::mutable_n() {
  set_has_n();
  // @@protoc_insertion_point(field_mutable:securemessage.SimpleRsaPublicKey.n)
  return n_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SimpleRsaPublicKey::release_n() {
  // @@protoc_insertion_point(field_release:securemessage.SimpleRsaPublicKey.n)
  clear_has_n();
  return n_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SimpleRsaPublicKey::set_allocated_n(::std::string* n) {
  if (n != NULL) {
    set_has_n();
  } else {
    clear_has_n();
  }
  n_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), n);
  // @@protoc_insertion_point(field_set_allocated:securemessage.SimpleRsaPublicKey.n)
}

// optional int32 e = 2 [default = 65537];
inline bool SimpleRsaPublicKey::has_e() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimpleRsaPublicKey::set_has_e() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimpleRsaPublicKey::clear_has_e() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimpleRsaPublicKey::clear_e() {
  e_ = 65537;
  clear_has_e();
}
inline ::google::protobuf::int32 SimpleRsaPublicKey::e() const {
  // @@protoc_insertion_point(field_get:securemessage.SimpleRsaPublicKey.e)
  return e_;
}
inline void SimpleRsaPublicKey::set_e(::google::protobuf::int32 value) {
  set_has_e();
  e_ = value;
  // @@protoc_insertion_point(field_set:securemessage.SimpleRsaPublicKey.e)
}

// -------------------------------------------------------------------

// DhPublicKey

// required bytes y = 1;
inline bool DhPublicKey::has_y() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DhPublicKey::set_has_y() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DhPublicKey::clear_has_y() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DhPublicKey::clear_y() {
  y_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_y();
}
inline const ::std::string& DhPublicKey::y() const {
  // @@protoc_insertion_point(field_get:securemessage.DhPublicKey.y)
  return y_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DhPublicKey::set_y(const ::std::string& value) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.DhPublicKey.y)
}
inline void DhPublicKey::set_y(const char* value) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.DhPublicKey.y)
}
inline void DhPublicKey::set_y(const void* value, size_t size) {
  set_has_y();
  y_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.DhPublicKey.y)
}
inline ::std::string* DhPublicKey::mutable_y() {
  set_has_y();
  // @@protoc_insertion_point(field_mutable:securemessage.DhPublicKey.y)
  return y_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DhPublicKey::release_y() {
  // @@protoc_insertion_point(field_release:securemessage.DhPublicKey.y)
  clear_has_y();
  return y_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DhPublicKey::set_allocated_y(::std::string* y) {
  if (y != NULL) {
    set_has_y();
  } else {
    clear_has_y();
  }
  y_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), y);
  // @@protoc_insertion_point(field_set_allocated:securemessage.DhPublicKey.y)
}

// -------------------------------------------------------------------

// GenericPublicKey

// required .securemessage.PublicKeyType type = 1;
inline bool GenericPublicKey::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GenericPublicKey::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GenericPublicKey::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GenericPublicKey::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::securemessage::PublicKeyType GenericPublicKey::type() const {
  // @@protoc_insertion_point(field_get:securemessage.GenericPublicKey.type)
  return static_cast< ::securemessage::PublicKeyType >(type_);
}
inline void GenericPublicKey::set_type(::securemessage::PublicKeyType value) {
  assert(::securemessage::PublicKeyType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:securemessage.GenericPublicKey.type)
}

// optional .securemessage.EcP256PublicKey ec_p256_public_key = 2;
inline bool GenericPublicKey::has_ec_p256_public_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GenericPublicKey::set_has_ec_p256_public_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GenericPublicKey::clear_has_ec_p256_public_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GenericPublicKey::clear_ec_p256_public_key() {
  if (ec_p256_public_key_ != NULL) ec_p256_public_key_->::securemessage::EcP256PublicKey::Clear();
  clear_has_ec_p256_public_key();
}
inline const ::securemessage::EcP256PublicKey& GenericPublicKey::ec_p256_public_key() const {
  // @@protoc_insertion_point(field_get:securemessage.GenericPublicKey.ec_p256_public_key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ec_p256_public_key_ != NULL ? *ec_p256_public_key_ : *default_instance().ec_p256_public_key_;
#else
  return ec_p256_public_key_ != NULL ? *ec_p256_public_key_ : *default_instance_->ec_p256_public_key_;
#endif
}
inline ::securemessage::EcP256PublicKey* GenericPublicKey::mutable_ec_p256_public_key() {
  set_has_ec_p256_public_key();
  if (ec_p256_public_key_ == NULL) {
    ec_p256_public_key_ = new ::securemessage::EcP256PublicKey;
  }
  // @@protoc_insertion_point(field_mutable:securemessage.GenericPublicKey.ec_p256_public_key)
  return ec_p256_public_key_;
}
inline ::securemessage::EcP256PublicKey* GenericPublicKey::release_ec_p256_public_key() {
  // @@protoc_insertion_point(field_release:securemessage.GenericPublicKey.ec_p256_public_key)
  clear_has_ec_p256_public_key();
  ::securemessage::EcP256PublicKey* temp = ec_p256_public_key_;
  ec_p256_public_key_ = NULL;
  return temp;
}
inline void GenericPublicKey::set_allocated_ec_p256_public_key(::securemessage::EcP256PublicKey* ec_p256_public_key) {
  delete ec_p256_public_key_;
  ec_p256_public_key_ = ec_p256_public_key;
  if (ec_p256_public_key) {
    set_has_ec_p256_public_key();
  } else {
    clear_has_ec_p256_public_key();
  }
  // @@protoc_insertion_point(field_set_allocated:securemessage.GenericPublicKey.ec_p256_public_key)
}

// optional .securemessage.SimpleRsaPublicKey rsa2048_public_key = 3;
inline bool GenericPublicKey::has_rsa2048_public_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GenericPublicKey::set_has_rsa2048_public_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GenericPublicKey::clear_has_rsa2048_public_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GenericPublicKey::clear_rsa2048_public_key() {
  if (rsa2048_public_key_ != NULL) rsa2048_public_key_->::securemessage::SimpleRsaPublicKey::Clear();
  clear_has_rsa2048_public_key();
}
inline const ::securemessage::SimpleRsaPublicKey& GenericPublicKey::rsa2048_public_key() const {
  // @@protoc_insertion_point(field_get:securemessage.GenericPublicKey.rsa2048_public_key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rsa2048_public_key_ != NULL ? *rsa2048_public_key_ : *default_instance().rsa2048_public_key_;
#else
  return rsa2048_public_key_ != NULL ? *rsa2048_public_key_ : *default_instance_->rsa2048_public_key_;
#endif
}
inline ::securemessage::SimpleRsaPublicKey* GenericPublicKey::mutable_rsa2048_public_key() {
  set_has_rsa2048_public_key();
  if (rsa2048_public_key_ == NULL) {
    rsa2048_public_key_ = new ::securemessage::SimpleRsaPublicKey;
  }
  // @@protoc_insertion_point(field_mutable:securemessage.GenericPublicKey.rsa2048_public_key)
  return rsa2048_public_key_;
}
inline ::securemessage::SimpleRsaPublicKey* GenericPublicKey::release_rsa2048_public_key() {
  // @@protoc_insertion_point(field_release:securemessage.GenericPublicKey.rsa2048_public_key)
  clear_has_rsa2048_public_key();
  ::securemessage::SimpleRsaPublicKey* temp = rsa2048_public_key_;
  rsa2048_public_key_ = NULL;
  return temp;
}
inline void GenericPublicKey::set_allocated_rsa2048_public_key(::securemessage::SimpleRsaPublicKey* rsa2048_public_key) {
  delete rsa2048_public_key_;
  rsa2048_public_key_ = rsa2048_public_key;
  if (rsa2048_public_key) {
    set_has_rsa2048_public_key();
  } else {
    clear_has_rsa2048_public_key();
  }
  // @@protoc_insertion_point(field_set_allocated:securemessage.GenericPublicKey.rsa2048_public_key)
}

// optional .securemessage.DhPublicKey dh2048_public_key = 4;
inline bool GenericPublicKey::has_dh2048_public_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GenericPublicKey::set_has_dh2048_public_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GenericPublicKey::clear_has_dh2048_public_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GenericPublicKey::clear_dh2048_public_key() {
  if (dh2048_public_key_ != NULL) dh2048_public_key_->::securemessage::DhPublicKey::Clear();
  clear_has_dh2048_public_key();
}
inline const ::securemessage::DhPublicKey& GenericPublicKey::dh2048_public_key() const {
  // @@protoc_insertion_point(field_get:securemessage.GenericPublicKey.dh2048_public_key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dh2048_public_key_ != NULL ? *dh2048_public_key_ : *default_instance().dh2048_public_key_;
#else
  return dh2048_public_key_ != NULL ? *dh2048_public_key_ : *default_instance_->dh2048_public_key_;
#endif
}
inline ::securemessage::DhPublicKey* GenericPublicKey::mutable_dh2048_public_key() {
  set_has_dh2048_public_key();
  if (dh2048_public_key_ == NULL) {
    dh2048_public_key_ = new ::securemessage::DhPublicKey;
  }
  // @@protoc_insertion_point(field_mutable:securemessage.GenericPublicKey.dh2048_public_key)
  return dh2048_public_key_;
}
inline ::securemessage::DhPublicKey* GenericPublicKey::release_dh2048_public_key() {
  // @@protoc_insertion_point(field_release:securemessage.GenericPublicKey.dh2048_public_key)
  clear_has_dh2048_public_key();
  ::securemessage::DhPublicKey* temp = dh2048_public_key_;
  dh2048_public_key_ = NULL;
  return temp;
}
inline void GenericPublicKey::set_allocated_dh2048_public_key(::securemessage::DhPublicKey* dh2048_public_key) {
  delete dh2048_public_key_;
  dh2048_public_key_ = dh2048_public_key;
  if (dh2048_public_key) {
    set_has_dh2048_public_key();
  } else {
    clear_has_dh2048_public_key();
  }
  // @@protoc_insertion_point(field_set_allocated:securemessage.GenericPublicKey.dh2048_public_key)
}

// -------------------------------------------------------------------

// DeviceToDeviceMessage

// optional bytes message = 1;
inline bool DeviceToDeviceMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceToDeviceMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceToDeviceMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceToDeviceMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& DeviceToDeviceMessage::message() const {
  // @@protoc_insertion_point(field_get:securemessage.DeviceToDeviceMessage.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceToDeviceMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:securemessage.DeviceToDeviceMessage.message)
}
inline void DeviceToDeviceMessage::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:securemessage.DeviceToDeviceMessage.message)
}
inline void DeviceToDeviceMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:securemessage.DeviceToDeviceMessage.message)
}
inline ::std::string* DeviceToDeviceMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:securemessage.DeviceToDeviceMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeviceToDeviceMessage::release_message() {
  // @@protoc_insertion_point(field_release:securemessage.DeviceToDeviceMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeviceToDeviceMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:securemessage.DeviceToDeviceMessage.message)
}

// optional int32 sequence_number = 2;
inline bool DeviceToDeviceMessage::has_sequence_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceToDeviceMessage::set_has_sequence_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceToDeviceMessage::clear_has_sequence_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceToDeviceMessage::clear_sequence_number() {
  sequence_number_ = 0;
  clear_has_sequence_number();
}
inline ::google::protobuf::int32 DeviceToDeviceMessage::sequence_number() const {
  // @@protoc_insertion_point(field_get:securemessage.DeviceToDeviceMessage.sequence_number)
  return sequence_number_;
}
inline void DeviceToDeviceMessage::set_sequence_number(::google::protobuf::int32 value) {
  set_has_sequence_number();
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:securemessage.DeviceToDeviceMessage.sequence_number)
}

// -------------------------------------------------------------------

// InitiatorHello

// optional .securemessage.GenericPublicKey public_dh_key = 1;
inline bool InitiatorHello::has_public_dh_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitiatorHello::set_has_public_dh_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitiatorHello::clear_has_public_dh_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitiatorHello::clear_public_dh_key() {
  if (public_dh_key_ != NULL) public_dh_key_->::securemessage::GenericPublicKey::Clear();
  clear_has_public_dh_key();
}
inline const ::securemessage::GenericPublicKey& InitiatorHello::public_dh_key() const {
  // @@protoc_insertion_point(field_get:securemessage.InitiatorHello.public_dh_key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return public_dh_key_ != NULL ? *public_dh_key_ : *default_instance().public_dh_key_;
#else
  return public_dh_key_ != NULL ? *public_dh_key_ : *default_instance_->public_dh_key_;
#endif
}
inline ::securemessage::GenericPublicKey* InitiatorHello::mutable_public_dh_key() {
  set_has_public_dh_key();
  if (public_dh_key_ == NULL) {
    public_dh_key_ = new ::securemessage::GenericPublicKey;
  }
  // @@protoc_insertion_point(field_mutable:securemessage.InitiatorHello.public_dh_key)
  return public_dh_key_;
}
inline ::securemessage::GenericPublicKey* InitiatorHello::release_public_dh_key() {
  // @@protoc_insertion_point(field_release:securemessage.InitiatorHello.public_dh_key)
  clear_has_public_dh_key();
  ::securemessage::GenericPublicKey* temp = public_dh_key_;
  public_dh_key_ = NULL;
  return temp;
}
inline void InitiatorHello::set_allocated_public_dh_key(::securemessage::GenericPublicKey* public_dh_key) {
  delete public_dh_key_;
  public_dh_key_ = public_dh_key;
  if (public_dh_key) {
    set_has_public_dh_key();
  } else {
    clear_has_public_dh_key();
  }
  // @@protoc_insertion_point(field_set_allocated:securemessage.InitiatorHello.public_dh_key)
}

// -------------------------------------------------------------------

// ResponderHello

// optional .securemessage.GenericPublicKey public_dh_key = 1;
inline bool ResponderHello::has_public_dh_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponderHello::set_has_public_dh_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponderHello::clear_has_public_dh_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponderHello::clear_public_dh_key() {
  if (public_dh_key_ != NULL) public_dh_key_->::securemessage::GenericPublicKey::Clear();
  clear_has_public_dh_key();
}
inline const ::securemessage::GenericPublicKey& ResponderHello::public_dh_key() const {
  // @@protoc_insertion_point(field_get:securemessage.ResponderHello.public_dh_key)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return public_dh_key_ != NULL ? *public_dh_key_ : *default_instance().public_dh_key_;
#else
  return public_dh_key_ != NULL ? *public_dh_key_ : *default_instance_->public_dh_key_;
#endif
}
inline ::securemessage::GenericPublicKey* ResponderHello::mutable_public_dh_key() {
  set_has_public_dh_key();
  if (public_dh_key_ == NULL) {
    public_dh_key_ = new ::securemessage::GenericPublicKey;
  }
  // @@protoc_insertion_point(field_mutable:securemessage.ResponderHello.public_dh_key)
  return public_dh_key_;
}
inline ::securemessage::GenericPublicKey* ResponderHello::release_public_dh_key() {
  // @@protoc_insertion_point(field_release:securemessage.ResponderHello.public_dh_key)
  clear_has_public_dh_key();
  ::securemessage::GenericPublicKey* temp = public_dh_key_;
  public_dh_key_ = NULL;
  return temp;
}
inline void ResponderHello::set_allocated_public_dh_key(::securemessage::GenericPublicKey* public_dh_key) {
  delete public_dh_key_;
  public_dh_key_ = public_dh_key;
  if (public_dh_key) {
    set_has_public_dh_key();
  } else {
    clear_has_public_dh_key();
  }
  // @@protoc_insertion_point(field_set_allocated:securemessage.ResponderHello.public_dh_key)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace securemessage

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::securemessage::SigScheme> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::securemessage::EncScheme> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::securemessage::PublicKeyType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_securemessage_2eproto__INCLUDED
