// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: extension.proto

#ifndef PROTOBUF_extension_2eproto__INCLUDED
#define PROTOBUF_extension_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "common.pb.h"
#include "chrome.pb.h"
#include "dom.pb.h"
#include "math.pb.h"
#include "web.pb.h"
// @@protoc_insertion_point(includes)

namespace userfeedback {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_extension_2eproto();
void protobuf_AssignDesc_extension_2eproto();
void protobuf_ShutdownFile_extension_2eproto();

class ExtensionErrors;
class ExtensionPageRequestParams;
class ExtensionSubmit;
class PostedScreenshot;
class SuggestQuery;

// ===================================================================

class ExtensionPageRequestParams : public ::google::protobuf::MessageLite {
 public:
  ExtensionPageRequestParams();
  virtual ~ExtensionPageRequestParams();

  ExtensionPageRequestParams(const ExtensionPageRequestParams& from);

  inline ExtensionPageRequestParams& operator=(const ExtensionPageRequestParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ExtensionPageRequestParams& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExtensionPageRequestParams* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ExtensionPageRequestParams* other);

  // implements Message ----------------------------------------------

  inline ExtensionPageRequestParams* New() const { return New(NULL); }

  ExtensionPageRequestParams* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExtensionPageRequestParams& from);
  void MergeFrom(const ExtensionPageRequestParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionPageRequestParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .userfeedback.ExtensionDetails extension_details = 1;
  bool has_extension_details() const;
  void clear_extension_details();
  static const int kExtensionDetailsFieldNumber = 1;
  const ::userfeedback::ExtensionDetails& extension_details() const;
  ::userfeedback::ExtensionDetails* mutable_extension_details();
  ::userfeedback::ExtensionDetails* release_extension_details();
  void set_allocated_extension_details(::userfeedback::ExtensionDetails* extension_details);

  // required string url = 2;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 2;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:userfeedback.ExtensionPageRequestParams)
 private:
  inline void set_has_extension_details();
  inline void clear_has_extension_details();
  inline void set_has_url();
  inline void clear_has_url();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::userfeedback::ExtensionDetails* extension_details_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_extension_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_extension_2eproto();
  #endif
  friend void protobuf_AssignDesc_extension_2eproto();
  friend void protobuf_ShutdownFile_extension_2eproto();

  void InitAsDefaultInstance();
  static ExtensionPageRequestParams* default_instance_;
};
// -------------------------------------------------------------------

class PostedScreenshot : public ::google::protobuf::MessageLite {
 public:
  PostedScreenshot();
  virtual ~PostedScreenshot();

  PostedScreenshot(const PostedScreenshot& from);

  inline PostedScreenshot& operator=(const PostedScreenshot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PostedScreenshot& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PostedScreenshot* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(PostedScreenshot* other);

  // implements Message ----------------------------------------------

  inline PostedScreenshot* New() const { return New(NULL); }

  PostedScreenshot* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PostedScreenshot& from);
  void MergeFrom(const PostedScreenshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PostedScreenshot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mime_type = 1;
  bool has_mime_type() const;
  void clear_mime_type();
  static const int kMimeTypeFieldNumber = 1;
  const ::std::string& mime_type() const;
  void set_mime_type(const ::std::string& value);
  void set_mime_type(const char* value);
  void set_mime_type(const char* value, size_t size);
  ::std::string* mutable_mime_type();
  ::std::string* release_mime_type();
  void set_allocated_mime_type(::std::string* mime_type);

  // required .userfeedback.Dimensions dimensions = 2;
  bool has_dimensions() const;
  void clear_dimensions();
  static const int kDimensionsFieldNumber = 2;
  const ::userfeedback::Dimensions& dimensions() const;
  ::userfeedback::Dimensions* mutable_dimensions();
  ::userfeedback::Dimensions* release_dimensions();
  void set_allocated_dimensions(::userfeedback::Dimensions* dimensions);

  // optional string base64_content = 3;
  bool has_base64_content() const;
  void clear_base64_content();
  static const int kBase64ContentFieldNumber = 3;
  const ::std::string& base64_content() const;
  void set_base64_content(const ::std::string& value);
  void set_base64_content(const char* value);
  void set_base64_content(const char* value, size_t size);
  ::std::string* mutable_base64_content();
  ::std::string* release_base64_content();
  void set_allocated_base64_content(::std::string* base64_content);

  // optional bytes binary_content = 4;
  bool has_binary_content() const;
  void clear_binary_content();
  static const int kBinaryContentFieldNumber = 4;
  const ::std::string& binary_content() const;
  void set_binary_content(const ::std::string& value);
  void set_binary_content(const char* value);
  void set_binary_content(const void* value, size_t size);
  ::std::string* mutable_binary_content();
  ::std::string* release_binary_content();
  void set_allocated_binary_content(::std::string* binary_content);

  // @@protoc_insertion_point(class_scope:userfeedback.PostedScreenshot)
 private:
  inline void set_has_mime_type();
  inline void clear_has_mime_type();
  inline void set_has_dimensions();
  inline void clear_has_dimensions();
  inline void set_has_base64_content();
  inline void clear_has_base64_content();
  inline void set_has_binary_content();
  inline void clear_has_binary_content();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr mime_type_;
  ::userfeedback::Dimensions* dimensions_;
  ::google::protobuf::internal::ArenaStringPtr base64_content_;
  ::google::protobuf::internal::ArenaStringPtr binary_content_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_extension_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_extension_2eproto();
  #endif
  friend void protobuf_AssignDesc_extension_2eproto();
  friend void protobuf_ShutdownFile_extension_2eproto();

  void InitAsDefaultInstance();
  static PostedScreenshot* default_instance_;
};
// -------------------------------------------------------------------

class ExtensionErrors : public ::google::protobuf::MessageLite {
 public:
  ExtensionErrors();
  virtual ~ExtensionErrors();

  ExtensionErrors(const ExtensionErrors& from);

  inline ExtensionErrors& operator=(const ExtensionErrors& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ExtensionErrors& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExtensionErrors* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ExtensionErrors* other);

  // implements Message ----------------------------------------------

  inline ExtensionErrors* New() const { return New(NULL); }

  ExtensionErrors* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExtensionErrors& from);
  void MergeFrom(const ExtensionErrors& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionErrors* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 number_of_attempts = 1;
  bool has_number_of_attempts() const;
  void clear_number_of_attempts();
  static const int kNumberOfAttemptsFieldNumber = 1;
  ::google::protobuf::int32 number_of_attempts() const;
  void set_number_of_attempts(::google::protobuf::int32 value);

  // required string errors = 2;
  bool has_errors() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 2;
  const ::std::string& errors() const;
  void set_errors(const ::std::string& value);
  void set_errors(const char* value);
  void set_errors(const char* value, size_t size);
  ::std::string* mutable_errors();
  ::std::string* release_errors();
  void set_allocated_errors(::std::string* errors);

  // @@protoc_insertion_point(class_scope:userfeedback.ExtensionErrors)
 private:
  inline void set_has_number_of_attempts();
  inline void clear_has_number_of_attempts();
  inline void set_has_errors();
  inline void clear_has_errors();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errors_;
  ::google::protobuf::int32 number_of_attempts_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_extension_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_extension_2eproto();
  #endif
  friend void protobuf_AssignDesc_extension_2eproto();
  friend void protobuf_ShutdownFile_extension_2eproto();

  void InitAsDefaultInstance();
  static ExtensionErrors* default_instance_;
};
// -------------------------------------------------------------------

class ExtensionSubmit : public ::google::protobuf::MessageLite {
 public:
  ExtensionSubmit();
  virtual ~ExtensionSubmit();

  ExtensionSubmit(const ExtensionSubmit& from);

  inline ExtensionSubmit& operator=(const ExtensionSubmit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ExtensionSubmit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExtensionSubmit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(ExtensionSubmit* other);

  // implements Message ----------------------------------------------

  inline ExtensionSubmit* New() const { return New(NULL); }

  ExtensionSubmit* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExtensionSubmit& from);
  void MergeFrom(const ExtensionSubmit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ExtensionSubmit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .userfeedback.CommonData common_data = 1;
  bool has_common_data() const;
  void clear_common_data();
  static const int kCommonDataFieldNumber = 1;
  const ::userfeedback::CommonData& common_data() const;
  ::userfeedback::CommonData* mutable_common_data();
  ::userfeedback::CommonData* release_common_data();
  void set_allocated_common_data(::userfeedback::CommonData* common_data);

  // required .userfeedback.WebData web_data = 2;
  bool has_web_data() const;
  void clear_web_data();
  static const int kWebDataFieldNumber = 2;
  const ::userfeedback::WebData& web_data() const;
  ::userfeedback::WebData* mutable_web_data();
  ::userfeedback::WebData* release_web_data();
  void set_allocated_web_data(::userfeedback::WebData* web_data);

  // required int32 type_id = 3;
  bool has_type_id() const;
  void clear_type_id();
  static const int kTypeIdFieldNumber = 3;
  ::google::protobuf::int32 type_id() const;
  void set_type_id(::google::protobuf::int32 value);

  // optional .userfeedback.PostedScreenshot screenshot = 4;
  bool has_screenshot() const;
  void clear_screenshot();
  static const int kScreenshotFieldNumber = 4;
  const ::userfeedback::PostedScreenshot& screenshot() const;
  ::userfeedback::PostedScreenshot* mutable_screenshot();
  ::userfeedback::PostedScreenshot* release_screenshot();
  void set_allocated_screenshot(::userfeedback::PostedScreenshot* screenshot);

  // optional .userfeedback.ChromeData chrome_data = 14;
  bool has_chrome_data() const;
  void clear_chrome_data();
  static const int kChromeDataFieldNumber = 14;
  const ::userfeedback::ChromeData& chrome_data() const;
  ::userfeedback::ChromeData* mutable_chrome_data();
  ::userfeedback::ChromeData* release_chrome_data();
  void set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data);

  // repeated .userfeedback.ProductSpecificBinaryData product_specific_binary_data = 15;
  int product_specific_binary_data_size() const;
  void clear_product_specific_binary_data();
  static const int kProductSpecificBinaryDataFieldNumber = 15;
  const ::userfeedback::ProductSpecificBinaryData& product_specific_binary_data(int index) const;
  ::userfeedback::ProductSpecificBinaryData* mutable_product_specific_binary_data(int index);
  ::userfeedback::ProductSpecificBinaryData* add_product_specific_binary_data();
  ::google::protobuf::RepeatedPtrField< ::userfeedback::ProductSpecificBinaryData >*
      mutable_product_specific_binary_data();
  const ::google::protobuf::RepeatedPtrField< ::userfeedback::ProductSpecificBinaryData >&
      product_specific_binary_data() const;

  // optional string category_tag = 16;
  bool has_category_tag() const;
  void clear_category_tag();
  static const int kCategoryTagFieldNumber = 16;
  const ::std::string& category_tag() const;
  void set_category_tag(const ::std::string& value);
  void set_category_tag(const char* value);
  void set_category_tag(const char* value, size_t size);
  ::std::string* mutable_category_tag();
  ::std::string* release_category_tag();
  void set_allocated_category_tag(::std::string* category_tag);

  // optional int32 product_id = 17;
  bool has_product_id() const;
  void clear_product_id();
  static const int kProductIdFieldNumber = 17;
  ::google::protobuf::int32 product_id() const;
  void set_product_id(::google::protobuf::int32 value);

  // optional string bucket = 18;
  bool has_bucket() const;
  void clear_bucket();
  static const int kBucketFieldNumber = 18;
  const ::std::string& bucket() const;
  void set_bucket(const ::std::string& value);
  void set_bucket(const char* value);
  void set_bucket(const char* value, size_t size);
  ::std::string* mutable_bucket();
  ::std::string* release_bucket();
  void set_allocated_bucket(::std::string* bucket);

  // @@protoc_insertion_point(class_scope:userfeedback.ExtensionSubmit)
 private:
  inline void set_has_common_data();
  inline void clear_has_common_data();
  inline void set_has_web_data();
  inline void clear_has_web_data();
  inline void set_has_type_id();
  inline void clear_has_type_id();
  inline void set_has_screenshot();
  inline void clear_has_screenshot();
  inline void set_has_chrome_data();
  inline void clear_has_chrome_data();
  inline void set_has_category_tag();
  inline void clear_has_category_tag();
  inline void set_has_product_id();
  inline void clear_has_product_id();
  inline void set_has_bucket();
  inline void clear_has_bucket();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::userfeedback::CommonData* common_data_;
  ::userfeedback::WebData* web_data_;
  ::userfeedback::PostedScreenshot* screenshot_;
  ::userfeedback::ChromeData* chrome_data_;
  ::google::protobuf::int32 type_id_;
  ::google::protobuf::int32 product_id_;
  ::google::protobuf::RepeatedPtrField< ::userfeedback::ProductSpecificBinaryData > product_specific_binary_data_;
  ::google::protobuf::internal::ArenaStringPtr category_tag_;
  ::google::protobuf::internal::ArenaStringPtr bucket_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_extension_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_extension_2eproto();
  #endif
  friend void protobuf_AssignDesc_extension_2eproto();
  friend void protobuf_ShutdownFile_extension_2eproto();

  void InitAsDefaultInstance();
  static ExtensionSubmit* default_instance_;
};
// -------------------------------------------------------------------

class SuggestQuery : public ::google::protobuf::MessageLite {
 public:
  SuggestQuery();
  virtual ~SuggestQuery();

  SuggestQuery(const SuggestQuery& from);

  inline SuggestQuery& operator=(const SuggestQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SuggestQuery& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SuggestQuery* internal_default_instance() {
    return default_instance_;
  }
  #endif

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(SuggestQuery* other);

  // implements Message ----------------------------------------------

  inline SuggestQuery* New() const { return New(NULL); }

  SuggestQuery* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SuggestQuery& from);
  void MergeFrom(const SuggestQuery& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SuggestQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .userfeedback.CommonData common_data = 1;
  bool has_common_data() const;
  void clear_common_data();
  static const int kCommonDataFieldNumber = 1;
  const ::userfeedback::CommonData& common_data() const;
  ::userfeedback::CommonData* mutable_common_data();
  ::userfeedback::CommonData* release_common_data();
  void set_allocated_common_data(::userfeedback::CommonData* common_data);

  // required .userfeedback.WebData web_data = 2;
  bool has_web_data() const;
  void clear_web_data();
  static const int kWebDataFieldNumber = 2;
  const ::userfeedback::WebData& web_data() const;
  ::userfeedback::WebData* mutable_web_data();
  ::userfeedback::WebData* release_web_data();
  void set_allocated_web_data(::userfeedback::WebData* web_data);

  // required int32 type_id = 3;
  bool has_type_id() const;
  void clear_type_id();
  static const int kTypeIdFieldNumber = 3;
  ::google::protobuf::int32 type_id() const;
  void set_type_id(::google::protobuf::int32 value);

  // optional .userfeedback.HtmlDocument html_document_structure = 4;
  bool has_html_document_structure() const;
  void clear_html_document_structure();
  static const int kHtmlDocumentStructureFieldNumber = 4;
  const ::userfeedback::HtmlDocument& html_document_structure() const;
  ::userfeedback::HtmlDocument* mutable_html_document_structure();
  ::userfeedback::HtmlDocument* release_html_document_structure();
  void set_allocated_html_document_structure(::userfeedback::HtmlDocument* html_document_structure);

  // optional .userfeedback.ChromeData chrome_data = 5;
  bool has_chrome_data() const;
  void clear_chrome_data();
  static const int kChromeDataFieldNumber = 5;
  const ::userfeedback::ChromeData& chrome_data() const;
  ::userfeedback::ChromeData* mutable_chrome_data();
  ::userfeedback::ChromeData* release_chrome_data();
  void set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data);

  // @@protoc_insertion_point(class_scope:userfeedback.SuggestQuery)
 private:
  inline void set_has_common_data();
  inline void clear_has_common_data();
  inline void set_has_web_data();
  inline void clear_has_web_data();
  inline void set_has_type_id();
  inline void clear_has_type_id();
  inline void set_has_html_document_structure();
  inline void clear_has_html_document_structure();
  inline void set_has_chrome_data();
  inline void clear_has_chrome_data();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::userfeedback::CommonData* common_data_;
  ::userfeedback::WebData* web_data_;
  ::userfeedback::HtmlDocument* html_document_structure_;
  ::userfeedback::ChromeData* chrome_data_;
  ::google::protobuf::int32 type_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_extension_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_extension_2eproto();
  #endif
  friend void protobuf_AssignDesc_extension_2eproto();
  friend void protobuf_ShutdownFile_extension_2eproto();

  void InitAsDefaultInstance();
  static SuggestQuery* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ExtensionPageRequestParams

// required .userfeedback.ExtensionDetails extension_details = 1;
inline bool ExtensionPageRequestParams::has_extension_details() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtensionPageRequestParams::set_has_extension_details() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtensionPageRequestParams::clear_has_extension_details() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtensionPageRequestParams::clear_extension_details() {
  if (extension_details_ != NULL) extension_details_->::userfeedback::ExtensionDetails::Clear();
  clear_has_extension_details();
}
inline const ::userfeedback::ExtensionDetails& ExtensionPageRequestParams::extension_details() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionPageRequestParams.extension_details)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return extension_details_ != NULL ? *extension_details_ : *default_instance().extension_details_;
#else
  return extension_details_ != NULL ? *extension_details_ : *default_instance_->extension_details_;
#endif
}
inline ::userfeedback::ExtensionDetails* ExtensionPageRequestParams::mutable_extension_details() {
  set_has_extension_details();
  if (extension_details_ == NULL) {
    extension_details_ = new ::userfeedback::ExtensionDetails;
  }
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionPageRequestParams.extension_details)
  return extension_details_;
}
inline ::userfeedback::ExtensionDetails* ExtensionPageRequestParams::release_extension_details() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionPageRequestParams.extension_details)
  clear_has_extension_details();
  ::userfeedback::ExtensionDetails* temp = extension_details_;
  extension_details_ = NULL;
  return temp;
}
inline void ExtensionPageRequestParams::set_allocated_extension_details(::userfeedback::ExtensionDetails* extension_details) {
  delete extension_details_;
  extension_details_ = extension_details;
  if (extension_details) {
    set_has_extension_details();
  } else {
    clear_has_extension_details();
  }
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionPageRequestParams.extension_details)
}

// required string url = 2;
inline bool ExtensionPageRequestParams::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtensionPageRequestParams::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtensionPageRequestParams::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtensionPageRequestParams::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& ExtensionPageRequestParams::url() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionPageRequestParams.url)
  return url_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtensionPageRequestParams::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionPageRequestParams.url)
}
inline void ExtensionPageRequestParams::set_url(const char* value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userfeedback.ExtensionPageRequestParams.url)
}
inline void ExtensionPageRequestParams::set_url(const char* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userfeedback.ExtensionPageRequestParams.url)
}
inline ::std::string* ExtensionPageRequestParams::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionPageRequestParams.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExtensionPageRequestParams::release_url() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionPageRequestParams.url)
  clear_has_url();
  return url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtensionPageRequestParams::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionPageRequestParams.url)
}

// -------------------------------------------------------------------

// PostedScreenshot

// required string mime_type = 1;
inline bool PostedScreenshot::has_mime_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PostedScreenshot::set_has_mime_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PostedScreenshot::clear_has_mime_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PostedScreenshot::clear_mime_type() {
  mime_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mime_type();
}
inline const ::std::string& PostedScreenshot::mime_type() const {
  // @@protoc_insertion_point(field_get:userfeedback.PostedScreenshot.mime_type)
  return mime_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PostedScreenshot::set_mime_type(const ::std::string& value) {
  set_has_mime_type();
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userfeedback.PostedScreenshot.mime_type)
}
inline void PostedScreenshot::set_mime_type(const char* value) {
  set_has_mime_type();
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userfeedback.PostedScreenshot.mime_type)
}
inline void PostedScreenshot::set_mime_type(const char* value, size_t size) {
  set_has_mime_type();
  mime_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userfeedback.PostedScreenshot.mime_type)
}
inline ::std::string* PostedScreenshot::mutable_mime_type() {
  set_has_mime_type();
  // @@protoc_insertion_point(field_mutable:userfeedback.PostedScreenshot.mime_type)
  return mime_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PostedScreenshot::release_mime_type() {
  // @@protoc_insertion_point(field_release:userfeedback.PostedScreenshot.mime_type)
  clear_has_mime_type();
  return mime_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PostedScreenshot::set_allocated_mime_type(::std::string* mime_type) {
  if (mime_type != NULL) {
    set_has_mime_type();
  } else {
    clear_has_mime_type();
  }
  mime_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mime_type);
  // @@protoc_insertion_point(field_set_allocated:userfeedback.PostedScreenshot.mime_type)
}

// required .userfeedback.Dimensions dimensions = 2;
inline bool PostedScreenshot::has_dimensions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PostedScreenshot::set_has_dimensions() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PostedScreenshot::clear_has_dimensions() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PostedScreenshot::clear_dimensions() {
  if (dimensions_ != NULL) dimensions_->::userfeedback::Dimensions::Clear();
  clear_has_dimensions();
}
inline const ::userfeedback::Dimensions& PostedScreenshot::dimensions() const {
  // @@protoc_insertion_point(field_get:userfeedback.PostedScreenshot.dimensions)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dimensions_ != NULL ? *dimensions_ : *default_instance().dimensions_;
#else
  return dimensions_ != NULL ? *dimensions_ : *default_instance_->dimensions_;
#endif
}
inline ::userfeedback::Dimensions* PostedScreenshot::mutable_dimensions() {
  set_has_dimensions();
  if (dimensions_ == NULL) {
    dimensions_ = new ::userfeedback::Dimensions;
  }
  // @@protoc_insertion_point(field_mutable:userfeedback.PostedScreenshot.dimensions)
  return dimensions_;
}
inline ::userfeedback::Dimensions* PostedScreenshot::release_dimensions() {
  // @@protoc_insertion_point(field_release:userfeedback.PostedScreenshot.dimensions)
  clear_has_dimensions();
  ::userfeedback::Dimensions* temp = dimensions_;
  dimensions_ = NULL;
  return temp;
}
inline void PostedScreenshot::set_allocated_dimensions(::userfeedback::Dimensions* dimensions) {
  delete dimensions_;
  dimensions_ = dimensions;
  if (dimensions) {
    set_has_dimensions();
  } else {
    clear_has_dimensions();
  }
  // @@protoc_insertion_point(field_set_allocated:userfeedback.PostedScreenshot.dimensions)
}

// optional string base64_content = 3;
inline bool PostedScreenshot::has_base64_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PostedScreenshot::set_has_base64_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PostedScreenshot::clear_has_base64_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PostedScreenshot::clear_base64_content() {
  base64_content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_base64_content();
}
inline const ::std::string& PostedScreenshot::base64_content() const {
  // @@protoc_insertion_point(field_get:userfeedback.PostedScreenshot.base64_content)
  return base64_content_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PostedScreenshot::set_base64_content(const ::std::string& value) {
  set_has_base64_content();
  base64_content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userfeedback.PostedScreenshot.base64_content)
}
inline void PostedScreenshot::set_base64_content(const char* value) {
  set_has_base64_content();
  base64_content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userfeedback.PostedScreenshot.base64_content)
}
inline void PostedScreenshot::set_base64_content(const char* value, size_t size) {
  set_has_base64_content();
  base64_content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userfeedback.PostedScreenshot.base64_content)
}
inline ::std::string* PostedScreenshot::mutable_base64_content() {
  set_has_base64_content();
  // @@protoc_insertion_point(field_mutable:userfeedback.PostedScreenshot.base64_content)
  return base64_content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PostedScreenshot::release_base64_content() {
  // @@protoc_insertion_point(field_release:userfeedback.PostedScreenshot.base64_content)
  clear_has_base64_content();
  return base64_content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PostedScreenshot::set_allocated_base64_content(::std::string* base64_content) {
  if (base64_content != NULL) {
    set_has_base64_content();
  } else {
    clear_has_base64_content();
  }
  base64_content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), base64_content);
  // @@protoc_insertion_point(field_set_allocated:userfeedback.PostedScreenshot.base64_content)
}

// optional bytes binary_content = 4;
inline bool PostedScreenshot::has_binary_content() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PostedScreenshot::set_has_binary_content() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PostedScreenshot::clear_has_binary_content() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PostedScreenshot::clear_binary_content() {
  binary_content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_binary_content();
}
inline const ::std::string& PostedScreenshot::binary_content() const {
  // @@protoc_insertion_point(field_get:userfeedback.PostedScreenshot.binary_content)
  return binary_content_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PostedScreenshot::set_binary_content(const ::std::string& value) {
  set_has_binary_content();
  binary_content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userfeedback.PostedScreenshot.binary_content)
}
inline void PostedScreenshot::set_binary_content(const char* value) {
  set_has_binary_content();
  binary_content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userfeedback.PostedScreenshot.binary_content)
}
inline void PostedScreenshot::set_binary_content(const void* value, size_t size) {
  set_has_binary_content();
  binary_content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userfeedback.PostedScreenshot.binary_content)
}
inline ::std::string* PostedScreenshot::mutable_binary_content() {
  set_has_binary_content();
  // @@protoc_insertion_point(field_mutable:userfeedback.PostedScreenshot.binary_content)
  return binary_content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PostedScreenshot::release_binary_content() {
  // @@protoc_insertion_point(field_release:userfeedback.PostedScreenshot.binary_content)
  clear_has_binary_content();
  return binary_content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PostedScreenshot::set_allocated_binary_content(::std::string* binary_content) {
  if (binary_content != NULL) {
    set_has_binary_content();
  } else {
    clear_has_binary_content();
  }
  binary_content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), binary_content);
  // @@protoc_insertion_point(field_set_allocated:userfeedback.PostedScreenshot.binary_content)
}

// -------------------------------------------------------------------

// ExtensionErrors

// required int32 number_of_attempts = 1;
inline bool ExtensionErrors::has_number_of_attempts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtensionErrors::set_has_number_of_attempts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtensionErrors::clear_has_number_of_attempts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtensionErrors::clear_number_of_attempts() {
  number_of_attempts_ = 0;
  clear_has_number_of_attempts();
}
inline ::google::protobuf::int32 ExtensionErrors::number_of_attempts() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionErrors.number_of_attempts)
  return number_of_attempts_;
}
inline void ExtensionErrors::set_number_of_attempts(::google::protobuf::int32 value) {
  set_has_number_of_attempts();
  number_of_attempts_ = value;
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionErrors.number_of_attempts)
}

// required string errors = 2;
inline bool ExtensionErrors::has_errors() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtensionErrors::set_has_errors() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtensionErrors::clear_has_errors() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtensionErrors::clear_errors() {
  errors_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errors();
}
inline const ::std::string& ExtensionErrors::errors() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionErrors.errors)
  return errors_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtensionErrors::set_errors(const ::std::string& value) {
  set_has_errors();
  errors_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionErrors.errors)
}
inline void ExtensionErrors::set_errors(const char* value) {
  set_has_errors();
  errors_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userfeedback.ExtensionErrors.errors)
}
inline void ExtensionErrors::set_errors(const char* value, size_t size) {
  set_has_errors();
  errors_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userfeedback.ExtensionErrors.errors)
}
inline ::std::string* ExtensionErrors::mutable_errors() {
  set_has_errors();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionErrors.errors)
  return errors_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExtensionErrors::release_errors() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionErrors.errors)
  clear_has_errors();
  return errors_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtensionErrors::set_allocated_errors(::std::string* errors) {
  if (errors != NULL) {
    set_has_errors();
  } else {
    clear_has_errors();
  }
  errors_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errors);
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionErrors.errors)
}

// -------------------------------------------------------------------

// ExtensionSubmit

// required .userfeedback.CommonData common_data = 1;
inline bool ExtensionSubmit::has_common_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtensionSubmit::set_has_common_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtensionSubmit::clear_has_common_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtensionSubmit::clear_common_data() {
  if (common_data_ != NULL) common_data_->::userfeedback::CommonData::Clear();
  clear_has_common_data();
}
inline const ::userfeedback::CommonData& ExtensionSubmit::common_data() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.common_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return common_data_ != NULL ? *common_data_ : *default_instance().common_data_;
#else
  return common_data_ != NULL ? *common_data_ : *default_instance_->common_data_;
#endif
}
inline ::userfeedback::CommonData* ExtensionSubmit::mutable_common_data() {
  set_has_common_data();
  if (common_data_ == NULL) {
    common_data_ = new ::userfeedback::CommonData;
  }
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.common_data)
  return common_data_;
}
inline ::userfeedback::CommonData* ExtensionSubmit::release_common_data() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.common_data)
  clear_has_common_data();
  ::userfeedback::CommonData* temp = common_data_;
  common_data_ = NULL;
  return temp;
}
inline void ExtensionSubmit::set_allocated_common_data(::userfeedback::CommonData* common_data) {
  delete common_data_;
  common_data_ = common_data;
  if (common_data) {
    set_has_common_data();
  } else {
    clear_has_common_data();
  }
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.common_data)
}

// required .userfeedback.WebData web_data = 2;
inline bool ExtensionSubmit::has_web_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtensionSubmit::set_has_web_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtensionSubmit::clear_has_web_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtensionSubmit::clear_web_data() {
  if (web_data_ != NULL) web_data_->::userfeedback::WebData::Clear();
  clear_has_web_data();
}
inline const ::userfeedback::WebData& ExtensionSubmit::web_data() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.web_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return web_data_ != NULL ? *web_data_ : *default_instance().web_data_;
#else
  return web_data_ != NULL ? *web_data_ : *default_instance_->web_data_;
#endif
}
inline ::userfeedback::WebData* ExtensionSubmit::mutable_web_data() {
  set_has_web_data();
  if (web_data_ == NULL) {
    web_data_ = new ::userfeedback::WebData;
  }
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.web_data)
  return web_data_;
}
inline ::userfeedback::WebData* ExtensionSubmit::release_web_data() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.web_data)
  clear_has_web_data();
  ::userfeedback::WebData* temp = web_data_;
  web_data_ = NULL;
  return temp;
}
inline void ExtensionSubmit::set_allocated_web_data(::userfeedback::WebData* web_data) {
  delete web_data_;
  web_data_ = web_data;
  if (web_data) {
    set_has_web_data();
  } else {
    clear_has_web_data();
  }
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.web_data)
}

// required int32 type_id = 3;
inline bool ExtensionSubmit::has_type_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtensionSubmit::set_has_type_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtensionSubmit::clear_has_type_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtensionSubmit::clear_type_id() {
  type_id_ = 0;
  clear_has_type_id();
}
inline ::google::protobuf::int32 ExtensionSubmit::type_id() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.type_id)
  return type_id_;
}
inline void ExtensionSubmit::set_type_id(::google::protobuf::int32 value) {
  set_has_type_id();
  type_id_ = value;
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionSubmit.type_id)
}

// optional .userfeedback.PostedScreenshot screenshot = 4;
inline bool ExtensionSubmit::has_screenshot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtensionSubmit::set_has_screenshot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExtensionSubmit::clear_has_screenshot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExtensionSubmit::clear_screenshot() {
  if (screenshot_ != NULL) screenshot_->::userfeedback::PostedScreenshot::Clear();
  clear_has_screenshot();
}
inline const ::userfeedback::PostedScreenshot& ExtensionSubmit::screenshot() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.screenshot)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return screenshot_ != NULL ? *screenshot_ : *default_instance().screenshot_;
#else
  return screenshot_ != NULL ? *screenshot_ : *default_instance_->screenshot_;
#endif
}
inline ::userfeedback::PostedScreenshot* ExtensionSubmit::mutable_screenshot() {
  set_has_screenshot();
  if (screenshot_ == NULL) {
    screenshot_ = new ::userfeedback::PostedScreenshot;
  }
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.screenshot)
  return screenshot_;
}
inline ::userfeedback::PostedScreenshot* ExtensionSubmit::release_screenshot() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.screenshot)
  clear_has_screenshot();
  ::userfeedback::PostedScreenshot* temp = screenshot_;
  screenshot_ = NULL;
  return temp;
}
inline void ExtensionSubmit::set_allocated_screenshot(::userfeedback::PostedScreenshot* screenshot) {
  delete screenshot_;
  screenshot_ = screenshot;
  if (screenshot) {
    set_has_screenshot();
  } else {
    clear_has_screenshot();
  }
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.screenshot)
}

// optional .userfeedback.ChromeData chrome_data = 14;
inline bool ExtensionSubmit::has_chrome_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExtensionSubmit::set_has_chrome_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExtensionSubmit::clear_has_chrome_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExtensionSubmit::clear_chrome_data() {
  if (chrome_data_ != NULL) chrome_data_->::userfeedback::ChromeData::Clear();
  clear_has_chrome_data();
}
inline const ::userfeedback::ChromeData& ExtensionSubmit::chrome_data() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.chrome_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chrome_data_ != NULL ? *chrome_data_ : *default_instance().chrome_data_;
#else
  return chrome_data_ != NULL ? *chrome_data_ : *default_instance_->chrome_data_;
#endif
}
inline ::userfeedback::ChromeData* ExtensionSubmit::mutable_chrome_data() {
  set_has_chrome_data();
  if (chrome_data_ == NULL) {
    chrome_data_ = new ::userfeedback::ChromeData;
  }
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.chrome_data)
  return chrome_data_;
}
inline ::userfeedback::ChromeData* ExtensionSubmit::release_chrome_data() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.chrome_data)
  clear_has_chrome_data();
  ::userfeedback::ChromeData* temp = chrome_data_;
  chrome_data_ = NULL;
  return temp;
}
inline void ExtensionSubmit::set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data) {
  delete chrome_data_;
  chrome_data_ = chrome_data;
  if (chrome_data) {
    set_has_chrome_data();
  } else {
    clear_has_chrome_data();
  }
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.chrome_data)
}

// repeated .userfeedback.ProductSpecificBinaryData product_specific_binary_data = 15;
inline int ExtensionSubmit::product_specific_binary_data_size() const {
  return product_specific_binary_data_.size();
}
inline void ExtensionSubmit::clear_product_specific_binary_data() {
  product_specific_binary_data_.Clear();
}
inline const ::userfeedback::ProductSpecificBinaryData& ExtensionSubmit::product_specific_binary_data(int index) const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.product_specific_binary_data)
  return product_specific_binary_data_.Get(index);
}
inline ::userfeedback::ProductSpecificBinaryData* ExtensionSubmit::mutable_product_specific_binary_data(int index) {
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.product_specific_binary_data)
  return product_specific_binary_data_.Mutable(index);
}
inline ::userfeedback::ProductSpecificBinaryData* ExtensionSubmit::add_product_specific_binary_data() {
  // @@protoc_insertion_point(field_add:userfeedback.ExtensionSubmit.product_specific_binary_data)
  return product_specific_binary_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::userfeedback::ProductSpecificBinaryData >*
ExtensionSubmit::mutable_product_specific_binary_data() {
  // @@protoc_insertion_point(field_mutable_list:userfeedback.ExtensionSubmit.product_specific_binary_data)
  return &product_specific_binary_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::userfeedback::ProductSpecificBinaryData >&
ExtensionSubmit::product_specific_binary_data() const {
  // @@protoc_insertion_point(field_list:userfeedback.ExtensionSubmit.product_specific_binary_data)
  return product_specific_binary_data_;
}

// optional string category_tag = 16;
inline bool ExtensionSubmit::has_category_tag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExtensionSubmit::set_has_category_tag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExtensionSubmit::clear_has_category_tag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExtensionSubmit::clear_category_tag() {
  category_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_category_tag();
}
inline const ::std::string& ExtensionSubmit::category_tag() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.category_tag)
  return category_tag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtensionSubmit::set_category_tag(const ::std::string& value) {
  set_has_category_tag();
  category_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionSubmit.category_tag)
}
inline void ExtensionSubmit::set_category_tag(const char* value) {
  set_has_category_tag();
  category_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userfeedback.ExtensionSubmit.category_tag)
}
inline void ExtensionSubmit::set_category_tag(const char* value, size_t size) {
  set_has_category_tag();
  category_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userfeedback.ExtensionSubmit.category_tag)
}
inline ::std::string* ExtensionSubmit::mutable_category_tag() {
  set_has_category_tag();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.category_tag)
  return category_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExtensionSubmit::release_category_tag() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.category_tag)
  clear_has_category_tag();
  return category_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtensionSubmit::set_allocated_category_tag(::std::string* category_tag) {
  if (category_tag != NULL) {
    set_has_category_tag();
  } else {
    clear_has_category_tag();
  }
  category_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), category_tag);
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.category_tag)
}

// optional int32 product_id = 17;
inline bool ExtensionSubmit::has_product_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExtensionSubmit::set_has_product_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExtensionSubmit::clear_has_product_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExtensionSubmit::clear_product_id() {
  product_id_ = 0;
  clear_has_product_id();
}
inline ::google::protobuf::int32 ExtensionSubmit::product_id() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.product_id)
  return product_id_;
}
inline void ExtensionSubmit::set_product_id(::google::protobuf::int32 value) {
  set_has_product_id();
  product_id_ = value;
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionSubmit.product_id)
}

// optional string bucket = 18;
inline bool ExtensionSubmit::has_bucket() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExtensionSubmit::set_has_bucket() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExtensionSubmit::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExtensionSubmit::clear_bucket() {
  bucket_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bucket();
}
inline const ::std::string& ExtensionSubmit::bucket() const {
  // @@protoc_insertion_point(field_get:userfeedback.ExtensionSubmit.bucket)
  return bucket_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtensionSubmit::set_bucket(const ::std::string& value) {
  set_has_bucket();
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:userfeedback.ExtensionSubmit.bucket)
}
inline void ExtensionSubmit::set_bucket(const char* value) {
  set_has_bucket();
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:userfeedback.ExtensionSubmit.bucket)
}
inline void ExtensionSubmit::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  bucket_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:userfeedback.ExtensionSubmit.bucket)
}
inline ::std::string* ExtensionSubmit::mutable_bucket() {
  set_has_bucket();
  // @@protoc_insertion_point(field_mutable:userfeedback.ExtensionSubmit.bucket)
  return bucket_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExtensionSubmit::release_bucket() {
  // @@protoc_insertion_point(field_release:userfeedback.ExtensionSubmit.bucket)
  clear_has_bucket();
  return bucket_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtensionSubmit::set_allocated_bucket(::std::string* bucket) {
  if (bucket != NULL) {
    set_has_bucket();
  } else {
    clear_has_bucket();
  }
  bucket_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bucket);
  // @@protoc_insertion_point(field_set_allocated:userfeedback.ExtensionSubmit.bucket)
}

// -------------------------------------------------------------------

// SuggestQuery

// required .userfeedback.CommonData common_data = 1;
inline bool SuggestQuery::has_common_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SuggestQuery::set_has_common_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SuggestQuery::clear_has_common_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SuggestQuery::clear_common_data() {
  if (common_data_ != NULL) common_data_->::userfeedback::CommonData::Clear();
  clear_has_common_data();
}
inline const ::userfeedback::CommonData& SuggestQuery::common_data() const {
  // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.common_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return common_data_ != NULL ? *common_data_ : *default_instance().common_data_;
#else
  return common_data_ != NULL ? *common_data_ : *default_instance_->common_data_;
#endif
}
inline ::userfeedback::CommonData* SuggestQuery::mutable_common_data() {
  set_has_common_data();
  if (common_data_ == NULL) {
    common_data_ = new ::userfeedback::CommonData;
  }
  // @@protoc_insertion_point(field_mutable:userfeedback.SuggestQuery.common_data)
  return common_data_;
}
inline ::userfeedback::CommonData* SuggestQuery::release_common_data() {
  // @@protoc_insertion_point(field_release:userfeedback.SuggestQuery.common_data)
  clear_has_common_data();
  ::userfeedback::CommonData* temp = common_data_;
  common_data_ = NULL;
  return temp;
}
inline void SuggestQuery::set_allocated_common_data(::userfeedback::CommonData* common_data) {
  delete common_data_;
  common_data_ = common_data;
  if (common_data) {
    set_has_common_data();
  } else {
    clear_has_common_data();
  }
  // @@protoc_insertion_point(field_set_allocated:userfeedback.SuggestQuery.common_data)
}

// required .userfeedback.WebData web_data = 2;
inline bool SuggestQuery::has_web_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SuggestQuery::set_has_web_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SuggestQuery::clear_has_web_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SuggestQuery::clear_web_data() {
  if (web_data_ != NULL) web_data_->::userfeedback::WebData::Clear();
  clear_has_web_data();
}
inline const ::userfeedback::WebData& SuggestQuery::web_data() const {
  // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.web_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return web_data_ != NULL ? *web_data_ : *default_instance().web_data_;
#else
  return web_data_ != NULL ? *web_data_ : *default_instance_->web_data_;
#endif
}
inline ::userfeedback::WebData* SuggestQuery::mutable_web_data() {
  set_has_web_data();
  if (web_data_ == NULL) {
    web_data_ = new ::userfeedback::WebData;
  }
  // @@protoc_insertion_point(field_mutable:userfeedback.SuggestQuery.web_data)
  return web_data_;
}
inline ::userfeedback::WebData* SuggestQuery::release_web_data() {
  // @@protoc_insertion_point(field_release:userfeedback.SuggestQuery.web_data)
  clear_has_web_data();
  ::userfeedback::WebData* temp = web_data_;
  web_data_ = NULL;
  return temp;
}
inline void SuggestQuery::set_allocated_web_data(::userfeedback::WebData* web_data) {
  delete web_data_;
  web_data_ = web_data;
  if (web_data) {
    set_has_web_data();
  } else {
    clear_has_web_data();
  }
  // @@protoc_insertion_point(field_set_allocated:userfeedback.SuggestQuery.web_data)
}

// required int32 type_id = 3;
inline bool SuggestQuery::has_type_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SuggestQuery::set_has_type_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SuggestQuery::clear_has_type_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SuggestQuery::clear_type_id() {
  type_id_ = 0;
  clear_has_type_id();
}
inline ::google::protobuf::int32 SuggestQuery::type_id() const {
  // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.type_id)
  return type_id_;
}
inline void SuggestQuery::set_type_id(::google::protobuf::int32 value) {
  set_has_type_id();
  type_id_ = value;
  // @@protoc_insertion_point(field_set:userfeedback.SuggestQuery.type_id)
}

// optional .userfeedback.HtmlDocument html_document_structure = 4;
inline bool SuggestQuery::has_html_document_structure() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SuggestQuery::set_has_html_document_structure() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SuggestQuery::clear_has_html_document_structure() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SuggestQuery::clear_html_document_structure() {
  if (html_document_structure_ != NULL) html_document_structure_->::userfeedback::HtmlDocument::Clear();
  clear_has_html_document_structure();
}
inline const ::userfeedback::HtmlDocument& SuggestQuery::html_document_structure() const {
  // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.html_document_structure)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return html_document_structure_ != NULL ? *html_document_structure_ : *default_instance().html_document_structure_;
#else
  return html_document_structure_ != NULL ? *html_document_structure_ : *default_instance_->html_document_structure_;
#endif
}
inline ::userfeedback::HtmlDocument* SuggestQuery::mutable_html_document_structure() {
  set_has_html_document_structure();
  if (html_document_structure_ == NULL) {
    html_document_structure_ = new ::userfeedback::HtmlDocument;
  }
  // @@protoc_insertion_point(field_mutable:userfeedback.SuggestQuery.html_document_structure)
  return html_document_structure_;
}
inline ::userfeedback::HtmlDocument* SuggestQuery::release_html_document_structure() {
  // @@protoc_insertion_point(field_release:userfeedback.SuggestQuery.html_document_structure)
  clear_has_html_document_structure();
  ::userfeedback::HtmlDocument* temp = html_document_structure_;
  html_document_structure_ = NULL;
  return temp;
}
inline void SuggestQuery::set_allocated_html_document_structure(::userfeedback::HtmlDocument* html_document_structure) {
  delete html_document_structure_;
  html_document_structure_ = html_document_structure;
  if (html_document_structure) {
    set_has_html_document_structure();
  } else {
    clear_has_html_document_structure();
  }
  // @@protoc_insertion_point(field_set_allocated:userfeedback.SuggestQuery.html_document_structure)
}

// optional .userfeedback.ChromeData chrome_data = 5;
inline bool SuggestQuery::has_chrome_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SuggestQuery::set_has_chrome_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SuggestQuery::clear_has_chrome_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SuggestQuery::clear_chrome_data() {
  if (chrome_data_ != NULL) chrome_data_->::userfeedback::ChromeData::Clear();
  clear_has_chrome_data();
}
inline const ::userfeedback::ChromeData& SuggestQuery::chrome_data() const {
  // @@protoc_insertion_point(field_get:userfeedback.SuggestQuery.chrome_data)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chrome_data_ != NULL ? *chrome_data_ : *default_instance().chrome_data_;
#else
  return chrome_data_ != NULL ? *chrome_data_ : *default_instance_->chrome_data_;
#endif
}
inline ::userfeedback::ChromeData* SuggestQuery::mutable_chrome_data() {
  set_has_chrome_data();
  if (chrome_data_ == NULL) {
    chrome_data_ = new ::userfeedback::ChromeData;
  }
  // @@protoc_insertion_point(field_mutable:userfeedback.SuggestQuery.chrome_data)
  return chrome_data_;
}
inline ::userfeedback::ChromeData* SuggestQuery::release_chrome_data() {
  // @@protoc_insertion_point(field_release:userfeedback.SuggestQuery.chrome_data)
  clear_has_chrome_data();
  ::userfeedback::ChromeData* temp = chrome_data_;
  chrome_data_ = NULL;
  return temp;
}
inline void SuggestQuery::set_allocated_chrome_data(::userfeedback::ChromeData* chrome_data) {
  delete chrome_data_;
  chrome_data_ = chrome_data;
  if (chrome_data) {
    set_has_chrome_data();
  } else {
    clear_has_chrome_data();
  }
  // @@protoc_insertion_point(field_set_allocated:userfeedback.SuggestQuery.chrome_data)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace userfeedback

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_extension_2eproto__INCLUDED
