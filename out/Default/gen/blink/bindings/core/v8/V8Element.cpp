// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This file has been auto-generated by code_generator_v8.py. DO NOT MODIFY!

#include "V8Element.h"

#include "bindings/core/v8/Dictionary.h"
#include "bindings/core/v8/DictionarySequenceOrDictionary.h"
#include "bindings/core/v8/ExceptionState.h"
#include "bindings/core/v8/ScriptState.h"
#include "bindings/core/v8/V8AbstractEventListener.h"
#include "bindings/core/v8/V8Animation.h"
#include "bindings/core/v8/V8Attr.h"
#include "bindings/core/v8/V8ClientRect.h"
#include "bindings/core/v8/V8ClientRectList.h"
#include "bindings/core/v8/V8DOMActivityLogger.h"
#include "bindings/core/v8/V8DOMConfiguration.h"
#include "bindings/core/v8/V8DOMTokenList.h"
#include "bindings/core/v8/V8Element.h"
#include "bindings/core/v8/V8EventListenerList.h"
#include "bindings/core/v8/V8HTMLCollection.h"
#include "bindings/core/v8/V8HTMLSlotElement.h"
#include "bindings/core/v8/V8KeyframeEffectOptions.h"
#include "bindings/core/v8/V8NamedNodeMap.h"
#include "bindings/core/v8/V8Node.h"
#include "bindings/core/v8/V8NodeList.h"
#include "bindings/core/v8/V8ObjectConstructor.h"
#include "bindings/core/v8/V8ScrollStateCallback.h"
#include "bindings/core/v8/V8ScrollToOptions.h"
#include "bindings/core/v8/V8ShadowRoot.h"
#include "bindings/core/v8/V8ShadowRootInit.h"
#include "core/HTMLNames.h"
#include "core/animation/ElementAnimation.h"
#include "core/dom/ChildNode.h"
#include "core/dom/ClassCollection.h"
#include "core/dom/Document.h"
#include "core/dom/ElementFullscreen.h"
#include "core/dom/NameNodeList.h"
#include "core/dom/NodeList.h"
#include "core/dom/NonDocumentTypeChildNode.h"
#include "core/dom/ParentNode.h"
#include "core/dom/StaticNodeList.h"
#include "core/dom/TagCollection.h"
#include "core/dom/custom/CEReactionsScope.h"
#include "core/dom/custom/V0CustomElementProcessingStack.h"
#include "core/frame/UseCounter.h"
#include "core/html/HTMLCollection.h"
#include "core/html/HTMLDataListOptionsCollection.h"
#include "core/html/HTMLFormControlsCollection.h"
#include "core/html/HTMLTableRowsCollection.h"
#include "core/html/LabelsNodeList.h"
#include "platform/RuntimeEnabledFeatures.h"
#include "wtf/GetPtr.h"
#include "wtf/RefPtr.h"

namespace blink {

// Suppress warning: global constructors, because struct WrapperTypeInfo is trivial
// and does not depend on another global objects.
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif
const WrapperTypeInfo V8Element::wrapperTypeInfo = { gin::kEmbedderBlink, V8Element::domTemplate, V8Element::trace, V8Element::traceWrappers, 0, 0, V8Element::preparePrototypeAndInterfaceObject, nullptr, "Element", &V8Node::wrapperTypeInfo, WrapperTypeInfo::WrapperTypeObjectPrototype, WrapperTypeInfo::NodeClassId, WrapperTypeInfo::InheritFromEventTarget, WrapperTypeInfo::Dependent };
#if defined(COMPONENT_BUILD) && defined(WIN32) && COMPILER(CLANG)
#pragma clang diagnostic pop
#endif

// This static member must be declared by DEFINE_WRAPPERTYPEINFO in Element.h.
// For details, see the comment of DEFINE_WRAPPERTYPEINFO in
// bindings/core/v8/ScriptWrappable.h.
const WrapperTypeInfo& Element::s_wrapperTypeInfo = V8Element::wrapperTypeInfo;

static_assert(
    !std::is_base_of<ActiveScriptWrappable, Element>::value,
    "Element inherits from ActiveScriptWrappable, but does not specify "
    "[ActiveScriptWrappable] extended attribute in the IDL file.  "
    "Be consistent.");

namespace ElementV8Internal {

static void namespaceURIAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueStringOrNull(info, impl->namespaceURI(), info.GetIsolate());
}

static void namespaceURIAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::namespaceURIAttributeGetter(info);
}

static void prefixAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueStringOrNull(info, impl->prefix(), info.GetIsolate());
}

static void prefixAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::prefixAttributeGetter(info);
}

static void localNameAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueString(info, impl->localName(), info.GetIsolate());
}

static void localNameAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::localNameAttributeGetter(info);
}

static void tagNameAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueString(info, impl->tagName(), info.GetIsolate());
}

static void tagNameAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::tagNameAttributeGetter(info);
}

static void idAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueString(info, impl->getIdAttribute(), info.GetIsolate());
}

static void idAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::idAttributeGetter(info);
}

static void idAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    V8StringResource<> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setAttribute(HTMLNames::idAttr, cppValue);
}

static void idAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    CEReactionsScope ceReactionsScope;
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    ElementV8Internal::idAttributeSetter(v8Value, info);
}

static void classNameAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueString(info, impl->getClassAttribute(), info.GetIsolate());
}

static void classNameAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::classNameAttributeGetter(info);
}

static void classNameAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    V8StringResource<> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setAttribute(HTMLNames::classAttr, cppValue);
}

static void classNameAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    CEReactionsScope ceReactionsScope;
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    ElementV8Internal::classNameAttributeSetter(v8Value, info);
}

static void classListAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->classList()), impl);
}

static void classListAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::classListAttributeGetter(info);
}

static void classListAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* proxyImpl = V8Element::toImpl(holder);
    DOMTokenList* impl = WTF::getPtr(proxyImpl->classList());
    if (!impl)
        return;
    V8StringResource<> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setValue(cppValue);
}

static void classListAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::classListAttributeSetter(v8Value, info);
}

static void classListAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->classList()));
}

static void classListAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::classListAttributeGetterForMainWorld(info);
}

static void classListAttributeSetterForMainWorld(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* proxyImpl = V8Element::toImpl(holder);
    DOMTokenList* impl = WTF::getPtr(proxyImpl->classList());
    if (!impl)
        return;
    V8StringResource<> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setValue(cppValue);
}

static void classListAttributeSetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::classListAttributeSetterForMainWorld(v8Value, info);
}

static void ongotpointercaptureAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(WTF::getPtr(impl->ongotpointercapture()));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void ongotpointercaptureAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::ongotpointercaptureAttributeGetter(info);
}

static void ongotpointercaptureAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    impl->setOngotpointercapture(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void ongotpointercaptureAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::ongotpointercaptureAttributeSetter(v8Value, info);
}

static void onlostpointercaptureAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(WTF::getPtr(impl->onlostpointercapture()));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void onlostpointercaptureAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::onlostpointercaptureAttributeGetter(info);
}

static void onlostpointercaptureAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    impl->setOnlostpointercapture(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void onlostpointercaptureAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::onlostpointercaptureAttributeSetter(v8Value, info);
}

static void attributesAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->attributesForBindings()), impl);
}

static void attributesAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::attributesAttributeGetter(info);
}

static void attributesAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->attributesForBindings()));
}

static void attributesAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::attributesAttributeGetterForMainWorld(info);
}

static void innerHTMLAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueString(info, impl->innerHTML(), info.GetIsolate());
}

static void innerHTMLAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::innerHTMLAttributeGetter(info);
}

static void innerHTMLAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "innerHTML", "Element", holder, info.GetIsolate());
    Element* impl = V8Element::toImpl(holder);
    V8StringResource<TreatNullAsNullString> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    impl->setInnerHTML(cppValue, exceptionState);
    exceptionState.throwIfNeeded();
}

static void innerHTMLAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    CEReactionsScope ceReactionsScope;
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    ElementV8Internal::innerHTMLAttributeSetter(v8Value, info);
}

static void outerHTMLAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueString(info, impl->outerHTML(), info.GetIsolate());
}

static void outerHTMLAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::outerHTMLAttributeGetter(info);
}

static void outerHTMLAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "outerHTML", "Element", holder, info.GetIsolate());
    Element* impl = V8Element::toImpl(holder);
    V8StringResource<TreatNullAsNullString> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    impl->setOuterHTML(cppValue, exceptionState);
    exceptionState.throwIfNeeded();
}

static void outerHTMLAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    CEReactionsScope ceReactionsScope;
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    ElementV8Internal::outerHTMLAttributeSetter(v8Value, info);
}

static void shadowRootAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->openShadowRoot()), impl);
}

static void shadowRootAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::shadowRootAttributeGetter(info);
}

static void shadowRootAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueForMainWorld(info, WTF::getPtr(impl->openShadowRoot()));
}

static void shadowRootAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::shadowRootAttributeGetterForMainWorld(info);
}

static void slotAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueString(info, impl->fastGetAttribute(HTMLNames::slotAttr), info.GetIsolate());
}

static void slotAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::slotAttributeGetter(info);
}

static void slotAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    V8StringResource<> cppValue = v8Value;
    if (!cppValue.prepare())
        return;
    impl->setAttribute(HTMLNames::slotAttr, cppValue);
}

static void slotAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    CEReactionsScope ceReactionsScope;
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    ElementV8Internal::slotAttributeSetter(v8Value, info);
}

static void assignedSlotAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueFast(info, WTF::getPtr(impl->assignedSlotForBinding()), impl);
}

static void assignedSlotAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::assignedSlotAttributeGetter(info);
}

static void scrollTopAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValue(info, impl->scrollTop());
}

static void scrollTopAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::scrollTopAttributeGetter(info);
}

static void scrollTopAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "scrollTop", "Element", holder, info.GetIsolate());
    Element* impl = V8Element::toImpl(holder);
    double cppValue = toDouble(info.GetIsolate(), v8Value, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setScrollTop(cppValue);
}

static void scrollTopAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::scrollTopAttributeSetter(v8Value, info);
}

static void scrollLeftAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValue(info, impl->scrollLeft());
}

static void scrollLeftAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::scrollLeftAttributeGetter(info);
}

static void scrollLeftAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    ExceptionState exceptionState(ExceptionState::SetterContext, "scrollLeft", "Element", holder, info.GetIsolate());
    Element* impl = V8Element::toImpl(holder);
    double cppValue = toDouble(info.GetIsolate(), v8Value, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    impl->setScrollLeft(cppValue);
}

static void scrollLeftAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::scrollLeftAttributeSetter(v8Value, info);
}

static void scrollWidthAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueInt(info, impl->scrollWidth());
}

static void scrollWidthAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::scrollWidthAttributeGetter(info);
}

static void scrollHeightAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueInt(info, impl->scrollHeight());
}

static void scrollHeightAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::scrollHeightAttributeGetter(info);
}

static void clientTopAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueInt(info, impl->clientTop());
}

static void clientTopAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::clientTopAttributeGetter(info);
}

static void clientLeftAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueInt(info, impl->clientLeft());
}

static void clientLeftAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::clientLeftAttributeGetter(info);
}

static void clientWidthAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueInt(info, impl->clientWidth());
}

static void clientWidthAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::clientWidthAttributeGetter(info);
}

static void clientHeightAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueInt(info, impl->clientHeight());
}

static void clientHeightAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::clientHeightAttributeGetter(info);
}

static void computedRoleAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueStringOrNull(info, impl->computedRole(), info.GetIsolate());
}

static void computedRoleAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::computedRoleAttributeGetter(info);
}

static void computedNameAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueStringOrNull(info, impl->computedName(), info.GetIsolate());
}

static void computedNameAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::computedNameAttributeGetter(info);
}

static void onbeforecopyAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(WTF::getPtr(impl->onbeforecopy()));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void onbeforecopyAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::onbeforecopyAttributeGetter(info);
}

static void onbeforecopyAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    impl->setOnbeforecopy(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void onbeforecopyAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::onbeforecopyAttributeSetter(v8Value, info);
}

static void onbeforecutAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(WTF::getPtr(impl->onbeforecut()));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void onbeforecutAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::onbeforecutAttributeGetter(info);
}

static void onbeforecutAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    impl->setOnbeforecut(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void onbeforecutAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::onbeforecutAttributeSetter(v8Value, info);
}

static void onbeforepasteAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(WTF::getPtr(impl->onbeforepaste()));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void onbeforepasteAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::onbeforepasteAttributeGetter(info);
}

static void onbeforepasteAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    impl->setOnbeforepaste(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void onbeforepasteAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::onbeforepasteAttributeSetter(v8Value, info);
}

static void oncopyAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(WTF::getPtr(impl->oncopy()));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void oncopyAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::oncopyAttributeGetter(info);
}

static void oncopyAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    impl->setOncopy(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void oncopyAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::oncopyAttributeSetter(v8Value, info);
}

static void oncutAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(WTF::getPtr(impl->oncut()));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void oncutAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::oncutAttributeGetter(info);
}

static void oncutAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    impl->setOncut(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void oncutAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::oncutAttributeSetter(v8Value, info);
}

static void onpasteAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(WTF::getPtr(impl->onpaste()));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void onpasteAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::onpasteAttributeGetter(info);
}

static void onpasteAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    impl->setOnpaste(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void onpasteAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::onpasteAttributeSetter(v8Value, info);
}

static void onsearchAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(WTF::getPtr(impl->onsearch()));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void onsearchAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::onsearchAttributeGetter(info);
}

static void onsearchAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    impl->setOnsearch(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void onsearchAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::onsearchAttributeSetter(v8Value, info);
}

static void onselectstartAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(WTF::getPtr(impl->onselectstart()));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void onselectstartAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::onselectstartAttributeGetter(info);
}

static void onselectstartAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    impl->setOnselectstart(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void onselectstartAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::onselectstartAttributeSetter(v8Value, info);
}

static void onwheelAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(WTF::getPtr(impl->onwheel()));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void onwheelAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::onwheelAttributeGetter(info);
}

static void onwheelAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    impl->setOnwheel(V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void onwheelAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::onwheelAttributeSetter(v8Value, info);
}

static void onwebkitfullscreenchangeAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(ElementFullscreen::onwebkitfullscreenchange(*impl));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void onwebkitfullscreenchangeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::onwebkitfullscreenchangeAttributeGetter(info);
}

static void onwebkitfullscreenchangeAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    ElementFullscreen::setOnwebkitfullscreenchange(*impl, V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void onwebkitfullscreenchangeAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::onwebkitfullscreenchangeAttributeSetter(v8Value, info);
}

static void onwebkitfullscreenerrorAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    EventListener* cppValue(ElementFullscreen::onwebkitfullscreenerror(*impl));
    v8SetReturnValue(info, cppValue ? V8AbstractEventListener::cast(cppValue)->getListenerOrNull(info.GetIsolate(), impl->getExecutionContext()) : v8::Null(info.GetIsolate()).As<v8::Value>());
}

static void onwebkitfullscreenerrorAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::onwebkitfullscreenerrorAttributeGetter(info);
}

static void onwebkitfullscreenerrorAttributeSetter(v8::Local<v8::Value> v8Value, const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    ElementFullscreen::setOnwebkitfullscreenerror(*impl, V8EventListenerList::getEventListener(ScriptState::current(info.GetIsolate()), v8Value, true, ListenerFindOrCreate));
}

static void onwebkitfullscreenerrorAttributeSetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Value> v8Value = info[0];
    ElementV8Internal::onwebkitfullscreenerrorAttributeSetter(v8Value, info);
}

static void previousElementSiblingAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueFast(info, NonDocumentTypeChildNode::previousElementSibling(*impl), impl);
}

static void previousElementSiblingAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::previousElementSiblingAttributeGetter(info);
}

static void previousElementSiblingAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueForMainWorld(info, NonDocumentTypeChildNode::previousElementSibling(*impl));
}

static void previousElementSiblingAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::previousElementSiblingAttributeGetterForMainWorld(info);
}

static void nextElementSiblingAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueFast(info, NonDocumentTypeChildNode::nextElementSibling(*impl), impl);
}

static void nextElementSiblingAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::nextElementSiblingAttributeGetter(info);
}

static void nextElementSiblingAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueForMainWorld(info, NonDocumentTypeChildNode::nextElementSibling(*impl));
}

static void nextElementSiblingAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::nextElementSiblingAttributeGetterForMainWorld(info);
}

static void childrenAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueFast(info, ParentNode::children(*impl), impl);
}

static void childrenAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::childrenAttributeGetter(info);
}

static void childrenAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueForMainWorld(info, ParentNode::children(*impl));
}

static void childrenAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::childrenAttributeGetterForMainWorld(info);
}

static void firstElementChildAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueFast(info, ParentNode::firstElementChild(*impl), impl);
}

static void firstElementChildAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::firstElementChildAttributeGetter(info);
}

static void firstElementChildAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueForMainWorld(info, ParentNode::firstElementChild(*impl));
}

static void firstElementChildAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::firstElementChildAttributeGetterForMainWorld(info);
}

static void lastElementChildAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueFast(info, ParentNode::lastElementChild(*impl), impl);
}

static void lastElementChildAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::lastElementChildAttributeGetter(info);
}

static void lastElementChildAttributeGetterForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueForMainWorld(info, ParentNode::lastElementChild(*impl));
}

static void lastElementChildAttributeGetterCallbackForMainWorld(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::lastElementChildAttributeGetterForMainWorld(info);
}

static void childElementCountAttributeGetter(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    v8::Local<v8::Object> holder = info.Holder();
    Element* impl = V8Element::toImpl(holder);
    v8SetReturnValueUnsigned(info, ParentNode::childElementCount(*impl));
}

static void childElementCountAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::childElementCountAttributeGetter(info);
}

static void setPointerCaptureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setPointerCapture", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    int pointerId;
    {
        pointerId = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->setPointerCapture(pointerId, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setPointerCaptureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::setPointerCaptureMethod(info);
}

static void releasePointerCaptureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "releasePointerCapture", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    int pointerId;
    {
        pointerId = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->releasePointerCapture(pointerId, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void releasePointerCaptureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::releasePointerCaptureMethod(info);
}

static void hasPointerCaptureMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "hasPointerCapture", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    int pointerId;
    {
        pointerId = toInt32(info.GetIsolate(), info[0], NormalConversion, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    v8SetReturnValueBool(info, impl->hasPointerCapture(pointerId));
}

static void hasPointerCaptureMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::hasPointerCaptureMethod(info);
}

static void hasAttributesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Element* impl = V8Element::toImpl(info.Holder());
    v8SetReturnValueBool(info, impl->hasAttributes());
}

static void hasAttributesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::hasAttributesMethod(info);
}

static void getAttributeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(info.GetIsolate(), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "getAttribute", "Element", 1, info.Length()));
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<> name;
    {
        name = info[0];
        if (!name.prepare())
            return;
    }
    v8SetReturnValueStringOrNull(info, impl->getAttribute(name), info.GetIsolate());
}

static void getAttributeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::getAttributeMethod(info);
}

static void getAttributeNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        V8ThrowException::throwException(info.GetIsolate(), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "getAttributeNS", "Element", 2, info.Length()));
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<TreatNullAndUndefinedAsNullString> namespaceURI;
    V8StringResource<> localName;
    {
        namespaceURI = info[0];
        if (!namespaceURI.prepare())
            return;
        localName = info[1];
        if (!localName.prepare())
            return;
    }
    v8SetReturnValueStringOrNull(info, impl->getAttributeNS(namespaceURI, localName), info.GetIsolate());
}

static void getAttributeNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::getAttributeNSMethod(info);
}

static void setAttributeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setAttribute", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    V8StringResource<> name;
    V8StringResource<> value;
    {
        name = info[0];
        if (!name.prepare())
            return;
        value = info[1];
        if (!value.prepare())
            return;
    }
    impl->setAttribute(name, value, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setAttributeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::setAttributeMethod(info);
}

static void setAttributeNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setAttributeNS", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        setMinimumArityTypeError(exceptionState, 3, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    V8StringResource<TreatNullAndUndefinedAsNullString> namespaceURI;
    V8StringResource<> name;
    V8StringResource<> value;
    {
        namespaceURI = info[0];
        if (!namespaceURI.prepare())
            return;
        name = info[1];
        if (!name.prepare())
            return;
        value = info[2];
        if (!value.prepare())
            return;
    }
    impl->setAttributeNS(namespaceURI, name, value, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void setAttributeNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::setAttributeNSMethod(info);
}

static void removeAttributeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(info.GetIsolate(), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "removeAttribute", "Element", 1, info.Length()));
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    V8StringResource<> name;
    {
        name = info[0];
        if (!name.prepare())
            return;
    }
    impl->removeAttribute(name);
}

static void removeAttributeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::removeAttributeMethod(info);
}

static void removeAttributeNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        V8ThrowException::throwException(info.GetIsolate(), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "removeAttributeNS", "Element", 2, info.Length()));
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    V8StringResource<TreatNullAndUndefinedAsNullString> namespaceURI;
    V8StringResource<> localName;
    {
        namespaceURI = info[0];
        if (!namespaceURI.prepare())
            return;
        localName = info[1];
        if (!localName.prepare())
            return;
    }
    impl->removeAttributeNS(namespaceURI, localName);
}

static void removeAttributeNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::removeAttributeNSMethod(info);
}

static void hasAttributeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(info.GetIsolate(), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "hasAttribute", "Element", 1, info.Length()));
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<> name;
    {
        name = info[0];
        if (!name.prepare())
            return;
    }
    v8SetReturnValueBool(info, impl->hasAttribute(name));
}

static void hasAttributeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::hasAttributeMethod(info);
}

static void hasAttributeNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        V8ThrowException::throwException(info.GetIsolate(), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "hasAttributeNS", "Element", 2, info.Length()));
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<TreatNullAndUndefinedAsNullString> namespaceURI;
    V8StringResource<> localName;
    {
        namespaceURI = info[0];
        if (!namespaceURI.prepare())
            return;
        localName = info[1];
        if (!localName.prepare())
            return;
    }
    v8SetReturnValueBool(info, impl->hasAttributeNS(namespaceURI, localName));
}

static void hasAttributeNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::hasAttributeNSMethod(info);
}

static void getAttributeNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(info.GetIsolate(), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "getAttributeNode", "Element", 1, info.Length()));
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<> name;
    {
        name = info[0];
        if (!name.prepare())
            return;
    }
    v8SetReturnValueFast(info, impl->getAttributeNode(name), impl);
}

static void getAttributeNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::getAttributeNodeMethod(info);
}

static void getAttributeNodeNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        V8ThrowException::throwException(info.GetIsolate(), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "getAttributeNodeNS", "Element", 2, info.Length()));
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<TreatNullAndUndefinedAsNullString> namespaceURI;
    V8StringResource<> localName;
    {
        namespaceURI = info[0];
        if (!namespaceURI.prepare())
            return;
        localName = info[1];
        if (!localName.prepare())
            return;
    }
    v8SetReturnValueFast(info, impl->getAttributeNodeNS(namespaceURI, localName), impl);
}

static void getAttributeNodeNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::getAttributeNodeNSMethod(info);
}

static void setAttributeNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setAttributeNode", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    Attr* attr;
    {
        attr = V8Attr::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!attr) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Attr'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    Attr* result = impl->setAttributeNode(attr, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, result, impl);
}

static void setAttributeNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::setAttributeNodeMethod(info);
}

static void setAttributeNodeNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setAttributeNodeNS", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    Attr* attr;
    {
        attr = V8Attr::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!attr) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Attr'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    Attr* result = impl->setAttributeNodeNS(attr, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, result, impl);
}

static void setAttributeNodeNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::setAttributeNodeNSMethod(info);
}

static void removeAttributeNodeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "removeAttributeNode", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    Attr* attr;
    {
        attr = V8Attr::toImplWithTypeCheck(info.GetIsolate(), info[0]);
        if (!attr) {
            exceptionState.throwTypeError("parameter 1 is not of type 'Attr'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    Attr* result = impl->removeAttributeNode(attr, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, result, impl);
}

static void removeAttributeNodeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::removeAttributeNodeMethod(info);
}

static void closestMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "closest", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<> selectors;
    {
        selectors = info[0];
        if (!selectors.prepare())
            return;
    }
    Element* result = impl->closest(selectors, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, result, impl);
}

static void closestMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::closestMethod(info);
}

static void matchesMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "matches", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<> selectors;
    {
        selectors = info[0];
        if (!selectors.prepare())
            return;
    }
    bool result = impl->matches(selectors, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void matchesMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::matchesMethod(info);
}

static void webkitMatchesSelectorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "webkitMatchesSelector", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<> selectors;
    {
        selectors = info[0];
        if (!selectors.prepare())
            return;
    }
    bool result = impl->matches(selectors, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueBool(info, result);
}

static void webkitMatchesSelectorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), currentExecutionContext(info.GetIsolate()), UseCounter::ElementPrefixedMatchesSelector);
    ElementV8Internal::webkitMatchesSelectorMethod(info);
}

static void getElementsByTagNameMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(info.GetIsolate(), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "getElementsByTagName", "Element", 1, info.Length()));
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<> localName;
    {
        localName = info[0];
        if (!localName.prepare())
            return;
    }
    v8SetReturnValueFast(info, impl->getElementsByTagName(localName), impl);
}

static void getElementsByTagNameMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::getElementsByTagNameMethod(info);
}

static void getElementsByTagNameNSMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 2)) {
        V8ThrowException::throwException(info.GetIsolate(), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "getElementsByTagNameNS", "Element", 2, info.Length()));
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<TreatNullAndUndefinedAsNullString> namespaceURI;
    V8StringResource<> localName;
    {
        namespaceURI = info[0];
        if (!namespaceURI.prepare())
            return;
        localName = info[1];
        if (!localName.prepare())
            return;
    }
    v8SetReturnValueFast(info, impl->getElementsByTagNameNS(namespaceURI, localName), impl);
}

static void getElementsByTagNameNSMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::getElementsByTagNameNSMethod(info);
}

static void getElementsByClassNameMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    if (UNLIKELY(info.Length() < 1)) {
        V8ThrowException::throwException(info.GetIsolate(), createMinimumArityTypeErrorForMethod(info.GetIsolate(), "getElementsByClassName", "Element", 1, info.Length()));
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<> classNames;
    {
        classNames = info[0];
        if (!classNames.prepare())
            return;
    }
    v8SetReturnValueFast(info, impl->getElementsByClassName(classNames), impl);
}

static void getElementsByClassNameMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::getElementsByClassNameMethod(info);
}

static void insertAdjacentElementMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "insertAdjacentElement", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    V8StringResource<> where;
    Element* element;
    {
        where = info[0];
        if (!where.prepare())
            return;
        element = V8Element::toImplWithTypeCheck(info.GetIsolate(), info[1]);
        if (!element) {
            exceptionState.throwTypeError("parameter 2 is not of type 'Element'.");
            exceptionState.throwIfNeeded();
            return;
        }
    }
    Element* result = impl->insertAdjacentElement(where, element, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, result, impl);
}

static void insertAdjacentElementMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::insertAdjacentElementMethod(info);
}

static void insertAdjacentTextMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "insertAdjacentText", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<> where;
    V8StringResource<> data;
    {
        where = info[0];
        if (!where.prepare())
            return;
        data = info[1];
        if (!data.prepare())
            return;
    }
    impl->insertAdjacentText(where, data, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void insertAdjacentTextMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::insertAdjacentTextMethod(info);
}

static void insertAdjacentHTMLMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "insertAdjacentHTML", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    V8StringResource<> position;
    V8StringResource<> text;
    {
        position = info[0];
        if (!position.prepare())
            return;
        text = info[1];
        if (!text.prepare())
            return;
    }
    impl->insertAdjacentHTML(position, text, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void insertAdjacentHTMLMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::insertAdjacentHTMLMethod(info);
}

static void createShadowRootMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "createShadowRoot", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    ScriptState* scriptState = ScriptState::forReceiverObject(info);
    ShadowRoot* result = impl->createShadowRoot(scriptState, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, result, impl);
}

static void createShadowRootMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), currentExecutionContext(info.GetIsolate()), UseCounter::ElementCreateShadowRoot);
    ElementV8Internal::createShadowRootMethod(info);
}

static void attachShadowMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "attachShadow", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    ShadowRootInit shadowRootInitDict;
    {
        if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
            exceptionState.throwTypeError("parameter 1 ('shadowRootInitDict') is not an object.");
            exceptionState.throwIfNeeded();
            return;
        }
        V8ShadowRootInit::toImpl(info.GetIsolate(), info[0], shadowRootInitDict, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    ScriptState* scriptState = ScriptState::forReceiverObject(info);
    ShadowRoot* result = impl->attachShadow(scriptState, shadowRootInitDict, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, result, impl);
}

static void attachShadowMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), currentExecutionContext(info.GetIsolate()), UseCounter::ElementAttachShadow);
    ElementV8Internal::attachShadowMethod(info);
}

static void getDestinationInsertionPointsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Element* impl = V8Element::toImpl(info.Holder());
    v8SetReturnValueFast(info, impl->getDestinationInsertionPoints(), impl);
}

static void getDestinationInsertionPointsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::getDestinationInsertionPointsMethod(info);
}

static void requestPointerLockMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Element* impl = V8Element::toImpl(info.Holder());
    impl->requestPointerLock();
}

static void requestPointerLockMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), currentExecutionContext(info.GetIsolate()), UseCounter::ElementRequestPointerLock);
    ElementV8Internal::requestPointerLockMethod(info);
}

static void getClientRectsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Element* impl = V8Element::toImpl(info.Holder());
    v8SetReturnValueFast(info, impl->getClientRects(), impl);
}

static void getClientRectsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::getClientRectsMethod(info);
}

static void getBoundingClientRectMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Element* impl = V8Element::toImpl(info.Holder());
    v8SetReturnValueFast(info, impl->getBoundingClientRect(), impl);
}

static void getBoundingClientRectMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::getBoundingClientRectMethod(info);
}

static void scrollIntoViewMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollIntoView", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    bool alignWithTop;
    {
        int numArgsPassed = info.Length();
        while (numArgsPassed > 0) {
            if (!info[numArgsPassed - 1]->IsUndefined())
                break;
            --numArgsPassed;
        }
        if (UNLIKELY(numArgsPassed <= 0)) {
            impl->scrollIntoView();
            return;
        }
        alignWithTop = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->scrollIntoView(alignWithTop);
}

static void scrollIntoViewMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::scrollIntoViewMethod(info);
}

static void scroll1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scroll", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    ScrollToOptions options;
    {
        if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
            exceptionState.throwTypeError("parameter 1 ('options') is not an object.");
            exceptionState.throwIfNeeded();
            return;
        }
        V8ScrollToOptions::toImpl(info.GetIsolate(), info[0], options, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->scrollTo(options);
}

static void scroll2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scroll", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    double x;
    double y;
    {
        x = toDouble(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toDouble(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->scrollTo(x, y);
}

static void scrollMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scroll", "Element", info.Holder(), info.GetIsolate());
    switch (std::min(2, info.Length())) {
    case 0:
        if (true) {
            scroll1Method(info);
            return;
        }
        break;
    case 1:
        if (true) {
            scroll1Method(info);
            return;
        }
        break;
    case 2:
        if (true) {
            scroll2Method(info);
            return;
        }
        break;
    default:
        break;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void scrollMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::scrollMethod(info);
}

static void scrollTo1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollTo", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    ScrollToOptions options;
    {
        if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
            exceptionState.throwTypeError("parameter 1 ('options') is not an object.");
            exceptionState.throwIfNeeded();
            return;
        }
        V8ScrollToOptions::toImpl(info.GetIsolate(), info[0], options, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->scrollTo(options);
}

static void scrollTo2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollTo", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    double x;
    double y;
    {
        x = toDouble(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toDouble(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->scrollTo(x, y);
}

static void scrollToMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollTo", "Element", info.Holder(), info.GetIsolate());
    switch (std::min(2, info.Length())) {
    case 0:
        if (true) {
            scrollTo1Method(info);
            return;
        }
        break;
    case 1:
        if (true) {
            scrollTo1Method(info);
            return;
        }
        break;
    case 2:
        if (true) {
            scrollTo2Method(info);
            return;
        }
        break;
    default:
        break;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void scrollToMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::scrollToMethod(info);
}

static void scrollBy1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollBy", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    ScrollToOptions options;
    {
        if (!isUndefinedOrNull(info[0]) && !info[0]->IsObject()) {
            exceptionState.throwTypeError("parameter 1 ('options') is not an object.");
            exceptionState.throwIfNeeded();
            return;
        }
        V8ScrollToOptions::toImpl(info.GetIsolate(), info[0], options, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->scrollBy(options);
}

static void scrollBy2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollBy", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    double x;
    double y;
    {
        x = toDouble(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        y = toDouble(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->scrollBy(x, y);
}

static void scrollByMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollBy", "Element", info.Holder(), info.GetIsolate());
    switch (std::min(2, info.Length())) {
    case 0:
        if (true) {
            scrollBy1Method(info);
            return;
        }
        break;
    case 1:
        if (true) {
            scrollBy1Method(info);
            return;
        }
        break;
    case 2:
        if (true) {
            scrollBy2Method(info);
            return;
        }
        break;
    default:
        break;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void scrollByMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::scrollByMethod(info);
}

static void setApplyScrollMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setApplyScroll", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    ScrollStateCallback* scrollStateCallback;
    V8StringResource<> nativeScrollBehavior;
    {
        if (info.Length() <= 0 || !info[0]->IsFunction()) {
            exceptionState.throwTypeError("The callback provided as parameter 1 is not a function.");
            exceptionState.throwIfNeeded();
            return;
        }
        scrollStateCallback = V8ScrollStateCallback::create(v8::Local<v8::Function>::Cast(info[0]), ScriptState::current(info.GetIsolate()));
        nativeScrollBehavior = info[1];
        if (!nativeScrollBehavior.prepare())
            return;
        const char* validValues[] = {
            "disable-native-scroll",
            "perform-before-native-scroll",
            "perform-after-native-scroll",
        };
        if (!isValidEnum(nativeScrollBehavior, validValues, WTF_ARRAY_LENGTH(validValues), "NativeScrollBehavior", exceptionState)) {
            exceptionState.throwIfNeeded();
            return;
        }
    }
    impl->setApplyScroll(scrollStateCallback, nativeScrollBehavior);
}

static void setApplyScrollMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::setApplyScrollMethod(info);
}

static void setDistributeScrollMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "setDistributeScroll", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 2)) {
        setMinimumArityTypeError(exceptionState, 2, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    ScrollStateCallback* scrollStateCallback;
    V8StringResource<> nativeScrollBehavior;
    {
        if (info.Length() <= 0 || !info[0]->IsFunction()) {
            exceptionState.throwTypeError("The callback provided as parameter 1 is not a function.");
            exceptionState.throwIfNeeded();
            return;
        }
        scrollStateCallback = V8ScrollStateCallback::create(v8::Local<v8::Function>::Cast(info[0]), ScriptState::current(info.GetIsolate()));
        nativeScrollBehavior = info[1];
        if (!nativeScrollBehavior.prepare())
            return;
        const char* validValues[] = {
            "disable-native-scroll",
            "perform-before-native-scroll",
            "perform-after-native-scroll",
        };
        if (!isValidEnum(nativeScrollBehavior, validValues, WTF_ARRAY_LENGTH(validValues), "NativeScrollBehavior", exceptionState)) {
            exceptionState.throwIfNeeded();
            return;
        }
    }
    impl->setDistributeScroll(scrollStateCallback, nativeScrollBehavior);
}

static void setDistributeScrollMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::setDistributeScrollMethod(info);
}

static void scrollIntoViewIfNeededMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "scrollIntoViewIfNeeded", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    bool centerIfNeeded;
    {
        int numArgsPassed = info.Length();
        while (numArgsPassed > 0) {
            if (!info[numArgsPassed - 1]->IsUndefined())
                break;
            --numArgsPassed;
        }
        if (UNLIKELY(numArgsPassed <= 0)) {
            impl->scrollIntoViewIfNeeded();
            return;
        }
        centerIfNeeded = toBoolean(info.GetIsolate(), info[0], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    impl->scrollIntoViewIfNeeded(centerIfNeeded);
}

static void scrollIntoViewIfNeededMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), currentExecutionContext(info.GetIsolate()), UseCounter::ElementScrollIntoViewIfNeeded);
    ElementV8Internal::scrollIntoViewIfNeededMethod(info);
}

static void animate1Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "animate", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    DictionarySequenceOrDictionary effect;
    double timing;
    {
        int numArgsPassed = info.Length();
        while (numArgsPassed > 0) {
            if (!info[numArgsPassed - 1]->IsUndefined())
                break;
            --numArgsPassed;
        }
        V8DictionarySequenceOrDictionary::toImpl(info.GetIsolate(), info[0], effect, UnionTypeConversionMode::Nullable, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        if (UNLIKELY(numArgsPassed <= 1)) {
            ExecutionContext* executionContext = currentExecutionContext(info.GetIsolate());
            Animation* result = ElementAnimation::animate(executionContext, *impl, effect, exceptionState);
            if (exceptionState.hadException()) {
                exceptionState.throwIfNeeded();
                return;
            }
            v8SetReturnValueFast(info, result, impl);
            return;
        }
        timing = toRestrictedDouble(info.GetIsolate(), info[1], exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    ExecutionContext* executionContext = currentExecutionContext(info.GetIsolate());
    Animation* result = ElementAnimation::animate(executionContext, *impl, effect, timing, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, result, impl);
}

static void animate2Method(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "animate", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    DictionarySequenceOrDictionary effect;
    KeyframeEffectOptions timing;
    {
        V8DictionarySequenceOrDictionary::toImpl(info.GetIsolate(), info[0], effect, UnionTypeConversionMode::Nullable, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
        if (!isUndefinedOrNull(info[1]) && !info[1]->IsObject()) {
            exceptionState.throwTypeError("parameter 2 ('timing') is not an object.");
            exceptionState.throwIfNeeded();
            return;
        }
        V8KeyframeEffectOptions::toImpl(info.GetIsolate(), info[1], timing, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    ExecutionContext* executionContext = currentExecutionContext(info.GetIsolate());
    Animation* result = ElementAnimation::animate(executionContext, *impl, effect, timing, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, result, impl);
}

static void animateMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "animate", "Element", info.Holder(), info.GetIsolate());
    switch (std::min(2, info.Length())) {
    case 1:
        if (true) {
            UseCounter::countIfNotPrivateScript(info.GetIsolate(), currentExecutionContext(info.GetIsolate()), UseCounter::V8Element_Animate_Method);
            animate1Method(info);
            return;
        }
        break;
    case 2:
        if (info[1]->IsUndefined()) {
            UseCounter::countIfNotPrivateScript(info.GetIsolate(), currentExecutionContext(info.GetIsolate()), UseCounter::V8Element_Animate_Method);
            animate1Method(info);
            return;
        }
        if (info[1]->IsObject()) {
            UseCounter::countIfNotPrivateScript(info.GetIsolate(), currentExecutionContext(info.GetIsolate()), UseCounter::V8Element_Animate_Method);
            animate2Method(info);
            return;
        }
        if (true) {
            UseCounter::countIfNotPrivateScript(info.GetIsolate(), currentExecutionContext(info.GetIsolate()), UseCounter::V8Element_Animate_Method);
            animate1Method(info);
            return;
        }
        break;
    default:
        break;
    }
    if (info.Length() < 1) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(1, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    exceptionState.throwTypeError("No function was found that matched the signature provided.");
    exceptionState.throwIfNeeded();
    return;
}

static void animateMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::animateMethod(info);
}

static void getAnimationsMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Element* impl = V8Element::toImpl(info.Holder());
    v8SetReturnValue(info, toV8(ElementAnimation::getAnimations(*impl), info.Holder(), info.GetIsolate()));
}

static void getAnimationsMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::getAnimationsMethod(info);
}

static void beforeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "before", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    HeapVector<NodeOrString> nodes;
    {
        nodes = toImplArguments<HeapVector<NodeOrString>>(info, 0, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    ChildNode::before(*impl, nodes, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void beforeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::beforeMethod(info);
}

static void afterMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "after", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    HeapVector<NodeOrString> nodes;
    {
        nodes = toImplArguments<HeapVector<NodeOrString>>(info, 0, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    ChildNode::after(*impl, nodes, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void afterMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::afterMethod(info);
}

static void replaceWithMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "replaceWith", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    HeapVector<NodeOrString> nodes;
    {
        nodes = toImplArguments<HeapVector<NodeOrString>>(info, 0, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    ChildNode::replaceWith(*impl, nodes, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void replaceWithMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::replaceWithMethod(info);
}

static void removeMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "remove", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    ChildNode::remove(*impl, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void removeMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::removeMethod(info);
}

static void requestFullscreenMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Element* impl = V8Element::toImpl(info.Holder());
    ElementFullscreen::requestFullscreen(*impl);
}

static void requestFullscreenMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::requestFullscreenMethod(info);
}

static void webkitRequestFullScreenMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Element* impl = V8Element::toImpl(info.Holder());
    ElementFullscreen::webkitRequestFullscreen(*impl);
}

static void webkitRequestFullScreenMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), currentExecutionContext(info.GetIsolate()), UseCounter::PrefixedElementRequestFullScreen);
    ScriptState* scriptState = ScriptState::forReceiverObject(info);
    V8PerContextData* contextData = scriptState->perContextData();
    if (contextData && contextData->activityLogger()) {
        ExceptionState exceptionState(ExceptionState::ExecutionContext, "webkitRequestFullScreen", "Element", info.Holder(), info.GetIsolate());
        Vector<v8::Local<v8::Value>> loggerArgs = toImplArguments<Vector<v8::Local<v8::Value>>>(info, 0, exceptionState);
        contextData->activityLogger()->logMethod("Element.webkitRequestFullScreen", info.Length(), loggerArgs.data());
    }
    ElementV8Internal::webkitRequestFullScreenMethod(info);
}

static void webkitRequestFullscreenMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    Element* impl = V8Element::toImpl(info.Holder());
    ElementFullscreen::webkitRequestFullscreen(*impl);
}

static void webkitRequestFullscreenMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    UseCounter::countIfNotPrivateScript(info.GetIsolate(), currentExecutionContext(info.GetIsolate()), UseCounter::PrefixedElementRequestFullscreen);
    ScriptState* scriptState = ScriptState::forReceiverObject(info);
    V8PerContextData* contextData = scriptState->perContextData();
    if (contextData && contextData->activityLogger()) {
        ExceptionState exceptionState(ExceptionState::ExecutionContext, "webkitRequestFullscreen", "Element", info.Holder(), info.GetIsolate());
        Vector<v8::Local<v8::Value>> loggerArgs = toImplArguments<Vector<v8::Local<v8::Value>>>(info, 0, exceptionState);
        contextData->activityLogger()->logMethod("Element.webkitRequestFullscreen", info.Length(), loggerArgs.data());
    }
    ElementV8Internal::webkitRequestFullscreenMethod(info);
}

static void prependMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "prepend", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    HeapVector<NodeOrString> nodes;
    {
        nodes = toImplArguments<HeapVector<NodeOrString>>(info, 0, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    ParentNode::prepend(*impl, nodes, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void prependMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::prependMethod(info);
}

static void appendMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "append", "Element", info.Holder(), info.GetIsolate());
    Element* impl = V8Element::toImpl(info.Holder());
    V0CustomElementProcessingStack::CallbackDeliveryScope deliveryScope;
    HeapVector<NodeOrString> nodes;
    {
        nodes = toImplArguments<HeapVector<NodeOrString>>(info, 0, exceptionState);
        if (exceptionState.throwIfNeeded())
            return;
    }
    ParentNode::append(*impl, nodes, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
}

static void appendMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    CEReactionsScope ceReactionsScope;
    ElementV8Internal::appendMethod(info);
}

static void querySelectorMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "querySelector", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<> selectors;
    {
        selectors = info[0];
        if (!selectors.prepare())
            return;
    }
    Element* result = ParentNode::querySelector(*impl, selectors, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    v8SetReturnValueFast(info, result, impl);
}

static void querySelectorMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::querySelectorMethod(info);
}

static void querySelectorAllMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, "querySelectorAll", "Element", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 1)) {
        setMinimumArityTypeError(exceptionState, 1, info.Length());
        exceptionState.throwIfNeeded();
        return;
    }
    Element* impl = V8Element::toImpl(info.Holder());
    V8StringResource<> selectors;
    {
        selectors = info[0];
        if (!selectors.prepare())
            return;
    }
    NodeList* result = ParentNode::querySelectorAll(*impl, selectors, exceptionState);
    if (exceptionState.hadException()) {
        exceptionState.throwIfNeeded();
        return;
    }
    // [NewObject] must always create a new wrapper.  Check that a wrapper
    // does not exist yet.
    DCHECK(!result || DOMDataStore::getWrapper(result, info.GetIsolate()).IsEmpty());
    v8SetReturnValueFast(info, result, impl);
}

static void querySelectorAllMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ElementV8Internal::querySelectorAllMethod(info);
}

} // namespace ElementV8Internal

const V8DOMConfiguration::AccessorConfiguration V8ElementAccessors[] = {
    {"namespaceURI", ElementV8Internal::namespaceURIAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"prefix", ElementV8Internal::prefixAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"localName", ElementV8Internal::localNameAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"tagName", ElementV8Internal::tagNameAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"id", ElementV8Internal::idAttributeGetterCallback, ElementV8Internal::idAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"className", ElementV8Internal::classNameAttributeGetterCallback, ElementV8Internal::classNameAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"classList", ElementV8Internal::classListAttributeGetterCallback, ElementV8Internal::classListAttributeSetterCallback, ElementV8Internal::classListAttributeGetterCallbackForMainWorld, ElementV8Internal::classListAttributeSetterCallbackForMainWorld, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"attributes", ElementV8Internal::attributesAttributeGetterCallback, 0, ElementV8Internal::attributesAttributeGetterCallbackForMainWorld, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"innerHTML", ElementV8Internal::innerHTMLAttributeGetterCallback, ElementV8Internal::innerHTMLAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"outerHTML", ElementV8Internal::outerHTMLAttributeGetterCallback, ElementV8Internal::outerHTMLAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"shadowRoot", ElementV8Internal::shadowRootAttributeGetterCallback, 0, ElementV8Internal::shadowRootAttributeGetterCallbackForMainWorld, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"scrollTop", ElementV8Internal::scrollTopAttributeGetterCallback, ElementV8Internal::scrollTopAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"scrollLeft", ElementV8Internal::scrollLeftAttributeGetterCallback, ElementV8Internal::scrollLeftAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"scrollWidth", ElementV8Internal::scrollWidthAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"scrollHeight", ElementV8Internal::scrollHeightAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"clientTop", ElementV8Internal::clientTopAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"clientLeft", ElementV8Internal::clientLeftAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"clientWidth", ElementV8Internal::clientWidthAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"clientHeight", ElementV8Internal::clientHeightAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onbeforecopy", ElementV8Internal::onbeforecopyAttributeGetterCallback, ElementV8Internal::onbeforecopyAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onbeforecut", ElementV8Internal::onbeforecutAttributeGetterCallback, ElementV8Internal::onbeforecutAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onbeforepaste", ElementV8Internal::onbeforepasteAttributeGetterCallback, ElementV8Internal::onbeforepasteAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"oncopy", ElementV8Internal::oncopyAttributeGetterCallback, ElementV8Internal::oncopyAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"oncut", ElementV8Internal::oncutAttributeGetterCallback, ElementV8Internal::oncutAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onpaste", ElementV8Internal::onpasteAttributeGetterCallback, ElementV8Internal::onpasteAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onsearch", ElementV8Internal::onsearchAttributeGetterCallback, ElementV8Internal::onsearchAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onselectstart", ElementV8Internal::onselectstartAttributeGetterCallback, ElementV8Internal::onselectstartAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onwheel", ElementV8Internal::onwheelAttributeGetterCallback, ElementV8Internal::onwheelAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onwebkitfullscreenchange", ElementV8Internal::onwebkitfullscreenchangeAttributeGetterCallback, ElementV8Internal::onwebkitfullscreenchangeAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"onwebkitfullscreenerror", ElementV8Internal::onwebkitfullscreenerrorAttributeGetterCallback, ElementV8Internal::onwebkitfullscreenerrorAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"previousElementSibling", ElementV8Internal::previousElementSiblingAttributeGetterCallback, 0, ElementV8Internal::previousElementSiblingAttributeGetterCallbackForMainWorld, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"nextElementSibling", ElementV8Internal::nextElementSiblingAttributeGetterCallback, 0, ElementV8Internal::nextElementSiblingAttributeGetterCallbackForMainWorld, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"children", ElementV8Internal::childrenAttributeGetterCallback, 0, ElementV8Internal::childrenAttributeGetterCallbackForMainWorld, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"firstElementChild", ElementV8Internal::firstElementChildAttributeGetterCallback, 0, ElementV8Internal::firstElementChildAttributeGetterCallbackForMainWorld, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"lastElementChild", ElementV8Internal::lastElementChildAttributeGetterCallback, 0, ElementV8Internal::lastElementChildAttributeGetterCallbackForMainWorld, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
    {"childElementCount", ElementV8Internal::childElementCountAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder},
};

const V8DOMConfiguration::MethodConfiguration V8ElementMethods[] = {
    {"hasAttributes", ElementV8Internal::hasAttributesMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"getAttribute", ElementV8Internal::getAttributeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"getAttributeNS", ElementV8Internal::getAttributeNSMethodCallback, 0, 2, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"setAttribute", ElementV8Internal::setAttributeMethodCallback, 0, 2, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"setAttributeNS", ElementV8Internal::setAttributeNSMethodCallback, 0, 3, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"removeAttribute", ElementV8Internal::removeAttributeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"removeAttributeNS", ElementV8Internal::removeAttributeNSMethodCallback, 0, 2, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"hasAttribute", ElementV8Internal::hasAttributeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"hasAttributeNS", ElementV8Internal::hasAttributeNSMethodCallback, 0, 2, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"getAttributeNode", ElementV8Internal::getAttributeNodeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"getAttributeNodeNS", ElementV8Internal::getAttributeNodeNSMethodCallback, 0, 2, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"setAttributeNode", ElementV8Internal::setAttributeNodeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"setAttributeNodeNS", ElementV8Internal::setAttributeNodeNSMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"removeAttributeNode", ElementV8Internal::removeAttributeNodeMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"closest", ElementV8Internal::closestMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"matches", ElementV8Internal::matchesMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"webkitMatchesSelector", ElementV8Internal::webkitMatchesSelectorMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"getElementsByTagName", ElementV8Internal::getElementsByTagNameMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"getElementsByTagNameNS", ElementV8Internal::getElementsByTagNameNSMethodCallback, 0, 2, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"getElementsByClassName", ElementV8Internal::getElementsByClassNameMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"insertAdjacentElement", ElementV8Internal::insertAdjacentElementMethodCallback, 0, 2, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"insertAdjacentText", ElementV8Internal::insertAdjacentTextMethodCallback, 0, 2, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"insertAdjacentHTML", ElementV8Internal::insertAdjacentHTMLMethodCallback, 0, 2, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"createShadowRoot", ElementV8Internal::createShadowRootMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"getDestinationInsertionPoints", ElementV8Internal::getDestinationInsertionPointsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"requestPointerLock", ElementV8Internal::requestPointerLockMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"getClientRects", ElementV8Internal::getClientRectsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"getBoundingClientRect", ElementV8Internal::getBoundingClientRectMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"scrollIntoView", ElementV8Internal::scrollIntoViewMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"scrollIntoViewIfNeeded", ElementV8Internal::scrollIntoViewIfNeededMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"animate", ElementV8Internal::animateMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"remove", ElementV8Internal::removeMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"webkitRequestFullScreen", ElementV8Internal::webkitRequestFullScreenMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"webkitRequestFullscreen", ElementV8Internal::webkitRequestFullscreenMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"querySelector", ElementV8Internal::querySelectorMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
    {"querySelectorAll", ElementV8Internal::querySelectorAllMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype},
};

static void installV8ElementTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::FunctionTemplate> interfaceTemplate)
{
    // Initialize the interface object's template.
    V8DOMConfiguration::initializeDOMInterfaceTemplate(isolate, interfaceTemplate, V8Element::wrapperTypeInfo.interfaceName, V8Node::domTemplate(isolate, world), V8Element::internalFieldCount);
    v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interfaceTemplate);
    ALLOW_UNUSED_LOCAL(signature);
    v8::Local<v8::ObjectTemplate> instanceTemplate = interfaceTemplate->InstanceTemplate();
    ALLOW_UNUSED_LOCAL(instanceTemplate);
    v8::Local<v8::ObjectTemplate> prototypeTemplate = interfaceTemplate->PrototypeTemplate();
    ALLOW_UNUSED_LOCAL(prototypeTemplate);
    // Register DOM constants, attributes and operations.
    V8DOMConfiguration::installAccessors(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, V8ElementAccessors, WTF_ARRAY_LENGTH(V8ElementAccessors));
    V8DOMConfiguration::installMethods(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, V8ElementMethods, WTF_ARRAY_LENGTH(V8ElementMethods));

    if (RuntimeEnabledFeatures::computedAccessibilityInfoEnabled()) {
        const V8DOMConfiguration::AccessorConfiguration accessorcomputedNameConfiguration = \
        {"computedName", ElementV8Internal::computedNameAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
        V8DOMConfiguration::installAccessor(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, accessorcomputedNameConfiguration);
        const V8DOMConfiguration::AccessorConfiguration accessorcomputedRoleConfiguration = \
        {"computedRole", ElementV8Internal::computedRoleAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
        V8DOMConfiguration::installAccessor(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, accessorcomputedRoleConfiguration);
    }

    if (RuntimeEnabledFeatures::pointerEventEnabled()) {
        const V8DOMConfiguration::AccessorConfiguration accessorongotpointercaptureConfiguration = \
        {"ongotpointercapture", ElementV8Internal::ongotpointercaptureAttributeGetterCallback, ElementV8Internal::ongotpointercaptureAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
        V8DOMConfiguration::installAccessor(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, accessorongotpointercaptureConfiguration);
        const V8DOMConfiguration::AccessorConfiguration accessoronlostpointercaptureConfiguration = \
        {"onlostpointercapture", ElementV8Internal::onlostpointercaptureAttributeGetterCallback, ElementV8Internal::onlostpointercaptureAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
        V8DOMConfiguration::installAccessor(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, accessoronlostpointercaptureConfiguration);
    }

    if (RuntimeEnabledFeatures::shadowDOMV1Enabled()) {
        const V8DOMConfiguration::AccessorConfiguration accessorassignedSlotConfiguration = \
        {"assignedSlot", ElementV8Internal::assignedSlotAttributeGetterCallback, 0, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::ReadOnly), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
        V8DOMConfiguration::installAccessor(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, accessorassignedSlotConfiguration);
        const V8DOMConfiguration::AccessorConfiguration accessorslotConfiguration = \
        {"slot", ElementV8Internal::slotAttributeGetterCallback, ElementV8Internal::slotAttributeSetterCallback, 0, 0, 0, v8::DEFAULT, static_cast<v8::PropertyAttribute>(v8::None), V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype, V8DOMConfiguration::CheckHolder};
        V8DOMConfiguration::installAccessor(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, accessorslotConfiguration);
    }

    if (RuntimeEnabledFeatures::pointerEventEnabled()) {
        const V8DOMConfiguration::MethodConfiguration setPointerCaptureMethodConfiguration = {"setPointerCapture", ElementV8Internal::setPointerCaptureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, setPointerCaptureMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::pointerEventEnabled()) {
        const V8DOMConfiguration::MethodConfiguration releasePointerCaptureMethodConfiguration = {"releasePointerCapture", ElementV8Internal::releasePointerCaptureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, releasePointerCaptureMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::pointerEventEnabled()) {
        const V8DOMConfiguration::MethodConfiguration hasPointerCaptureMethodConfiguration = {"hasPointerCapture", ElementV8Internal::hasPointerCaptureMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, hasPointerCaptureMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::shadowDOMV1Enabled()) {
        const V8DOMConfiguration::MethodConfiguration attachShadowMethodConfiguration = {"attachShadow", ElementV8Internal::attachShadowMethodCallback, 0, 1, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, attachShadowMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::cssomSmoothScrollEnabled()) {
        const V8DOMConfiguration::MethodConfiguration scrollMethodConfiguration = {"scroll", ElementV8Internal::scrollMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, scrollMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::cssomSmoothScrollEnabled()) {
        const V8DOMConfiguration::MethodConfiguration scrollToMethodConfiguration = {"scrollTo", ElementV8Internal::scrollToMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, scrollToMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::cssomSmoothScrollEnabled()) {
        const V8DOMConfiguration::MethodConfiguration scrollByMethodConfiguration = {"scrollBy", ElementV8Internal::scrollByMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, scrollByMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::scrollCustomizationEnabled()) {
        const V8DOMConfiguration::MethodConfiguration setApplyScrollMethodConfiguration = {"setApplyScroll", ElementV8Internal::setApplyScrollMethodCallback, 0, 2, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, setApplyScrollMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::scrollCustomizationEnabled()) {
        const V8DOMConfiguration::MethodConfiguration setDistributeScrollMethodConfiguration = {"setDistributeScroll", ElementV8Internal::setDistributeScrollMethodCallback, 0, 2, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, setDistributeScrollMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::webAnimationsAPIEnabled()) {
        const V8DOMConfiguration::MethodConfiguration getAnimationsMethodConfiguration = {"getAnimations", ElementV8Internal::getAnimationsMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, getAnimationsMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
        const V8DOMConfiguration::MethodConfiguration beforeMethodConfiguration = {"before", ElementV8Internal::beforeMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, beforeMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
        const V8DOMConfiguration::MethodConfiguration afterMethodConfiguration = {"after", ElementV8Internal::afterMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, afterMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
        const V8DOMConfiguration::MethodConfiguration replaceWithMethodConfiguration = {"replaceWith", ElementV8Internal::replaceWithMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, replaceWithMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::fullscreenUnprefixedEnabled()) {
        const V8DOMConfiguration::MethodConfiguration requestFullscreenMethodConfiguration = {"requestFullscreen", ElementV8Internal::requestFullscreenMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, requestFullscreenMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
        const V8DOMConfiguration::MethodConfiguration prependMethodConfiguration = {"prepend", ElementV8Internal::prependMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, prependMethodConfiguration);
    }
    if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
        const V8DOMConfiguration::MethodConfiguration appendMethodConfiguration = {"append", ElementV8Internal::appendMethodCallback, 0, 0, v8::None, V8DOMConfiguration::ExposedToAllScripts, V8DOMConfiguration::OnPrototype};
        V8DOMConfiguration::installMethod(isolate, world, instanceTemplate, prototypeTemplate, interfaceTemplate, signature, appendMethodConfiguration);
    }
}

v8::Local<v8::FunctionTemplate> V8Element::domTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world)
{
    return V8DOMConfiguration::domClassTemplate(isolate, world, const_cast<WrapperTypeInfo*>(&wrapperTypeInfo), installV8ElementTemplate);
}

bool V8Element::hasInstance(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->hasInstance(&wrapperTypeInfo, v8Value);
}

v8::Local<v8::Object> V8Element::findInstanceInPrototypeChain(v8::Local<v8::Value> v8Value, v8::Isolate* isolate)
{
    return V8PerIsolateData::from(isolate)->findInstanceInPrototypeChain(&wrapperTypeInfo, v8Value);
}

Element* V8Element::toImplWithTypeCheck(v8::Isolate* isolate, v8::Local<v8::Value> value)
{
    return hasInstance(value, isolate) ? toImpl(v8::Local<v8::Object>::Cast(value)) : nullptr;
}

void V8Element::preparePrototypeAndInterfaceObject(v8::Local<v8::Context> context, const DOMWrapperWorld& world, v8::Local<v8::Object> prototypeObject, v8::Local<v8::Function> interfaceObject, v8::Local<v8::FunctionTemplate> interfaceTemplate)
{
    v8::Isolate* isolate = context->GetIsolate();
    v8::Local<v8::Name> unscopablesSymbol(v8::Symbol::GetUnscopables(isolate));
    v8::Local<v8::Object> unscopeables;
    if (v8CallBoolean(prototypeObject->HasOwnProperty(context, unscopablesSymbol)))
        unscopeables = prototypeObject->Get(context, unscopablesSymbol).ToLocalChecked().As<v8::Object>();
    else
        unscopeables = v8::Object::New(isolate);
    if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
        unscopeables->CreateDataProperty(context, v8AtomicString(isolate, "after"), v8::True(isolate)).FromJust();
    }
    if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
        unscopeables->CreateDataProperty(context, v8AtomicString(isolate, "append"), v8::True(isolate)).FromJust();
    }
    if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
        unscopeables->CreateDataProperty(context, v8AtomicString(isolate, "before"), v8::True(isolate)).FromJust();
    }
    if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
        unscopeables->CreateDataProperty(context, v8AtomicString(isolate, "prepend"), v8::True(isolate)).FromJust();
    }
    unscopeables->CreateDataProperty(context, v8AtomicString(isolate, "remove"), v8::True(isolate)).FromJust();
    if (RuntimeEnabledFeatures::dOMConvenienceAPIEnabled()) {
        unscopeables->CreateDataProperty(context, v8AtomicString(isolate, "replaceWith"), v8::True(isolate)).FromJust();
    }
    prototypeObject->CreateDataProperty(context, unscopablesSymbol, unscopeables).FromJust();
}

} // namespace blink
