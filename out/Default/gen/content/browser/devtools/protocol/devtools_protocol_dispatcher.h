// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// THIS FILE IS AUTOGENERATED. DO NOT EDIT.
// Generated by
//  content/public/browser/devtools_protocol_handler_generator.py from
//  gen/blink/core/inspector/protocol.json and

#ifndef CONTENT_BROWSER_DEVTOOLS_PROTOCOL_DEVTOOLS_PROTOCOL_DISPATCHER_H_
#define CONTENT_BROWSER_DEVTOOLS_PROTOCOL_DEVTOOLS_PROTOCOL_DISPATCHER_H_

#include <utility>

#include "base/memory/ptr_util.h"
#include "content/browser/devtools/protocol/devtools_protocol_client.h"

namespace content {

class DevToolsProtocolDispatcher;

namespace devtools {

extern const char kProtocolVersion[];

bool IsSupportedProtocolVersion(const std::string& version);

template<typename T>
base::Value* CreateValue(const T& param) {
  return new base::FundamentalValue(param);
}

template<class T>
base::Value* CreateValue(std::unique_ptr<T>& param) {
  return param.release();
}

template<class T>
base::Value* CreateValue(scoped_refptr<T> param) {
  return param->ToValue().release();
}

template<typename T>
base::Value* CreateValue(const std::vector<T> param) {
  base::ListValue* result = new base::ListValue();
  for (auto& item : param) {
    result->Append(CreateValue(item));
  }
  return result;
}

template<>
base::Value* CreateValue(const std::string& param);

namespace inspector {
template<int MASK>
struct DetachedParamsBuilder
    : base::RefCounted<DetachedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kReason = 1 << 0,
    kNoneSet = kReason
  };

  scoped_refptr<DetachedParamsBuilder<MASK & ~kReason>>
  set_reason(const std::string& reason) {
    static_assert(MASK & kReason, "already set");
    dict_->Set("reason", CreateValue(reason));
    return ThisAs<DetachedParamsBuilder<MASK & ~kReason>>();
  }

  static scoped_refptr<DetachedParamsBuilder<kNoneSet>> Create() {
    return new DetachedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct DetachedParamsBuilder<0>;
  friend class base::RefCounted<DetachedParamsBuilder<MASK>>;
  ~DetachedParamsBuilder() {}

  DetachedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef DetachedParamsBuilder<0> DetachedParams;

}  // namespace inspector

namespace inspector {
template<int MASK>
struct TargetCrashedParamsBuilder
    : base::RefCounted<TargetCrashedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };


  static scoped_refptr<TargetCrashedParamsBuilder<kNoneSet>> Create() {
    return new TargetCrashedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct TargetCrashedParamsBuilder<0>;
  friend class base::RefCounted<TargetCrashedParamsBuilder<MASK>>;
  ~TargetCrashedParamsBuilder() {}

  TargetCrashedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef TargetCrashedParamsBuilder<0> TargetCrashedParams;

}  // namespace inspector

namespace inspector {
class InspectorHandler;
}  // namespace domain

namespace inspector {
class Client : public DevToolsProtocolClient {
 public:
  explicit Client(DevToolsProtocolDelegate* notifier);
  ~Client() override;

  void Detached(
      scoped_refptr<DetachedParams> params);
  void TargetCrashed(
      scoped_refptr<TargetCrashedParams> params);
};
}  // namespace inspector

namespace memory {
extern const char kPressureLevelModerate[];
extern const char kPressureLevelCritical[];
}  // namespace memory

namespace memory {
typedef std::string PressureLevel;
}  // namespace memory

namespace memory {
class MemoryHandler;
}  // namespace domain

namespace page {
typedef std::string FrameId;
}  // namespace page

namespace page {
template<int MASK>
struct NavigationEntryBuilder
    : base::RefCounted<NavigationEntryBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kId = 1 << 0,
    kUrl = 1 << 1,
    kTitle = 1 << 2,
    kNoneSet = kId | kUrl | kTitle
  };

  scoped_refptr<NavigationEntryBuilder<MASK & ~kId>>
  set_id(int id) {
    static_assert(MASK & kId, "already set");
    dict_->Set("id", CreateValue(id));
    return ThisAs<NavigationEntryBuilder<MASK & ~kId>>();
  }

  scoped_refptr<NavigationEntryBuilder<MASK & ~kUrl>>
  set_url(const std::string& url) {
    static_assert(MASK & kUrl, "already set");
    dict_->Set("url", CreateValue(url));
    return ThisAs<NavigationEntryBuilder<MASK & ~kUrl>>();
  }

  scoped_refptr<NavigationEntryBuilder<MASK & ~kTitle>>
  set_title(const std::string& title) {
    static_assert(MASK & kTitle, "already set");
    dict_->Set("title", CreateValue(title));
    return ThisAs<NavigationEntryBuilder<MASK & ~kTitle>>();
  }

  static scoped_refptr<NavigationEntryBuilder<kNoneSet>> Create() {
    return new NavigationEntryBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct NavigationEntryBuilder<0>;
  friend class base::RefCounted<NavigationEntryBuilder<MASK>>;
  ~NavigationEntryBuilder() {}

  NavigationEntryBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef NavigationEntryBuilder<0> NavigationEntry;

}  // namespace page

namespace page {
template<int MASK>
struct CaptureScreenshotResponseBuilder
    : base::RefCounted<CaptureScreenshotResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kData = 1 << 0,
    kNoneSet = kData
  };

  scoped_refptr<CaptureScreenshotResponseBuilder<MASK & ~kData>>
  set_data(const std::string& data) {
    static_assert(MASK & kData, "already set");
    dict_->Set("data", CreateValue(data));
    return ThisAs<CaptureScreenshotResponseBuilder<MASK & ~kData>>();
  }

  static scoped_refptr<CaptureScreenshotResponseBuilder<kNoneSet>> Create() {
    return new CaptureScreenshotResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct CaptureScreenshotResponseBuilder<0>;
  friend class base::RefCounted<CaptureScreenshotResponseBuilder<MASK>>;
  ~CaptureScreenshotResponseBuilder() {}

  CaptureScreenshotResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef CaptureScreenshotResponseBuilder<0> CaptureScreenshotResponse;

}  // namespace page

namespace page {
namespace start_screencast {
extern const char kFormatJpeg[];
extern const char kFormatPng[];
}  // namespace start_screencast
}  // namespace page

namespace page {
extern const char kNavigationResponseProceed[];
extern const char kNavigationResponseCancel[];
extern const char kNavigationResponseCancelAndIgnore[];
}  // namespace page

namespace page {
typedef std::string NavigationResponse;
}  // namespace page

namespace page {
template<int MASK>
struct ScreencastFrameMetadataBuilder
    : base::RefCounted<ScreencastFrameMetadataBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kOffsetTop = 1 << 0,
    kPageScaleFactor = 1 << 1,
    kDeviceWidth = 1 << 2,
    kDeviceHeight = 1 << 3,
    kScrollOffsetX = 1 << 4,
    kScrollOffsetY = 1 << 5,
    kNoneSet = kOffsetTop | kPageScaleFactor | kDeviceWidth | kDeviceHeight | kScrollOffsetX | kScrollOffsetY
  };

  scoped_refptr<ScreencastFrameMetadataBuilder<MASK & ~kOffsetTop>>
  set_offset_top(double offset_top) {
    static_assert(MASK & kOffsetTop, "already set");
    dict_->Set("offsetTop", CreateValue(offset_top));
    return ThisAs<ScreencastFrameMetadataBuilder<MASK & ~kOffsetTop>>();
  }

  scoped_refptr<ScreencastFrameMetadataBuilder<MASK & ~kPageScaleFactor>>
  set_page_scale_factor(double page_scale_factor) {
    static_assert(MASK & kPageScaleFactor, "already set");
    dict_->Set("pageScaleFactor", CreateValue(page_scale_factor));
    return ThisAs<ScreencastFrameMetadataBuilder<MASK & ~kPageScaleFactor>>();
  }

  scoped_refptr<ScreencastFrameMetadataBuilder<MASK & ~kDeviceWidth>>
  set_device_width(double device_width) {
    static_assert(MASK & kDeviceWidth, "already set");
    dict_->Set("deviceWidth", CreateValue(device_width));
    return ThisAs<ScreencastFrameMetadataBuilder<MASK & ~kDeviceWidth>>();
  }

  scoped_refptr<ScreencastFrameMetadataBuilder<MASK & ~kDeviceHeight>>
  set_device_height(double device_height) {
    static_assert(MASK & kDeviceHeight, "already set");
    dict_->Set("deviceHeight", CreateValue(device_height));
    return ThisAs<ScreencastFrameMetadataBuilder<MASK & ~kDeviceHeight>>();
  }

  scoped_refptr<ScreencastFrameMetadataBuilder<MASK & ~kScrollOffsetX>>
  set_scroll_offset_x(double scroll_offset_x) {
    static_assert(MASK & kScrollOffsetX, "already set");
    dict_->Set("scrollOffsetX", CreateValue(scroll_offset_x));
    return ThisAs<ScreencastFrameMetadataBuilder<MASK & ~kScrollOffsetX>>();
  }

  scoped_refptr<ScreencastFrameMetadataBuilder<MASK & ~kScrollOffsetY>>
  set_scroll_offset_y(double scroll_offset_y) {
    static_assert(MASK & kScrollOffsetY, "already set");
    dict_->Set("scrollOffsetY", CreateValue(scroll_offset_y));
    return ThisAs<ScreencastFrameMetadataBuilder<MASK & ~kScrollOffsetY>>();
  }

  scoped_refptr<ScreencastFrameMetadataBuilder<MASK>>
  set_timestamp(double timestamp) {
    dict_->Set("timestamp", CreateValue(timestamp));
    return this;
  }

  static scoped_refptr<ScreencastFrameMetadataBuilder<kNoneSet>> Create() {
    return new ScreencastFrameMetadataBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct ScreencastFrameMetadataBuilder<0>;
  friend class base::RefCounted<ScreencastFrameMetadataBuilder<MASK>>;
  ~ScreencastFrameMetadataBuilder() {}

  ScreencastFrameMetadataBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef ScreencastFrameMetadataBuilder<0> ScreencastFrameMetadata;

}  // namespace page

namespace page {
template<int MASK>
struct ScreencastFrameParamsBuilder
    : base::RefCounted<ScreencastFrameParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kData = 1 << 0,
    kMetadata = 1 << 1,
    kSessionId = 1 << 2,
    kNoneSet = kData | kMetadata | kSessionId
  };

  scoped_refptr<ScreencastFrameParamsBuilder<MASK & ~kData>>
  set_data(const std::string& data) {
    static_assert(MASK & kData, "already set");
    dict_->Set("data", CreateValue(data));
    return ThisAs<ScreencastFrameParamsBuilder<MASK & ~kData>>();
  }

  scoped_refptr<ScreencastFrameParamsBuilder<MASK & ~kMetadata>>
  set_metadata(scoped_refptr<devtools::page::ScreencastFrameMetadata> metadata) {
    static_assert(MASK & kMetadata, "already set");
    dict_->Set("metadata", CreateValue(metadata));
    return ThisAs<ScreencastFrameParamsBuilder<MASK & ~kMetadata>>();
  }

  scoped_refptr<ScreencastFrameParamsBuilder<MASK & ~kSessionId>>
  set_session_id(int session_id) {
    static_assert(MASK & kSessionId, "already set");
    dict_->Set("sessionId", CreateValue(session_id));
    return ThisAs<ScreencastFrameParamsBuilder<MASK & ~kSessionId>>();
  }

  static scoped_refptr<ScreencastFrameParamsBuilder<kNoneSet>> Create() {
    return new ScreencastFrameParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct ScreencastFrameParamsBuilder<0>;
  friend class base::RefCounted<ScreencastFrameParamsBuilder<MASK>>;
  ~ScreencastFrameParamsBuilder() {}

  ScreencastFrameParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef ScreencastFrameParamsBuilder<0> ScreencastFrameParams;

}  // namespace page

namespace page {
template<int MASK>
struct ScreencastVisibilityChangedParamsBuilder
    : base::RefCounted<ScreencastVisibilityChangedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kVisible = 1 << 0,
    kNoneSet = kVisible
  };

  scoped_refptr<ScreencastVisibilityChangedParamsBuilder<MASK & ~kVisible>>
  set_visible(bool visible) {
    static_assert(MASK & kVisible, "already set");
    dict_->Set("visible", CreateValue(visible));
    return ThisAs<ScreencastVisibilityChangedParamsBuilder<MASK & ~kVisible>>();
  }

  static scoped_refptr<ScreencastVisibilityChangedParamsBuilder<kNoneSet>> Create() {
    return new ScreencastVisibilityChangedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct ScreencastVisibilityChangedParamsBuilder<0>;
  friend class base::RefCounted<ScreencastVisibilityChangedParamsBuilder<MASK>>;
  ~ScreencastVisibilityChangedParamsBuilder() {}

  ScreencastVisibilityChangedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef ScreencastVisibilityChangedParamsBuilder<0> ScreencastVisibilityChangedParams;

}  // namespace page

namespace dom {
template<int MASK>
struct RGBABuilder
    : base::RefCounted<RGBABuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kR = 1 << 0,
    kG = 1 << 1,
    kB = 1 << 2,
    kNoneSet = kR | kG | kB
  };

  scoped_refptr<RGBABuilder<MASK & ~kR>>
  set_r(int r) {
    static_assert(MASK & kR, "already set");
    dict_->Set("r", CreateValue(r));
    return ThisAs<RGBABuilder<MASK & ~kR>>();
  }

  scoped_refptr<RGBABuilder<MASK & ~kG>>
  set_g(int g) {
    static_assert(MASK & kG, "already set");
    dict_->Set("g", CreateValue(g));
    return ThisAs<RGBABuilder<MASK & ~kG>>();
  }

  scoped_refptr<RGBABuilder<MASK & ~kB>>
  set_b(int b) {
    static_assert(MASK & kB, "already set");
    dict_->Set("b", CreateValue(b));
    return ThisAs<RGBABuilder<MASK & ~kB>>();
  }

  scoped_refptr<RGBABuilder<MASK>>
  set_a(double a) {
    dict_->Set("a", CreateValue(a));
    return this;
  }

  static scoped_refptr<RGBABuilder<kNoneSet>> Create() {
    return new RGBABuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct RGBABuilder<0>;
  friend class base::RefCounted<RGBABuilder<MASK>>;
  ~RGBABuilder() {}

  RGBABuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef RGBABuilder<0> RGBA;

}  // namespace dom

namespace page {
template<int MASK>
struct ColorPickedParamsBuilder
    : base::RefCounted<ColorPickedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kColor = 1 << 0,
    kNoneSet = kColor
  };

  scoped_refptr<ColorPickedParamsBuilder<MASK & ~kColor>>
  set_color(scoped_refptr<devtools::dom::RGBA> color) {
    static_assert(MASK & kColor, "already set");
    dict_->Set("color", CreateValue(color));
    return ThisAs<ColorPickedParamsBuilder<MASK & ~kColor>>();
  }

  static scoped_refptr<ColorPickedParamsBuilder<kNoneSet>> Create() {
    return new ColorPickedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct ColorPickedParamsBuilder<0>;
  friend class base::RefCounted<ColorPickedParamsBuilder<MASK>>;
  ~ColorPickedParamsBuilder() {}

  ColorPickedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef ColorPickedParamsBuilder<0> ColorPickedParams;

}  // namespace page

namespace page {
template<int MASK>
struct InterstitialShownParamsBuilder
    : base::RefCounted<InterstitialShownParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };


  static scoped_refptr<InterstitialShownParamsBuilder<kNoneSet>> Create() {
    return new InterstitialShownParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct InterstitialShownParamsBuilder<0>;
  friend class base::RefCounted<InterstitialShownParamsBuilder<MASK>>;
  ~InterstitialShownParamsBuilder() {}

  InterstitialShownParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef InterstitialShownParamsBuilder<0> InterstitialShownParams;

}  // namespace page

namespace page {
template<int MASK>
struct InterstitialHiddenParamsBuilder
    : base::RefCounted<InterstitialHiddenParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };


  static scoped_refptr<InterstitialHiddenParamsBuilder<kNoneSet>> Create() {
    return new InterstitialHiddenParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct InterstitialHiddenParamsBuilder<0>;
  friend class base::RefCounted<InterstitialHiddenParamsBuilder<MASK>>;
  ~InterstitialHiddenParamsBuilder() {}

  InterstitialHiddenParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef InterstitialHiddenParamsBuilder<0> InterstitialHiddenParams;

}  // namespace page

namespace page {
template<int MASK>
struct NavigationRequestedParamsBuilder
    : base::RefCounted<NavigationRequestedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kIsInMainFrame = 1 << 0,
    kIsRedirect = 1 << 1,
    kNavigationId = 1 << 2,
    kUrl = 1 << 3,
    kNoneSet = kIsInMainFrame | kIsRedirect | kNavigationId | kUrl
  };

  scoped_refptr<NavigationRequestedParamsBuilder<MASK & ~kIsInMainFrame>>
  set_is_in_main_frame(bool is_in_main_frame) {
    static_assert(MASK & kIsInMainFrame, "already set");
    dict_->Set("isInMainFrame", CreateValue(is_in_main_frame));
    return ThisAs<NavigationRequestedParamsBuilder<MASK & ~kIsInMainFrame>>();
  }

  scoped_refptr<NavigationRequestedParamsBuilder<MASK & ~kIsRedirect>>
  set_is_redirect(bool is_redirect) {
    static_assert(MASK & kIsRedirect, "already set");
    dict_->Set("isRedirect", CreateValue(is_redirect));
    return ThisAs<NavigationRequestedParamsBuilder<MASK & ~kIsRedirect>>();
  }

  scoped_refptr<NavigationRequestedParamsBuilder<MASK & ~kNavigationId>>
  set_navigation_id(int navigation_id) {
    static_assert(MASK & kNavigationId, "already set");
    dict_->Set("navigationId", CreateValue(navigation_id));
    return ThisAs<NavigationRequestedParamsBuilder<MASK & ~kNavigationId>>();
  }

  scoped_refptr<NavigationRequestedParamsBuilder<MASK & ~kUrl>>
  set_url(const std::string& url) {
    static_assert(MASK & kUrl, "already set");
    dict_->Set("url", CreateValue(url));
    return ThisAs<NavigationRequestedParamsBuilder<MASK & ~kUrl>>();
  }

  static scoped_refptr<NavigationRequestedParamsBuilder<kNoneSet>> Create() {
    return new NavigationRequestedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct NavigationRequestedParamsBuilder<0>;
  friend class base::RefCounted<NavigationRequestedParamsBuilder<MASK>>;
  ~NavigationRequestedParamsBuilder() {}

  NavigationRequestedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef NavigationRequestedParamsBuilder<0> NavigationRequestedParams;

}  // namespace page

namespace page {
class PageHandler;
}  // namespace domain

namespace page {
class Client : public DevToolsProtocolClient {
 public:
  explicit Client(DevToolsProtocolDelegate* notifier);
  ~Client() override;

  void SendCaptureScreenshotResponse(
      DevToolsCommandId command_id,
      scoped_refptr<CaptureScreenshotResponse> params);
  void ScreencastFrame(
      scoped_refptr<ScreencastFrameParams> params);
  void ScreencastVisibilityChanged(
      scoped_refptr<ScreencastVisibilityChangedParams> params);
  void ColorPicked(
      scoped_refptr<ColorPickedParams> params);
  void InterstitialShown(
      scoped_refptr<InterstitialShownParams> params);
  void InterstitialHidden(
      scoped_refptr<InterstitialHiddenParams> params);
  void NavigationRequested(
      scoped_refptr<NavigationRequestedParams> params);
};
}  // namespace page

namespace emulation {
namespace screen_orientation {
extern const char kTypePortraitPrimary[];
extern const char kTypePortraitSecondary[];
extern const char kTypeLandscapePrimary[];
extern const char kTypeLandscapeSecondary[];
}  // namespace screen_orientation
}  // namespace emulation

namespace emulation {
template<int MASK>
struct ScreenOrientationBuilder
    : base::RefCounted<ScreenOrientationBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kType = 1 << 0,
    kAngle = 1 << 1,
    kNoneSet = kType | kAngle
  };

  scoped_refptr<ScreenOrientationBuilder<MASK & ~kType>>
  set_type(const std::string& type) {
    static_assert(MASK & kType, "already set");
    dict_->Set("type", CreateValue(type));
    return ThisAs<ScreenOrientationBuilder<MASK & ~kType>>();
  }

  scoped_refptr<ScreenOrientationBuilder<MASK & ~kAngle>>
  set_angle(int angle) {
    static_assert(MASK & kAngle, "already set");
    dict_->Set("angle", CreateValue(angle));
    return ThisAs<ScreenOrientationBuilder<MASK & ~kAngle>>();
  }

  static scoped_refptr<ScreenOrientationBuilder<kNoneSet>> Create() {
    return new ScreenOrientationBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct ScreenOrientationBuilder<0>;
  friend class base::RefCounted<ScreenOrientationBuilder<MASK>>;
  ~ScreenOrientationBuilder() {}

  ScreenOrientationBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef ScreenOrientationBuilder<0> ScreenOrientation;

}  // namespace emulation

namespace emulation {
namespace set_touch_emulation_enabled {
extern const char kConfigurationMobile[];
extern const char kConfigurationDesktop[];
}  // namespace set_touch_emulation_enabled
}  // namespace emulation

namespace emulation {
class EmulationHandler;
}  // namespace domain

namespace security {
extern const char kSecurityStateUnknown[];
extern const char kSecurityStateNeutral[];
extern const char kSecurityStateInsecure[];
extern const char kSecurityStateWarning[];
extern const char kSecurityStateSecure[];
extern const char kSecurityStateInfo[];
}  // namespace security

namespace security {
typedef std::string SecurityState;
}  // namespace security

namespace security {
typedef int CertificateId;
}  // namespace security

namespace security {
template<int MASK>
struct SecurityStateExplanationBuilder
    : base::RefCounted<SecurityStateExplanationBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kSecurityState = 1 << 0,
    kSummary = 1 << 1,
    kDescription = 1 << 2,
    kNoneSet = kSecurityState | kSummary | kDescription
  };

  scoped_refptr<SecurityStateExplanationBuilder<MASK & ~kSecurityState>>
  set_security_state(const std::string& security_state) {
    static_assert(MASK & kSecurityState, "already set");
    dict_->Set("securityState", CreateValue(security_state));
    return ThisAs<SecurityStateExplanationBuilder<MASK & ~kSecurityState>>();
  }

  scoped_refptr<SecurityStateExplanationBuilder<MASK & ~kSummary>>
  set_summary(const std::string& summary) {
    static_assert(MASK & kSummary, "already set");
    dict_->Set("summary", CreateValue(summary));
    return ThisAs<SecurityStateExplanationBuilder<MASK & ~kSummary>>();
  }

  scoped_refptr<SecurityStateExplanationBuilder<MASK & ~kDescription>>
  set_description(const std::string& description) {
    static_assert(MASK & kDescription, "already set");
    dict_->Set("description", CreateValue(description));
    return ThisAs<SecurityStateExplanationBuilder<MASK & ~kDescription>>();
  }

  scoped_refptr<SecurityStateExplanationBuilder<MASK>>
  set_certificate_id(int certificate_id) {
    dict_->Set("certificateId", CreateValue(certificate_id));
    return this;
  }

  static scoped_refptr<SecurityStateExplanationBuilder<kNoneSet>> Create() {
    return new SecurityStateExplanationBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct SecurityStateExplanationBuilder<0>;
  friend class base::RefCounted<SecurityStateExplanationBuilder<MASK>>;
  ~SecurityStateExplanationBuilder() {}

  SecurityStateExplanationBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef SecurityStateExplanationBuilder<0> SecurityStateExplanation;

}  // namespace security

namespace security {
template<int MASK>
struct MixedContentStatusBuilder
    : base::RefCounted<MixedContentStatusBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kRanInsecureContent = 1 << 0,
    kDisplayedInsecureContent = 1 << 1,
    kRanInsecureContentStyle = 1 << 2,
    kDisplayedInsecureContentStyle = 1 << 3,
    kNoneSet = kRanInsecureContent | kDisplayedInsecureContent | kRanInsecureContentStyle | kDisplayedInsecureContentStyle
  };

  scoped_refptr<MixedContentStatusBuilder<MASK & ~kRanInsecureContent>>
  set_ran_insecure_content(bool ran_insecure_content) {
    static_assert(MASK & kRanInsecureContent, "already set");
    dict_->Set("ranInsecureContent", CreateValue(ran_insecure_content));
    return ThisAs<MixedContentStatusBuilder<MASK & ~kRanInsecureContent>>();
  }

  scoped_refptr<MixedContentStatusBuilder<MASK & ~kDisplayedInsecureContent>>
  set_displayed_insecure_content(bool displayed_insecure_content) {
    static_assert(MASK & kDisplayedInsecureContent, "already set");
    dict_->Set("displayedInsecureContent", CreateValue(displayed_insecure_content));
    return ThisAs<MixedContentStatusBuilder<MASK & ~kDisplayedInsecureContent>>();
  }

  scoped_refptr<MixedContentStatusBuilder<MASK & ~kRanInsecureContentStyle>>
  set_ran_insecure_content_style(const std::string& ran_insecure_content_style) {
    static_assert(MASK & kRanInsecureContentStyle, "already set");
    dict_->Set("ranInsecureContentStyle", CreateValue(ran_insecure_content_style));
    return ThisAs<MixedContentStatusBuilder<MASK & ~kRanInsecureContentStyle>>();
  }

  scoped_refptr<MixedContentStatusBuilder<MASK & ~kDisplayedInsecureContentStyle>>
  set_displayed_insecure_content_style(const std::string& displayed_insecure_content_style) {
    static_assert(MASK & kDisplayedInsecureContentStyle, "already set");
    dict_->Set("displayedInsecureContentStyle", CreateValue(displayed_insecure_content_style));
    return ThisAs<MixedContentStatusBuilder<MASK & ~kDisplayedInsecureContentStyle>>();
  }

  static scoped_refptr<MixedContentStatusBuilder<kNoneSet>> Create() {
    return new MixedContentStatusBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct MixedContentStatusBuilder<0>;
  friend class base::RefCounted<MixedContentStatusBuilder<MASK>>;
  ~MixedContentStatusBuilder() {}

  MixedContentStatusBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef MixedContentStatusBuilder<0> MixedContentStatus;

}  // namespace security

namespace security {
template<int MASK>
struct SecurityStateChangedParamsBuilder
    : base::RefCounted<SecurityStateChangedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kSecurityState = 1 << 0,
    kNoneSet = kSecurityState
  };

  scoped_refptr<SecurityStateChangedParamsBuilder<MASK & ~kSecurityState>>
  set_security_state(const std::string& security_state) {
    static_assert(MASK & kSecurityState, "already set");
    dict_->Set("securityState", CreateValue(security_state));
    return ThisAs<SecurityStateChangedParamsBuilder<MASK & ~kSecurityState>>();
  }

  scoped_refptr<SecurityStateChangedParamsBuilder<MASK>>
  set_explanations(const std::vector<scoped_refptr<devtools::security::SecurityStateExplanation>>& explanations) {
    dict_->Set("explanations", CreateValue(explanations));
    return this;
  }

  scoped_refptr<SecurityStateChangedParamsBuilder<MASK>>
  set_mixed_content_status(scoped_refptr<devtools::security::MixedContentStatus> mixed_content_status) {
    dict_->Set("mixedContentStatus", CreateValue(mixed_content_status));
    return this;
  }

  scoped_refptr<SecurityStateChangedParamsBuilder<MASK>>
  set_scheme_is_cryptographic(bool scheme_is_cryptographic) {
    dict_->Set("schemeIsCryptographic", CreateValue(scheme_is_cryptographic));
    return this;
  }

  static scoped_refptr<SecurityStateChangedParamsBuilder<kNoneSet>> Create() {
    return new SecurityStateChangedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct SecurityStateChangedParamsBuilder<0>;
  friend class base::RefCounted<SecurityStateChangedParamsBuilder<MASK>>;
  ~SecurityStateChangedParamsBuilder() {}

  SecurityStateChangedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef SecurityStateChangedParamsBuilder<0> SecurityStateChangedParams;

}  // namespace security

namespace security {
class SecurityHandler;
}  // namespace domain

namespace security {
class Client : public DevToolsProtocolClient {
 public:
  explicit Client(DevToolsProtocolDelegate* notifier);
  ~Client() override;

  void SecurityStateChanged(
      scoped_refptr<SecurityStateChangedParams> params);
};
}  // namespace security

namespace network {
extern const char kCookieSameSiteStrict[];
extern const char kCookieSameSiteLax[];
}  // namespace network

namespace network {
typedef std::string CookieSameSite;
}  // namespace network

namespace network {
template<int MASK>
struct CookieBuilder
    : base::RefCounted<CookieBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kName = 1 << 0,
    kValue = 1 << 1,
    kDomain = 1 << 2,
    kPath = 1 << 3,
    kExpires = 1 << 4,
    kSize = 1 << 5,
    kHttpOnly = 1 << 6,
    kSecure = 1 << 7,
    kSession = 1 << 8,
    kNoneSet = kName | kValue | kDomain | kPath | kExpires | kSize | kHttpOnly | kSecure | kSession
  };

  scoped_refptr<CookieBuilder<MASK & ~kName>>
  set_name(const std::string& name) {
    static_assert(MASK & kName, "already set");
    dict_->Set("name", CreateValue(name));
    return ThisAs<CookieBuilder<MASK & ~kName>>();
  }

  scoped_refptr<CookieBuilder<MASK & ~kValue>>
  set_value(const std::string& value) {
    static_assert(MASK & kValue, "already set");
    dict_->Set("value", CreateValue(value));
    return ThisAs<CookieBuilder<MASK & ~kValue>>();
  }

  scoped_refptr<CookieBuilder<MASK & ~kDomain>>
  set_domain(const std::string& domain) {
    static_assert(MASK & kDomain, "already set");
    dict_->Set("domain", CreateValue(domain));
    return ThisAs<CookieBuilder<MASK & ~kDomain>>();
  }

  scoped_refptr<CookieBuilder<MASK & ~kPath>>
  set_path(const std::string& path) {
    static_assert(MASK & kPath, "already set");
    dict_->Set("path", CreateValue(path));
    return ThisAs<CookieBuilder<MASK & ~kPath>>();
  }

  scoped_refptr<CookieBuilder<MASK & ~kExpires>>
  set_expires(double expires) {
    static_assert(MASK & kExpires, "already set");
    dict_->Set("expires", CreateValue(expires));
    return ThisAs<CookieBuilder<MASK & ~kExpires>>();
  }

  scoped_refptr<CookieBuilder<MASK & ~kSize>>
  set_size(int size) {
    static_assert(MASK & kSize, "already set");
    dict_->Set("size", CreateValue(size));
    return ThisAs<CookieBuilder<MASK & ~kSize>>();
  }

  scoped_refptr<CookieBuilder<MASK & ~kHttpOnly>>
  set_http_only(bool http_only) {
    static_assert(MASK & kHttpOnly, "already set");
    dict_->Set("httpOnly", CreateValue(http_only));
    return ThisAs<CookieBuilder<MASK & ~kHttpOnly>>();
  }

  scoped_refptr<CookieBuilder<MASK & ~kSecure>>
  set_secure(bool secure) {
    static_assert(MASK & kSecure, "already set");
    dict_->Set("secure", CreateValue(secure));
    return ThisAs<CookieBuilder<MASK & ~kSecure>>();
  }

  scoped_refptr<CookieBuilder<MASK & ~kSession>>
  set_session(bool session) {
    static_assert(MASK & kSession, "already set");
    dict_->Set("session", CreateValue(session));
    return ThisAs<CookieBuilder<MASK & ~kSession>>();
  }

  scoped_refptr<CookieBuilder<MASK>>
  set_same_site(const std::string& same_site) {
    dict_->Set("sameSite", CreateValue(same_site));
    return this;
  }

  static scoped_refptr<CookieBuilder<kNoneSet>> Create() {
    return new CookieBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct CookieBuilder<0>;
  friend class base::RefCounted<CookieBuilder<MASK>>;
  ~CookieBuilder() {}

  CookieBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef CookieBuilder<0> Cookie;

}  // namespace network

namespace network {
template<int MASK>
struct GetCookiesResponseBuilder
    : base::RefCounted<GetCookiesResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kCookies = 1 << 0,
    kNoneSet = kCookies
  };

  scoped_refptr<GetCookiesResponseBuilder<MASK & ~kCookies>>
  set_cookies(const std::vector<scoped_refptr<devtools::network::Cookie>>& cookies) {
    static_assert(MASK & kCookies, "already set");
    dict_->Set("cookies", CreateValue(cookies));
    return ThisAs<GetCookiesResponseBuilder<MASK & ~kCookies>>();
  }

  static scoped_refptr<GetCookiesResponseBuilder<kNoneSet>> Create() {
    return new GetCookiesResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct GetCookiesResponseBuilder<0>;
  friend class base::RefCounted<GetCookiesResponseBuilder<MASK>>;
  ~GetCookiesResponseBuilder() {}

  GetCookiesResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef GetCookiesResponseBuilder<0> GetCookiesResponse;

}  // namespace network

namespace network {
template<int MASK>
struct DeleteCookieResponseBuilder
    : base::RefCounted<DeleteCookieResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };


  static scoped_refptr<DeleteCookieResponseBuilder<kNoneSet>> Create() {
    return new DeleteCookieResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct DeleteCookieResponseBuilder<0>;
  friend class base::RefCounted<DeleteCookieResponseBuilder<MASK>>;
  ~DeleteCookieResponseBuilder() {}

  DeleteCookieResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef DeleteCookieResponseBuilder<0> DeleteCookieResponse;

}  // namespace network

namespace network {
typedef double Timestamp;
}  // namespace network

namespace network {
template<int MASK>
struct SetCookieResponseBuilder
    : base::RefCounted<SetCookieResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kSuccess = 1 << 0,
    kNoneSet = kSuccess
  };

  scoped_refptr<SetCookieResponseBuilder<MASK & ~kSuccess>>
  set_success(bool success) {
    static_assert(MASK & kSuccess, "already set");
    dict_->Set("success", CreateValue(success));
    return ThisAs<SetCookieResponseBuilder<MASK & ~kSuccess>>();
  }

  static scoped_refptr<SetCookieResponseBuilder<kNoneSet>> Create() {
    return new SetCookieResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct SetCookieResponseBuilder<0>;
  friend class base::RefCounted<SetCookieResponseBuilder<MASK>>;
  ~SetCookieResponseBuilder() {}

  SetCookieResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef SetCookieResponseBuilder<0> SetCookieResponse;

}  // namespace network

namespace network {
extern const char kConnectionTypeNone[];
extern const char kConnectionTypeCellular2g[];
extern const char kConnectionTypeCellular3g[];
extern const char kConnectionTypeCellular4g[];
extern const char kConnectionTypeBluetooth[];
extern const char kConnectionTypeEthernet[];
extern const char kConnectionTypeWifi[];
extern const char kConnectionTypeWimax[];
extern const char kConnectionTypeOther[];
}  // namespace network

namespace network {
typedef std::string ConnectionType;
}  // namespace network

namespace network {
template<int MASK>
struct CertificateSubjectBuilder
    : base::RefCounted<CertificateSubjectBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kName = 1 << 0,
    kSanDnsNames = 1 << 1,
    kSanIpAddresses = 1 << 2,
    kNoneSet = kName | kSanDnsNames | kSanIpAddresses
  };

  scoped_refptr<CertificateSubjectBuilder<MASK & ~kName>>
  set_name(const std::string& name) {
    static_assert(MASK & kName, "already set");
    dict_->Set("name", CreateValue(name));
    return ThisAs<CertificateSubjectBuilder<MASK & ~kName>>();
  }

  scoped_refptr<CertificateSubjectBuilder<MASK & ~kSanDnsNames>>
  set_san_dns_names(const std::vector<std::string>& san_dns_names) {
    static_assert(MASK & kSanDnsNames, "already set");
    dict_->Set("sanDnsNames", CreateValue(san_dns_names));
    return ThisAs<CertificateSubjectBuilder<MASK & ~kSanDnsNames>>();
  }

  scoped_refptr<CertificateSubjectBuilder<MASK & ~kSanIpAddresses>>
  set_san_ip_addresses(const std::vector<std::string>& san_ip_addresses) {
    static_assert(MASK & kSanIpAddresses, "already set");
    dict_->Set("sanIpAddresses", CreateValue(san_ip_addresses));
    return ThisAs<CertificateSubjectBuilder<MASK & ~kSanIpAddresses>>();
  }

  static scoped_refptr<CertificateSubjectBuilder<kNoneSet>> Create() {
    return new CertificateSubjectBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct CertificateSubjectBuilder<0>;
  friend class base::RefCounted<CertificateSubjectBuilder<MASK>>;
  ~CertificateSubjectBuilder() {}

  CertificateSubjectBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef CertificateSubjectBuilder<0> CertificateSubject;

}  // namespace network

namespace network {
template<int MASK>
struct CertificateDetailsBuilder
    : base::RefCounted<CertificateDetailsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kSubject = 1 << 0,
    kIssuer = 1 << 1,
    kValidFrom = 1 << 2,
    kValidTo = 1 << 3,
    kNoneSet = kSubject | kIssuer | kValidFrom | kValidTo
  };

  scoped_refptr<CertificateDetailsBuilder<MASK & ~kSubject>>
  set_subject(scoped_refptr<devtools::network::CertificateSubject> subject) {
    static_assert(MASK & kSubject, "already set");
    dict_->Set("subject", CreateValue(subject));
    return ThisAs<CertificateDetailsBuilder<MASK & ~kSubject>>();
  }

  scoped_refptr<CertificateDetailsBuilder<MASK & ~kIssuer>>
  set_issuer(const std::string& issuer) {
    static_assert(MASK & kIssuer, "already set");
    dict_->Set("issuer", CreateValue(issuer));
    return ThisAs<CertificateDetailsBuilder<MASK & ~kIssuer>>();
  }

  scoped_refptr<CertificateDetailsBuilder<MASK & ~kValidFrom>>
  set_valid_from(double valid_from) {
    static_assert(MASK & kValidFrom, "already set");
    dict_->Set("validFrom", CreateValue(valid_from));
    return ThisAs<CertificateDetailsBuilder<MASK & ~kValidFrom>>();
  }

  scoped_refptr<CertificateDetailsBuilder<MASK & ~kValidTo>>
  set_valid_to(double valid_to) {
    static_assert(MASK & kValidTo, "already set");
    dict_->Set("validTo", CreateValue(valid_to));
    return ThisAs<CertificateDetailsBuilder<MASK & ~kValidTo>>();
  }

  static scoped_refptr<CertificateDetailsBuilder<kNoneSet>> Create() {
    return new CertificateDetailsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct CertificateDetailsBuilder<0>;
  friend class base::RefCounted<CertificateDetailsBuilder<MASK>>;
  ~CertificateDetailsBuilder() {}

  CertificateDetailsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef CertificateDetailsBuilder<0> CertificateDetails;

}  // namespace network

namespace network {
class NetworkHandler;
}  // namespace domain

namespace network {
class Client : public DevToolsProtocolClient {
 public:
  explicit Client(DevToolsProtocolDelegate* notifier);
  ~Client() override;

  void SendGetCookiesResponse(
      DevToolsCommandId command_id,
      scoped_refptr<GetCookiesResponse> params);
  void SendDeleteCookieResponse(
      DevToolsCommandId command_id,
      scoped_refptr<DeleteCookieResponse> params);
  void SendSetCookieResponse(
      DevToolsCommandId command_id,
      scoped_refptr<SetCookieResponse> params);
};
}  // namespace network

namespace dom {
typedef int NodeId;
}  // namespace dom

namespace dom {
class DOMHandler;
}  // namespace domain

namespace io {
typedef std::string StreamHandle;
}  // namespace io

namespace io {
template<int MASK>
struct ReadResponseBuilder
    : base::RefCounted<ReadResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kData = 1 << 0,
    kEof = 1 << 1,
    kNoneSet = kData | kEof
  };

  scoped_refptr<ReadResponseBuilder<MASK & ~kData>>
  set_data(const std::string& data) {
    static_assert(MASK & kData, "already set");
    dict_->Set("data", CreateValue(data));
    return ThisAs<ReadResponseBuilder<MASK & ~kData>>();
  }

  scoped_refptr<ReadResponseBuilder<MASK & ~kEof>>
  set_eof(bool eof) {
    static_assert(MASK & kEof, "already set");
    dict_->Set("eof", CreateValue(eof));
    return ThisAs<ReadResponseBuilder<MASK & ~kEof>>();
  }

  static scoped_refptr<ReadResponseBuilder<kNoneSet>> Create() {
    return new ReadResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct ReadResponseBuilder<0>;
  friend class base::RefCounted<ReadResponseBuilder<MASK>>;
  ~ReadResponseBuilder() {}

  ReadResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef ReadResponseBuilder<0> ReadResponse;

}  // namespace io

namespace io {
class IOHandler;
}  // namespace domain

namespace io {
class Client : public DevToolsProtocolClient {
 public:
  explicit Client(DevToolsProtocolDelegate* notifier);
  ~Client() override;

  void SendReadResponse(
      DevToolsCommandId command_id,
      scoped_refptr<ReadResponse> params);
};
}  // namespace io

namespace service_worker {
typedef std::string TargetID;
}  // namespace service_worker

namespace service_worker {
template<int MASK>
struct TargetInfoBuilder
    : base::RefCounted<TargetInfoBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kId = 1 << 0,
    kType = 1 << 1,
    kTitle = 1 << 2,
    kUrl = 1 << 3,
    kNoneSet = kId | kType | kTitle | kUrl
  };

  scoped_refptr<TargetInfoBuilder<MASK & ~kId>>
  set_id(const std::string& id) {
    static_assert(MASK & kId, "already set");
    dict_->Set("id", CreateValue(id));
    return ThisAs<TargetInfoBuilder<MASK & ~kId>>();
  }

  scoped_refptr<TargetInfoBuilder<MASK & ~kType>>
  set_type(const std::string& type) {
    static_assert(MASK & kType, "already set");
    dict_->Set("type", CreateValue(type));
    return ThisAs<TargetInfoBuilder<MASK & ~kType>>();
  }

  scoped_refptr<TargetInfoBuilder<MASK & ~kTitle>>
  set_title(const std::string& title) {
    static_assert(MASK & kTitle, "already set");
    dict_->Set("title", CreateValue(title));
    return ThisAs<TargetInfoBuilder<MASK & ~kTitle>>();
  }

  scoped_refptr<TargetInfoBuilder<MASK & ~kUrl>>
  set_url(const std::string& url) {
    static_assert(MASK & kUrl, "already set");
    dict_->Set("url", CreateValue(url));
    return ThisAs<TargetInfoBuilder<MASK & ~kUrl>>();
  }

  static scoped_refptr<TargetInfoBuilder<kNoneSet>> Create() {
    return new TargetInfoBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct TargetInfoBuilder<0>;
  friend class base::RefCounted<TargetInfoBuilder<MASK>>;
  ~TargetInfoBuilder() {}

  TargetInfoBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef TargetInfoBuilder<0> TargetInfo;

}  // namespace service_worker

namespace service_worker {
template<int MASK>
struct WorkerCreatedParamsBuilder
    : base::RefCounted<WorkerCreatedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kWorkerId = 1 << 0,
    kUrl = 1 << 1,
    kVersionId = 1 << 2,
    kNoneSet = kWorkerId | kUrl | kVersionId
  };

  scoped_refptr<WorkerCreatedParamsBuilder<MASK & ~kWorkerId>>
  set_worker_id(const std::string& worker_id) {
    static_assert(MASK & kWorkerId, "already set");
    dict_->Set("workerId", CreateValue(worker_id));
    return ThisAs<WorkerCreatedParamsBuilder<MASK & ~kWorkerId>>();
  }

  scoped_refptr<WorkerCreatedParamsBuilder<MASK & ~kUrl>>
  set_url(const std::string& url) {
    static_assert(MASK & kUrl, "already set");
    dict_->Set("url", CreateValue(url));
    return ThisAs<WorkerCreatedParamsBuilder<MASK & ~kUrl>>();
  }

  scoped_refptr<WorkerCreatedParamsBuilder<MASK & ~kVersionId>>
  set_version_id(const std::string& version_id) {
    static_assert(MASK & kVersionId, "already set");
    dict_->Set("versionId", CreateValue(version_id));
    return ThisAs<WorkerCreatedParamsBuilder<MASK & ~kVersionId>>();
  }

  static scoped_refptr<WorkerCreatedParamsBuilder<kNoneSet>> Create() {
    return new WorkerCreatedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct WorkerCreatedParamsBuilder<0>;
  friend class base::RefCounted<WorkerCreatedParamsBuilder<MASK>>;
  ~WorkerCreatedParamsBuilder() {}

  WorkerCreatedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef WorkerCreatedParamsBuilder<0> WorkerCreatedParams;

}  // namespace service_worker

namespace service_worker {
template<int MASK>
struct WorkerTerminatedParamsBuilder
    : base::RefCounted<WorkerTerminatedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kWorkerId = 1 << 0,
    kNoneSet = kWorkerId
  };

  scoped_refptr<WorkerTerminatedParamsBuilder<MASK & ~kWorkerId>>
  set_worker_id(const std::string& worker_id) {
    static_assert(MASK & kWorkerId, "already set");
    dict_->Set("workerId", CreateValue(worker_id));
    return ThisAs<WorkerTerminatedParamsBuilder<MASK & ~kWorkerId>>();
  }

  static scoped_refptr<WorkerTerminatedParamsBuilder<kNoneSet>> Create() {
    return new WorkerTerminatedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct WorkerTerminatedParamsBuilder<0>;
  friend class base::RefCounted<WorkerTerminatedParamsBuilder<MASK>>;
  ~WorkerTerminatedParamsBuilder() {}

  WorkerTerminatedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef WorkerTerminatedParamsBuilder<0> WorkerTerminatedParams;

}  // namespace service_worker

namespace service_worker {
template<int MASK>
struct DispatchMessageParamsBuilder
    : base::RefCounted<DispatchMessageParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kWorkerId = 1 << 0,
    kMessage = 1 << 1,
    kNoneSet = kWorkerId | kMessage
  };

  scoped_refptr<DispatchMessageParamsBuilder<MASK & ~kWorkerId>>
  set_worker_id(const std::string& worker_id) {
    static_assert(MASK & kWorkerId, "already set");
    dict_->Set("workerId", CreateValue(worker_id));
    return ThisAs<DispatchMessageParamsBuilder<MASK & ~kWorkerId>>();
  }

  scoped_refptr<DispatchMessageParamsBuilder<MASK & ~kMessage>>
  set_message(const std::string& message) {
    static_assert(MASK & kMessage, "already set");
    dict_->Set("message", CreateValue(message));
    return ThisAs<DispatchMessageParamsBuilder<MASK & ~kMessage>>();
  }

  static scoped_refptr<DispatchMessageParamsBuilder<kNoneSet>> Create() {
    return new DispatchMessageParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct DispatchMessageParamsBuilder<0>;
  friend class base::RefCounted<DispatchMessageParamsBuilder<MASK>>;
  ~DispatchMessageParamsBuilder() {}

  DispatchMessageParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef DispatchMessageParamsBuilder<0> DispatchMessageParams;

}  // namespace service_worker

namespace service_worker {
template<int MASK>
struct ServiceWorkerRegistrationBuilder
    : base::RefCounted<ServiceWorkerRegistrationBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kRegistrationId = 1 << 0,
    kScopeURL = 1 << 1,
    kIsDeleted = 1 << 2,
    kNoneSet = kRegistrationId | kScopeURL | kIsDeleted
  };

  scoped_refptr<ServiceWorkerRegistrationBuilder<MASK & ~kRegistrationId>>
  set_registration_id(const std::string& registration_id) {
    static_assert(MASK & kRegistrationId, "already set");
    dict_->Set("registrationId", CreateValue(registration_id));
    return ThisAs<ServiceWorkerRegistrationBuilder<MASK & ~kRegistrationId>>();
  }

  scoped_refptr<ServiceWorkerRegistrationBuilder<MASK & ~kScopeURL>>
  set_scope_url(const std::string& scope_url) {
    static_assert(MASK & kScopeURL, "already set");
    dict_->Set("scopeURL", CreateValue(scope_url));
    return ThisAs<ServiceWorkerRegistrationBuilder<MASK & ~kScopeURL>>();
  }

  scoped_refptr<ServiceWorkerRegistrationBuilder<MASK & ~kIsDeleted>>
  set_is_deleted(bool is_deleted) {
    static_assert(MASK & kIsDeleted, "already set");
    dict_->Set("isDeleted", CreateValue(is_deleted));
    return ThisAs<ServiceWorkerRegistrationBuilder<MASK & ~kIsDeleted>>();
  }

  static scoped_refptr<ServiceWorkerRegistrationBuilder<kNoneSet>> Create() {
    return new ServiceWorkerRegistrationBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct ServiceWorkerRegistrationBuilder<0>;
  friend class base::RefCounted<ServiceWorkerRegistrationBuilder<MASK>>;
  ~ServiceWorkerRegistrationBuilder() {}

  ServiceWorkerRegistrationBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef ServiceWorkerRegistrationBuilder<0> ServiceWorkerRegistration;

}  // namespace service_worker

namespace service_worker {
template<int MASK>
struct WorkerRegistrationUpdatedParamsBuilder
    : base::RefCounted<WorkerRegistrationUpdatedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kRegistrations = 1 << 0,
    kNoneSet = kRegistrations
  };

  scoped_refptr<WorkerRegistrationUpdatedParamsBuilder<MASK & ~kRegistrations>>
  set_registrations(const std::vector<scoped_refptr<devtools::service_worker::ServiceWorkerRegistration>>& registrations) {
    static_assert(MASK & kRegistrations, "already set");
    dict_->Set("registrations", CreateValue(registrations));
    return ThisAs<WorkerRegistrationUpdatedParamsBuilder<MASK & ~kRegistrations>>();
  }

  static scoped_refptr<WorkerRegistrationUpdatedParamsBuilder<kNoneSet>> Create() {
    return new WorkerRegistrationUpdatedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct WorkerRegistrationUpdatedParamsBuilder<0>;
  friend class base::RefCounted<WorkerRegistrationUpdatedParamsBuilder<MASK>>;
  ~WorkerRegistrationUpdatedParamsBuilder() {}

  WorkerRegistrationUpdatedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef WorkerRegistrationUpdatedParamsBuilder<0> WorkerRegistrationUpdatedParams;

}  // namespace service_worker

namespace service_worker {
extern const char kServiceWorkerVersionRunningStatusStopped[];
extern const char kServiceWorkerVersionRunningStatusStarting[];
extern const char kServiceWorkerVersionRunningStatusRunning[];
extern const char kServiceWorkerVersionRunningStatusStopping[];
}  // namespace service_worker

namespace service_worker {
typedef std::string ServiceWorkerVersionRunningStatus;
}  // namespace service_worker

namespace service_worker {
extern const char kServiceWorkerVersionStatusNew[];
extern const char kServiceWorkerVersionStatusInstalling[];
extern const char kServiceWorkerVersionStatusInstalled[];
extern const char kServiceWorkerVersionStatusActivating[];
extern const char kServiceWorkerVersionStatusActivated[];
extern const char kServiceWorkerVersionStatusRedundant[];
}  // namespace service_worker

namespace service_worker {
typedef std::string ServiceWorkerVersionStatus;
}  // namespace service_worker

namespace service_worker {
template<int MASK>
struct ServiceWorkerVersionBuilder
    : base::RefCounted<ServiceWorkerVersionBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kVersionId = 1 << 0,
    kRegistrationId = 1 << 1,
    kScriptURL = 1 << 2,
    kRunningStatus = 1 << 3,
    kStatus = 1 << 4,
    kNoneSet = kVersionId | kRegistrationId | kScriptURL | kRunningStatus | kStatus
  };

  scoped_refptr<ServiceWorkerVersionBuilder<MASK & ~kVersionId>>
  set_version_id(const std::string& version_id) {
    static_assert(MASK & kVersionId, "already set");
    dict_->Set("versionId", CreateValue(version_id));
    return ThisAs<ServiceWorkerVersionBuilder<MASK & ~kVersionId>>();
  }

  scoped_refptr<ServiceWorkerVersionBuilder<MASK & ~kRegistrationId>>
  set_registration_id(const std::string& registration_id) {
    static_assert(MASK & kRegistrationId, "already set");
    dict_->Set("registrationId", CreateValue(registration_id));
    return ThisAs<ServiceWorkerVersionBuilder<MASK & ~kRegistrationId>>();
  }

  scoped_refptr<ServiceWorkerVersionBuilder<MASK & ~kScriptURL>>
  set_script_url(const std::string& script_url) {
    static_assert(MASK & kScriptURL, "already set");
    dict_->Set("scriptURL", CreateValue(script_url));
    return ThisAs<ServiceWorkerVersionBuilder<MASK & ~kScriptURL>>();
  }

  scoped_refptr<ServiceWorkerVersionBuilder<MASK & ~kRunningStatus>>
  set_running_status(const std::string& running_status) {
    static_assert(MASK & kRunningStatus, "already set");
    dict_->Set("runningStatus", CreateValue(running_status));
    return ThisAs<ServiceWorkerVersionBuilder<MASK & ~kRunningStatus>>();
  }

  scoped_refptr<ServiceWorkerVersionBuilder<MASK & ~kStatus>>
  set_status(const std::string& status) {
    static_assert(MASK & kStatus, "already set");
    dict_->Set("status", CreateValue(status));
    return ThisAs<ServiceWorkerVersionBuilder<MASK & ~kStatus>>();
  }

  scoped_refptr<ServiceWorkerVersionBuilder<MASK>>
  set_script_last_modified(double script_last_modified) {
    dict_->Set("scriptLastModified", CreateValue(script_last_modified));
    return this;
  }

  scoped_refptr<ServiceWorkerVersionBuilder<MASK>>
  set_script_response_time(double script_response_time) {
    dict_->Set("scriptResponseTime", CreateValue(script_response_time));
    return this;
  }

  scoped_refptr<ServiceWorkerVersionBuilder<MASK>>
  set_controlled_clients(const std::vector<std::string>& controlled_clients) {
    dict_->Set("controlledClients", CreateValue(controlled_clients));
    return this;
  }

  static scoped_refptr<ServiceWorkerVersionBuilder<kNoneSet>> Create() {
    return new ServiceWorkerVersionBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct ServiceWorkerVersionBuilder<0>;
  friend class base::RefCounted<ServiceWorkerVersionBuilder<MASK>>;
  ~ServiceWorkerVersionBuilder() {}

  ServiceWorkerVersionBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef ServiceWorkerVersionBuilder<0> ServiceWorkerVersion;

}  // namespace service_worker

namespace service_worker {
template<int MASK>
struct WorkerVersionUpdatedParamsBuilder
    : base::RefCounted<WorkerVersionUpdatedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kVersions = 1 << 0,
    kNoneSet = kVersions
  };

  scoped_refptr<WorkerVersionUpdatedParamsBuilder<MASK & ~kVersions>>
  set_versions(const std::vector<scoped_refptr<devtools::service_worker::ServiceWorkerVersion>>& versions) {
    static_assert(MASK & kVersions, "already set");
    dict_->Set("versions", CreateValue(versions));
    return ThisAs<WorkerVersionUpdatedParamsBuilder<MASK & ~kVersions>>();
  }

  static scoped_refptr<WorkerVersionUpdatedParamsBuilder<kNoneSet>> Create() {
    return new WorkerVersionUpdatedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct WorkerVersionUpdatedParamsBuilder<0>;
  friend class base::RefCounted<WorkerVersionUpdatedParamsBuilder<MASK>>;
  ~WorkerVersionUpdatedParamsBuilder() {}

  WorkerVersionUpdatedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef WorkerVersionUpdatedParamsBuilder<0> WorkerVersionUpdatedParams;

}  // namespace service_worker

namespace service_worker {
template<int MASK>
struct ServiceWorkerErrorMessageBuilder
    : base::RefCounted<ServiceWorkerErrorMessageBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kErrorMessage = 1 << 0,
    kRegistrationId = 1 << 1,
    kVersionId = 1 << 2,
    kSourceURL = 1 << 3,
    kLineNumber = 1 << 4,
    kColumnNumber = 1 << 5,
    kNoneSet = kErrorMessage | kRegistrationId | kVersionId | kSourceURL | kLineNumber | kColumnNumber
  };

  scoped_refptr<ServiceWorkerErrorMessageBuilder<MASK & ~kErrorMessage>>
  set_error_message(const std::string& error_message) {
    static_assert(MASK & kErrorMessage, "already set");
    dict_->Set("errorMessage", CreateValue(error_message));
    return ThisAs<ServiceWorkerErrorMessageBuilder<MASK & ~kErrorMessage>>();
  }

  scoped_refptr<ServiceWorkerErrorMessageBuilder<MASK & ~kRegistrationId>>
  set_registration_id(const std::string& registration_id) {
    static_assert(MASK & kRegistrationId, "already set");
    dict_->Set("registrationId", CreateValue(registration_id));
    return ThisAs<ServiceWorkerErrorMessageBuilder<MASK & ~kRegistrationId>>();
  }

  scoped_refptr<ServiceWorkerErrorMessageBuilder<MASK & ~kVersionId>>
  set_version_id(const std::string& version_id) {
    static_assert(MASK & kVersionId, "already set");
    dict_->Set("versionId", CreateValue(version_id));
    return ThisAs<ServiceWorkerErrorMessageBuilder<MASK & ~kVersionId>>();
  }

  scoped_refptr<ServiceWorkerErrorMessageBuilder<MASK & ~kSourceURL>>
  set_source_url(const std::string& source_url) {
    static_assert(MASK & kSourceURL, "already set");
    dict_->Set("sourceURL", CreateValue(source_url));
    return ThisAs<ServiceWorkerErrorMessageBuilder<MASK & ~kSourceURL>>();
  }

  scoped_refptr<ServiceWorkerErrorMessageBuilder<MASK & ~kLineNumber>>
  set_line_number(int line_number) {
    static_assert(MASK & kLineNumber, "already set");
    dict_->Set("lineNumber", CreateValue(line_number));
    return ThisAs<ServiceWorkerErrorMessageBuilder<MASK & ~kLineNumber>>();
  }

  scoped_refptr<ServiceWorkerErrorMessageBuilder<MASK & ~kColumnNumber>>
  set_column_number(int column_number) {
    static_assert(MASK & kColumnNumber, "already set");
    dict_->Set("columnNumber", CreateValue(column_number));
    return ThisAs<ServiceWorkerErrorMessageBuilder<MASK & ~kColumnNumber>>();
  }

  static scoped_refptr<ServiceWorkerErrorMessageBuilder<kNoneSet>> Create() {
    return new ServiceWorkerErrorMessageBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct ServiceWorkerErrorMessageBuilder<0>;
  friend class base::RefCounted<ServiceWorkerErrorMessageBuilder<MASK>>;
  ~ServiceWorkerErrorMessageBuilder() {}

  ServiceWorkerErrorMessageBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef ServiceWorkerErrorMessageBuilder<0> ServiceWorkerErrorMessage;

}  // namespace service_worker

namespace service_worker {
template<int MASK>
struct WorkerErrorReportedParamsBuilder
    : base::RefCounted<WorkerErrorReportedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kErrorMessage = 1 << 0,
    kNoneSet = kErrorMessage
  };

  scoped_refptr<WorkerErrorReportedParamsBuilder<MASK & ~kErrorMessage>>
  set_error_message(scoped_refptr<devtools::service_worker::ServiceWorkerErrorMessage> error_message) {
    static_assert(MASK & kErrorMessage, "already set");
    dict_->Set("errorMessage", CreateValue(error_message));
    return ThisAs<WorkerErrorReportedParamsBuilder<MASK & ~kErrorMessage>>();
  }

  static scoped_refptr<WorkerErrorReportedParamsBuilder<kNoneSet>> Create() {
    return new WorkerErrorReportedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct WorkerErrorReportedParamsBuilder<0>;
  friend class base::RefCounted<WorkerErrorReportedParamsBuilder<MASK>>;
  ~WorkerErrorReportedParamsBuilder() {}

  WorkerErrorReportedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef WorkerErrorReportedParamsBuilder<0> WorkerErrorReportedParams;

}  // namespace service_worker

namespace service_worker {
class ServiceWorkerHandler;
}  // namespace domain

namespace service_worker {
class Client : public DevToolsProtocolClient {
 public:
  explicit Client(DevToolsProtocolDelegate* notifier);
  ~Client() override;

  void WorkerCreated(
      scoped_refptr<WorkerCreatedParams> params);
  void WorkerTerminated(
      scoped_refptr<WorkerTerminatedParams> params);
  void DispatchMessage(
      scoped_refptr<DispatchMessageParams> params);
  void WorkerRegistrationUpdated(
      scoped_refptr<WorkerRegistrationUpdatedParams> params);
  void WorkerVersionUpdated(
      scoped_refptr<WorkerVersionUpdatedParams> params);
  void WorkerErrorReported(
      scoped_refptr<WorkerErrorReportedParams> params);
};
}  // namespace service_worker

namespace input {
namespace dispatch_key_event {
extern const char kTypeKeyDown[];
extern const char kTypeKeyUp[];
extern const char kTypeRawKeyDown[];
extern const char kTypeChar[];
}  // namespace dispatch_key_event
}  // namespace input

namespace input {
namespace dispatch_mouse_event {
extern const char kTypeMousePressed[];
extern const char kTypeMouseReleased[];
extern const char kTypeMouseMoved[];
}  // namespace dispatch_mouse_event
}  // namespace input

namespace input {
namespace dispatch_mouse_event {
extern const char kButtonNone[];
extern const char kButtonLeft[];
extern const char kButtonMiddle[];
extern const char kButtonRight[];
}  // namespace dispatch_mouse_event
}  // namespace input

namespace input {
namespace emulate_touch_from_mouse_event {
extern const char kTypeMousePressed[];
extern const char kTypeMouseReleased[];
extern const char kTypeMouseMoved[];
extern const char kTypeMouseWheel[];
}  // namespace emulate_touch_from_mouse_event
}  // namespace input

namespace input {
namespace emulate_touch_from_mouse_event {
extern const char kButtonNone[];
extern const char kButtonLeft[];
extern const char kButtonMiddle[];
extern const char kButtonRight[];
}  // namespace emulate_touch_from_mouse_event
}  // namespace input

namespace input {
extern const char kGestureSourceTypeDefault[];
extern const char kGestureSourceTypeTouch[];
extern const char kGestureSourceTypeMouse[];
}  // namespace input

namespace input {
typedef std::string GestureSourceType;
}  // namespace input

namespace input {
template<int MASK>
struct SynthesizePinchGestureResponseBuilder
    : base::RefCounted<SynthesizePinchGestureResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };


  static scoped_refptr<SynthesizePinchGestureResponseBuilder<kNoneSet>> Create() {
    return new SynthesizePinchGestureResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct SynthesizePinchGestureResponseBuilder<0>;
  friend class base::RefCounted<SynthesizePinchGestureResponseBuilder<MASK>>;
  ~SynthesizePinchGestureResponseBuilder() {}

  SynthesizePinchGestureResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef SynthesizePinchGestureResponseBuilder<0> SynthesizePinchGestureResponse;

}  // namespace input

namespace input {
template<int MASK>
struct SynthesizeScrollGestureResponseBuilder
    : base::RefCounted<SynthesizeScrollGestureResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };


  static scoped_refptr<SynthesizeScrollGestureResponseBuilder<kNoneSet>> Create() {
    return new SynthesizeScrollGestureResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct SynthesizeScrollGestureResponseBuilder<0>;
  friend class base::RefCounted<SynthesizeScrollGestureResponseBuilder<MASK>>;
  ~SynthesizeScrollGestureResponseBuilder() {}

  SynthesizeScrollGestureResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef SynthesizeScrollGestureResponseBuilder<0> SynthesizeScrollGestureResponse;

}  // namespace input

namespace input {
template<int MASK>
struct SynthesizeTapGestureResponseBuilder
    : base::RefCounted<SynthesizeTapGestureResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };


  static scoped_refptr<SynthesizeTapGestureResponseBuilder<kNoneSet>> Create() {
    return new SynthesizeTapGestureResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct SynthesizeTapGestureResponseBuilder<0>;
  friend class base::RefCounted<SynthesizeTapGestureResponseBuilder<MASK>>;
  ~SynthesizeTapGestureResponseBuilder() {}

  SynthesizeTapGestureResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef SynthesizeTapGestureResponseBuilder<0> SynthesizeTapGestureResponse;

}  // namespace input

namespace input {
class InputHandler;
}  // namespace domain

namespace input {
class Client : public DevToolsProtocolClient {
 public:
  explicit Client(DevToolsProtocolDelegate* notifier);
  ~Client() override;

  void SendSynthesizePinchGestureResponse(
      DevToolsCommandId command_id,
      scoped_refptr<SynthesizePinchGestureResponse> params);
  void SendSynthesizeScrollGestureResponse(
      DevToolsCommandId command_id,
      scoped_refptr<SynthesizeScrollGestureResponse> params);
  void SendSynthesizeTapGestureResponse(
      DevToolsCommandId command_id,
      scoped_refptr<SynthesizeTapGestureResponse> params);
};
}  // namespace input

namespace tracing {
namespace start {
extern const char kTransferModeReportEvents[];
extern const char kTransferModeReturnAsStream[];
}  // namespace start
}  // namespace tracing

namespace tracing {
namespace trace_config {
extern const char kRecordModeRecordUntilFull[];
extern const char kRecordModeRecordContinuously[];
extern const char kRecordModeRecordAsMuchAsPossible[];
extern const char kRecordModeEchoToConsole[];
}  // namespace trace_config
}  // namespace tracing

namespace tracing {
typedef base::DictionaryValue MemoryDumpConfig;
}  // namespace tracing

namespace tracing {
template<int MASK>
struct TraceConfigBuilder
    : base::RefCounted<TraceConfigBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };

  scoped_refptr<TraceConfigBuilder<MASK>>
  set_record_mode(const std::string& record_mode) {
    dict_->Set("recordMode", CreateValue(record_mode));
    return this;
  }

  scoped_refptr<TraceConfigBuilder<MASK>>
  set_enable_sampling(bool enable_sampling) {
    dict_->Set("enableSampling", CreateValue(enable_sampling));
    return this;
  }

  scoped_refptr<TraceConfigBuilder<MASK>>
  set_enable_systrace(bool enable_systrace) {
    dict_->Set("enableSystrace", CreateValue(enable_systrace));
    return this;
  }

  scoped_refptr<TraceConfigBuilder<MASK>>
  set_enable_argument_filter(bool enable_argument_filter) {
    dict_->Set("enableArgumentFilter", CreateValue(enable_argument_filter));
    return this;
  }

  scoped_refptr<TraceConfigBuilder<MASK>>
  set_included_categories(const std::vector<std::string>& included_categories) {
    dict_->Set("includedCategories", CreateValue(included_categories));
    return this;
  }

  scoped_refptr<TraceConfigBuilder<MASK>>
  set_excluded_categories(const std::vector<std::string>& excluded_categories) {
    dict_->Set("excludedCategories", CreateValue(excluded_categories));
    return this;
  }

  scoped_refptr<TraceConfigBuilder<MASK>>
  set_synthetic_delays(const std::vector<std::string>& synthetic_delays) {
    dict_->Set("syntheticDelays", CreateValue(synthetic_delays));
    return this;
  }

  scoped_refptr<TraceConfigBuilder<MASK>>
  set_memory_dump_config(std::unique_ptr<base::DictionaryValue> memory_dump_config) {
    dict_->Set("memoryDumpConfig", CreateValue(memory_dump_config));
    return this;
  }

  static scoped_refptr<TraceConfigBuilder<kNoneSet>> Create() {
    return new TraceConfigBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct TraceConfigBuilder<0>;
  friend class base::RefCounted<TraceConfigBuilder<MASK>>;
  ~TraceConfigBuilder() {}

  TraceConfigBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef TraceConfigBuilder<0> TraceConfig;

}  // namespace tracing

namespace tracing {
template<int MASK>
struct StartResponseBuilder
    : base::RefCounted<StartResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };


  static scoped_refptr<StartResponseBuilder<kNoneSet>> Create() {
    return new StartResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct StartResponseBuilder<0>;
  friend class base::RefCounted<StartResponseBuilder<MASK>>;
  ~StartResponseBuilder() {}

  StartResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef StartResponseBuilder<0> StartResponse;

}  // namespace tracing

namespace tracing {
template<int MASK>
struct EndResponseBuilder
    : base::RefCounted<EndResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };


  static scoped_refptr<EndResponseBuilder<kNoneSet>> Create() {
    return new EndResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct EndResponseBuilder<0>;
  friend class base::RefCounted<EndResponseBuilder<MASK>>;
  ~EndResponseBuilder() {}

  EndResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef EndResponseBuilder<0> EndResponse;

}  // namespace tracing

namespace tracing {
template<int MASK>
struct GetCategoriesResponseBuilder
    : base::RefCounted<GetCategoriesResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kCategories = 1 << 0,
    kNoneSet = kCategories
  };

  scoped_refptr<GetCategoriesResponseBuilder<MASK & ~kCategories>>
  set_categories(const std::vector<std::string>& categories) {
    static_assert(MASK & kCategories, "already set");
    dict_->Set("categories", CreateValue(categories));
    return ThisAs<GetCategoriesResponseBuilder<MASK & ~kCategories>>();
  }

  static scoped_refptr<GetCategoriesResponseBuilder<kNoneSet>> Create() {
    return new GetCategoriesResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct GetCategoriesResponseBuilder<0>;
  friend class base::RefCounted<GetCategoriesResponseBuilder<MASK>>;
  ~GetCategoriesResponseBuilder() {}

  GetCategoriesResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef GetCategoriesResponseBuilder<0> GetCategoriesResponse;

}  // namespace tracing

namespace tracing {
template<int MASK>
struct RequestMemoryDumpResponseBuilder
    : base::RefCounted<RequestMemoryDumpResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kDumpGuid = 1 << 0,
    kSuccess = 1 << 1,
    kNoneSet = kDumpGuid | kSuccess
  };

  scoped_refptr<RequestMemoryDumpResponseBuilder<MASK & ~kDumpGuid>>
  set_dump_guid(const std::string& dump_guid) {
    static_assert(MASK & kDumpGuid, "already set");
    dict_->Set("dumpGuid", CreateValue(dump_guid));
    return ThisAs<RequestMemoryDumpResponseBuilder<MASK & ~kDumpGuid>>();
  }

  scoped_refptr<RequestMemoryDumpResponseBuilder<MASK & ~kSuccess>>
  set_success(bool success) {
    static_assert(MASK & kSuccess, "already set");
    dict_->Set("success", CreateValue(success));
    return ThisAs<RequestMemoryDumpResponseBuilder<MASK & ~kSuccess>>();
  }

  static scoped_refptr<RequestMemoryDumpResponseBuilder<kNoneSet>> Create() {
    return new RequestMemoryDumpResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct RequestMemoryDumpResponseBuilder<0>;
  friend class base::RefCounted<RequestMemoryDumpResponseBuilder<MASK>>;
  ~RequestMemoryDumpResponseBuilder() {}

  RequestMemoryDumpResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef RequestMemoryDumpResponseBuilder<0> RequestMemoryDumpResponse;

}  // namespace tracing

namespace tracing {
template<int MASK>
struct DataCollectedParamsBuilder
    : base::RefCounted<DataCollectedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kValue = 1 << 0,
    kNoneSet = kValue
  };

  scoped_refptr<DataCollectedParamsBuilder<MASK & ~kValue>>
  set_value(const std::vector<base::DictionaryValue>& value) {
    static_assert(MASK & kValue, "already set");
    dict_->Set("value", CreateValue(value));
    return ThisAs<DataCollectedParamsBuilder<MASK & ~kValue>>();
  }

  static scoped_refptr<DataCollectedParamsBuilder<kNoneSet>> Create() {
    return new DataCollectedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct DataCollectedParamsBuilder<0>;
  friend class base::RefCounted<DataCollectedParamsBuilder<MASK>>;
  ~DataCollectedParamsBuilder() {}

  DataCollectedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef DataCollectedParamsBuilder<0> DataCollectedParams;

}  // namespace tracing

namespace tracing {
template<int MASK>
struct TracingCompleteParamsBuilder
    : base::RefCounted<TracingCompleteParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };

  scoped_refptr<TracingCompleteParamsBuilder<MASK>>
  set_stream(const std::string& stream) {
    dict_->Set("stream", CreateValue(stream));
    return this;
  }

  static scoped_refptr<TracingCompleteParamsBuilder<kNoneSet>> Create() {
    return new TracingCompleteParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct TracingCompleteParamsBuilder<0>;
  friend class base::RefCounted<TracingCompleteParamsBuilder<MASK>>;
  ~TracingCompleteParamsBuilder() {}

  TracingCompleteParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef TracingCompleteParamsBuilder<0> TracingCompleteParams;

}  // namespace tracing

namespace tracing {
template<int MASK>
struct BufferUsageParamsBuilder
    : base::RefCounted<BufferUsageParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };

  scoped_refptr<BufferUsageParamsBuilder<MASK>>
  set_percent_full(double percent_full) {
    dict_->Set("percentFull", CreateValue(percent_full));
    return this;
  }

  scoped_refptr<BufferUsageParamsBuilder<MASK>>
  set_event_count(double event_count) {
    dict_->Set("eventCount", CreateValue(event_count));
    return this;
  }

  scoped_refptr<BufferUsageParamsBuilder<MASK>>
  set_value(double value) {
    dict_->Set("value", CreateValue(value));
    return this;
  }

  static scoped_refptr<BufferUsageParamsBuilder<kNoneSet>> Create() {
    return new BufferUsageParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct BufferUsageParamsBuilder<0>;
  friend class base::RefCounted<BufferUsageParamsBuilder<MASK>>;
  ~BufferUsageParamsBuilder() {}

  BufferUsageParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef BufferUsageParamsBuilder<0> BufferUsageParams;

}  // namespace tracing

namespace tracing {
class TracingHandler;
}  // namespace domain

namespace tracing {
class Client : public DevToolsProtocolClient {
 public:
  explicit Client(DevToolsProtocolDelegate* notifier);
  ~Client() override;

  void SendStartResponse(
      DevToolsCommandId command_id,
      scoped_refptr<StartResponse> params);
  void SendEndResponse(
      DevToolsCommandId command_id,
      scoped_refptr<EndResponse> params);
  void SendGetCategoriesResponse(
      DevToolsCommandId command_id,
      scoped_refptr<GetCategoriesResponse> params);
  void SendRequestMemoryDumpResponse(
      DevToolsCommandId command_id,
      scoped_refptr<RequestMemoryDumpResponse> params);
  void DataCollected(
      scoped_refptr<DataCollectedParams> params);
  void TracingComplete(
      scoped_refptr<TracingCompleteParams> params);
  void BufferUsage(
      scoped_refptr<BufferUsageParams> params);
};
}  // namespace tracing

namespace storage {
class StorageHandler;
}  // namespace domain

namespace browser {
typedef std::string BrowserContextID;
}  // namespace browser

namespace browser {
typedef std::string TargetID;
}  // namespace browser

namespace browser {
template<int MASK>
struct TargetInfoBuilder
    : base::RefCounted<TargetInfoBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kTargetId = 1 << 0,
    kType = 1 << 1,
    kTitle = 1 << 2,
    kUrl = 1 << 3,
    kNoneSet = kTargetId | kType | kTitle | kUrl
  };

  scoped_refptr<TargetInfoBuilder<MASK & ~kTargetId>>
  set_target_id(const std::string& target_id) {
    static_assert(MASK & kTargetId, "already set");
    dict_->Set("targetId", CreateValue(target_id));
    return ThisAs<TargetInfoBuilder<MASK & ~kTargetId>>();
  }

  scoped_refptr<TargetInfoBuilder<MASK & ~kType>>
  set_type(const std::string& type) {
    static_assert(MASK & kType, "already set");
    dict_->Set("type", CreateValue(type));
    return ThisAs<TargetInfoBuilder<MASK & ~kType>>();
  }

  scoped_refptr<TargetInfoBuilder<MASK & ~kTitle>>
  set_title(const std::string& title) {
    static_assert(MASK & kTitle, "already set");
    dict_->Set("title", CreateValue(title));
    return ThisAs<TargetInfoBuilder<MASK & ~kTitle>>();
  }

  scoped_refptr<TargetInfoBuilder<MASK & ~kUrl>>
  set_url(const std::string& url) {
    static_assert(MASK & kUrl, "already set");
    dict_->Set("url", CreateValue(url));
    return ThisAs<TargetInfoBuilder<MASK & ~kUrl>>();
  }

  static scoped_refptr<TargetInfoBuilder<kNoneSet>> Create() {
    return new TargetInfoBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct TargetInfoBuilder<0>;
  friend class base::RefCounted<TargetInfoBuilder<MASK>>;
  ~TargetInfoBuilder() {}

  TargetInfoBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef TargetInfoBuilder<0> TargetInfo;

}  // namespace browser

namespace browser {
template<int MASK>
struct DispatchMessageParamsBuilder
    : base::RefCounted<DispatchMessageParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kTargetId = 1 << 0,
    kMessage = 1 << 1,
    kNoneSet = kTargetId | kMessage
  };

  scoped_refptr<DispatchMessageParamsBuilder<MASK & ~kTargetId>>
  set_target_id(const std::string& target_id) {
    static_assert(MASK & kTargetId, "already set");
    dict_->Set("targetId", CreateValue(target_id));
    return ThisAs<DispatchMessageParamsBuilder<MASK & ~kTargetId>>();
  }

  scoped_refptr<DispatchMessageParamsBuilder<MASK & ~kMessage>>
  set_message(const std::string& message) {
    static_assert(MASK & kMessage, "already set");
    dict_->Set("message", CreateValue(message));
    return ThisAs<DispatchMessageParamsBuilder<MASK & ~kMessage>>();
  }

  static scoped_refptr<DispatchMessageParamsBuilder<kNoneSet>> Create() {
    return new DispatchMessageParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct DispatchMessageParamsBuilder<0>;
  friend class base::RefCounted<DispatchMessageParamsBuilder<MASK>>;
  ~DispatchMessageParamsBuilder() {}

  DispatchMessageParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef DispatchMessageParamsBuilder<0> DispatchMessageParams;

}  // namespace browser

namespace browser {
class BrowserHandler;
}  // namespace domain

namespace browser {
class Client : public DevToolsProtocolClient {
 public:
  explicit Client(DevToolsProtocolDelegate* notifier);
  ~Client() override;

  void DispatchMessage(
      scoped_refptr<DispatchMessageParams> params);
};
}  // namespace browser

namespace system_info {
template<int MASK>
struct GPUDeviceBuilder
    : base::RefCounted<GPUDeviceBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kVendorId = 1 << 0,
    kDeviceId = 1 << 1,
    kVendorString = 1 << 2,
    kDeviceString = 1 << 3,
    kNoneSet = kVendorId | kDeviceId | kVendorString | kDeviceString
  };

  scoped_refptr<GPUDeviceBuilder<MASK & ~kVendorId>>
  set_vendor_id(double vendor_id) {
    static_assert(MASK & kVendorId, "already set");
    dict_->Set("vendorId", CreateValue(vendor_id));
    return ThisAs<GPUDeviceBuilder<MASK & ~kVendorId>>();
  }

  scoped_refptr<GPUDeviceBuilder<MASK & ~kDeviceId>>
  set_device_id(double device_id) {
    static_assert(MASK & kDeviceId, "already set");
    dict_->Set("deviceId", CreateValue(device_id));
    return ThisAs<GPUDeviceBuilder<MASK & ~kDeviceId>>();
  }

  scoped_refptr<GPUDeviceBuilder<MASK & ~kVendorString>>
  set_vendor_string(const std::string& vendor_string) {
    static_assert(MASK & kVendorString, "already set");
    dict_->Set("vendorString", CreateValue(vendor_string));
    return ThisAs<GPUDeviceBuilder<MASK & ~kVendorString>>();
  }

  scoped_refptr<GPUDeviceBuilder<MASK & ~kDeviceString>>
  set_device_string(const std::string& device_string) {
    static_assert(MASK & kDeviceString, "already set");
    dict_->Set("deviceString", CreateValue(device_string));
    return ThisAs<GPUDeviceBuilder<MASK & ~kDeviceString>>();
  }

  static scoped_refptr<GPUDeviceBuilder<kNoneSet>> Create() {
    return new GPUDeviceBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct GPUDeviceBuilder<0>;
  friend class base::RefCounted<GPUDeviceBuilder<MASK>>;
  ~GPUDeviceBuilder() {}

  GPUDeviceBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef GPUDeviceBuilder<0> GPUDevice;

}  // namespace system_info

namespace system_info {
template<int MASK>
struct GPUInfoBuilder
    : base::RefCounted<GPUInfoBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kDevices = 1 << 0,
    kDriverBugWorkarounds = 1 << 1,
    kNoneSet = kDevices | kDriverBugWorkarounds
  };

  scoped_refptr<GPUInfoBuilder<MASK & ~kDevices>>
  set_devices(const std::vector<scoped_refptr<devtools::system_info::GPUDevice>>& devices) {
    static_assert(MASK & kDevices, "already set");
    dict_->Set("devices", CreateValue(devices));
    return ThisAs<GPUInfoBuilder<MASK & ~kDevices>>();
  }

  scoped_refptr<GPUInfoBuilder<MASK>>
  set_aux_attributes(std::unique_ptr<base::DictionaryValue> aux_attributes) {
    dict_->Set("auxAttributes", CreateValue(aux_attributes));
    return this;
  }

  scoped_refptr<GPUInfoBuilder<MASK>>
  set_feature_status(std::unique_ptr<base::DictionaryValue> feature_status) {
    dict_->Set("featureStatus", CreateValue(feature_status));
    return this;
  }

  scoped_refptr<GPUInfoBuilder<MASK & ~kDriverBugWorkarounds>>
  set_driver_bug_workarounds(const std::vector<std::string>& driver_bug_workarounds) {
    static_assert(MASK & kDriverBugWorkarounds, "already set");
    dict_->Set("driverBugWorkarounds", CreateValue(driver_bug_workarounds));
    return ThisAs<GPUInfoBuilder<MASK & ~kDriverBugWorkarounds>>();
  }

  static scoped_refptr<GPUInfoBuilder<kNoneSet>> Create() {
    return new GPUInfoBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct GPUInfoBuilder<0>;
  friend class base::RefCounted<GPUInfoBuilder<MASK>>;
  ~GPUInfoBuilder() {}

  GPUInfoBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef GPUInfoBuilder<0> GPUInfo;

}  // namespace system_info

namespace system_info {
template<int MASK>
struct GetInfoResponseBuilder
    : base::RefCounted<GetInfoResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kGpu = 1 << 0,
    kModelName = 1 << 1,
    kModelVersion = 1 << 2,
    kNoneSet = kGpu | kModelName | kModelVersion
  };

  scoped_refptr<GetInfoResponseBuilder<MASK & ~kGpu>>
  set_gpu(scoped_refptr<devtools::system_info::GPUInfo> gpu) {
    static_assert(MASK & kGpu, "already set");
    dict_->Set("gpu", CreateValue(gpu));
    return ThisAs<GetInfoResponseBuilder<MASK & ~kGpu>>();
  }

  scoped_refptr<GetInfoResponseBuilder<MASK & ~kModelName>>
  set_model_name(const std::string& model_name) {
    static_assert(MASK & kModelName, "already set");
    dict_->Set("modelName", CreateValue(model_name));
    return ThisAs<GetInfoResponseBuilder<MASK & ~kModelName>>();
  }

  scoped_refptr<GetInfoResponseBuilder<MASK & ~kModelVersion>>
  set_model_version(const std::string& model_version) {
    static_assert(MASK & kModelVersion, "already set");
    dict_->Set("modelVersion", CreateValue(model_version));
    return ThisAs<GetInfoResponseBuilder<MASK & ~kModelVersion>>();
  }

  static scoped_refptr<GetInfoResponseBuilder<kNoneSet>> Create() {
    return new GetInfoResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct GetInfoResponseBuilder<0>;
  friend class base::RefCounted<GetInfoResponseBuilder<MASK>>;
  ~GetInfoResponseBuilder() {}

  GetInfoResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef GetInfoResponseBuilder<0> GetInfoResponse;

}  // namespace system_info

namespace system_info {
class SystemInfoHandler;
}  // namespace domain

namespace system_info {
class Client : public DevToolsProtocolClient {
 public:
  explicit Client(DevToolsProtocolDelegate* notifier);
  ~Client() override;

  void SendGetInfoResponse(
      DevToolsCommandId command_id,
      scoped_refptr<GetInfoResponse> params);
};
}  // namespace system_info

namespace tethering {
template<int MASK>
struct BindResponseBuilder
    : base::RefCounted<BindResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };


  static scoped_refptr<BindResponseBuilder<kNoneSet>> Create() {
    return new BindResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct BindResponseBuilder<0>;
  friend class base::RefCounted<BindResponseBuilder<MASK>>;
  ~BindResponseBuilder() {}

  BindResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef BindResponseBuilder<0> BindResponse;

}  // namespace tethering

namespace tethering {
template<int MASK>
struct UnbindResponseBuilder
    : base::RefCounted<UnbindResponseBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kNoneSet = kAllSet
  };


  static scoped_refptr<UnbindResponseBuilder<kNoneSet>> Create() {
    return new UnbindResponseBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct UnbindResponseBuilder<0>;
  friend class base::RefCounted<UnbindResponseBuilder<MASK>>;
  ~UnbindResponseBuilder() {}

  UnbindResponseBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef UnbindResponseBuilder<0> UnbindResponse;

}  // namespace tethering

namespace tethering {
template<int MASK>
struct AcceptedParamsBuilder
    : base::RefCounted<AcceptedParamsBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kPort = 1 << 0,
    kConnectionId = 1 << 1,
    kNoneSet = kPort | kConnectionId
  };

  scoped_refptr<AcceptedParamsBuilder<MASK & ~kPort>>
  set_port(int port) {
    static_assert(MASK & kPort, "already set");
    dict_->Set("port", CreateValue(port));
    return ThisAs<AcceptedParamsBuilder<MASK & ~kPort>>();
  }

  scoped_refptr<AcceptedParamsBuilder<MASK & ~kConnectionId>>
  set_connection_id(const std::string& connection_id) {
    static_assert(MASK & kConnectionId, "already set");
    dict_->Set("connectionId", CreateValue(connection_id));
    return ThisAs<AcceptedParamsBuilder<MASK & ~kConnectionId>>();
  }

  static scoped_refptr<AcceptedParamsBuilder<kNoneSet>> Create() {
    return new AcceptedParamsBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct AcceptedParamsBuilder<0>;
  friend class base::RefCounted<AcceptedParamsBuilder<MASK>>;
  ~AcceptedParamsBuilder() {}

  AcceptedParamsBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef AcceptedParamsBuilder<0> AcceptedParams;

}  // namespace tethering

namespace tethering {
class TetheringHandler;
}  // namespace domain

namespace tethering {
class Client : public DevToolsProtocolClient {
 public:
  explicit Client(DevToolsProtocolDelegate* notifier);
  ~Client() override;

  void SendBindResponse(
      DevToolsCommandId command_id,
      scoped_refptr<BindResponse> params);
  void SendUnbindResponse(
      DevToolsCommandId command_id,
      scoped_refptr<UnbindResponse> params);
  void Accepted(
      scoped_refptr<AcceptedParams> params);
};
}  // namespace tethering

namespace schema {
template<int MASK>
struct DomainBuilder
    : base::RefCounted<DomainBuilder<MASK>> {
 public:
  enum {
    kAllSet = 0,
    kName = 1 << 0,
    kVersion = 1 << 1,
    kNoneSet = kName | kVersion
  };

  scoped_refptr<DomainBuilder<MASK & ~kName>>
  set_name(const std::string& name) {
    static_assert(MASK & kName, "already set");
    dict_->Set("name", CreateValue(name));
    return ThisAs<DomainBuilder<MASK & ~kName>>();
  }

  scoped_refptr<DomainBuilder<MASK & ~kVersion>>
  set_version(const std::string& version) {
    static_assert(MASK & kVersion, "already set");
    dict_->Set("version", CreateValue(version));
    return ThisAs<DomainBuilder<MASK & ~kVersion>>();
  }

  static scoped_refptr<DomainBuilder<kNoneSet>> Create() {
    return new DomainBuilder<kNoneSet>();
  }

  std::unique_ptr<base::DictionaryValue> ToValue() {
    static_assert(MASK == kAllSet, "required properties missing");
    return base::WrapUnique(dict_->DeepCopy());
  }

 private:
  friend struct DomainBuilder<0>;
  friend class base::RefCounted<DomainBuilder<MASK>>;
  ~DomainBuilder() {}

  DomainBuilder() : dict_(new base::DictionaryValue()) {
  }

  template<class T> T* ThisAs() {
    static_assert(sizeof(*this) == sizeof(T), "cannot cast");
    return reinterpret_cast<T*>(this);
  }

  std::unique_ptr<base::DictionaryValue> dict_;
};

typedef DomainBuilder<0> Domain;

}  // namespace schema

namespace schema {
class SchemaHandler;
}  // namespace domain

}  // namespace devtools

class DevToolsProtocolDispatcher {
 public:
  using CommandHandler =
      base::Callback<bool(DevToolsCommandId,
                          std::unique_ptr<base::DictionaryValue>)>;

  explicit DevToolsProtocolDispatcher(DevToolsProtocolDelegate* notifier);
  ~DevToolsProtocolDispatcher();

  CommandHandler FindCommandHandler(const std::string& method);

  void SetInspectorHandler(
      devtools::inspector::InspectorHandler* inspector_handler);
  void SetMemoryHandler(
      devtools::memory::MemoryHandler* memory_handler);
  void SetPageHandler(
      devtools::page::PageHandler* page_handler);
  void SetEmulationHandler(
      devtools::emulation::EmulationHandler* emulation_handler);
  void SetSecurityHandler(
      devtools::security::SecurityHandler* security_handler);
  void SetNetworkHandler(
      devtools::network::NetworkHandler* network_handler);
  void SetDOMHandler(
      devtools::dom::DOMHandler* dom_handler);
  void SetIOHandler(
      devtools::io::IOHandler* io_handler);
  void SetServiceWorkerHandler(
      devtools::service_worker::ServiceWorkerHandler* service_worker_handler);
  void SetInputHandler(
      devtools::input::InputHandler* input_handler);
  void SetTracingHandler(
      devtools::tracing::TracingHandler* tracing_handler);
  void SetStorageHandler(
      devtools::storage::StorageHandler* storage_handler);
  void SetBrowserHandler(
      devtools::browser::BrowserHandler* browser_handler);
  void SetSystemInfoHandler(
      devtools::system_info::SystemInfoHandler* system_info_handler);
  void SetTetheringHandler(
      devtools::tethering::TetheringHandler* tethering_handler);
  void SetSchemaHandler(
      devtools::schema::SchemaHandler* schema_handler);

 private:
  using Response = DevToolsProtocolClient::Response;
  using CommandHandlers = std::map<std::string, CommandHandler>;

  bool OnInspectorEnable(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnInspectorDisable(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnMemorySetPressureNotificationsSuppressed(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnMemorySimulatePressureNotification(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageEnable(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageDisable(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageReload(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageNavigate(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageGetNavigationHistory(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageNavigateToHistoryEntry(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageCaptureScreenshot(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageStartScreencast(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageStopScreencast(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageScreencastFrameAck(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageHandleJavaScriptDialog(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageSetColorPickerEnabled(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageRequestAppBanner(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageSetControlNavigations(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnPageProcessNavigation(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnEmulationSetDeviceMetricsOverride(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnEmulationClearDeviceMetricsOverride(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnEmulationSetVisibleSize(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnEmulationSetGeolocationOverride(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnEmulationClearGeolocationOverride(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnEmulationSetTouchEmulationEnabled(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnEmulationCanEmulate(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnSecurityEnable(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnSecurityDisable(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnNetworkClearBrowserCache(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnNetworkClearBrowserCookies(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnNetworkGetCookies(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnNetworkDeleteCookie(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnNetworkSetCookie(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnNetworkCanEmulateNetworkConditions(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnNetworkEmulateNetworkConditions(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnNetworkGetCertificateDetails(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnNetworkShowCertificateViewer(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnDOMSetFileInputFiles(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnIORead(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnIOClose(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerEnable(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerDisable(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerSendMessage(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerStop(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerUnregister(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerUpdateRegistration(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerStartWorker(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerSkipWaiting(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerStopWorker(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerInspectWorker(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerSetForceUpdateOnPageLoad(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerDeliverPushMessage(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerDispatchSyncEvent(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerGetTargetInfo(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnServiceWorkerActivateTarget(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnInputDispatchKeyEvent(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnInputDispatchMouseEvent(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnInputEmulateTouchFromMouseEvent(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnInputSynthesizePinchGesture(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnInputSynthesizeScrollGesture(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnInputSynthesizeTapGesture(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnTracingStart(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnTracingEnd(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnTracingGetCategories(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnTracingRequestMemoryDump(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnTracingRecordClockSyncMarker(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnStorageClearDataForOrigin(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnBrowserCreateBrowserContext(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnBrowserDisposeBrowserContext(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnBrowserCreateTarget(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnBrowserCloseTarget(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnBrowserGetTargets(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnBrowserAttach(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnBrowserDetach(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnBrowserSendMessage(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnSystemInfoGetInfo(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnTetheringBind(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnTetheringUnbind(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);
  bool OnSchemaGetDomains(
      DevToolsCommandId command_id,
      std::unique_ptr<base::DictionaryValue> params);

  DevToolsProtocolDelegate* notifier_;
  DevToolsProtocolClient client_;
  CommandHandlers command_handlers_;
  devtools::inspector::InspectorHandler* inspector_handler_;
  devtools::memory::MemoryHandler* memory_handler_;
  devtools::page::PageHandler* page_handler_;
  devtools::emulation::EmulationHandler* emulation_handler_;
  devtools::security::SecurityHandler* security_handler_;
  devtools::network::NetworkHandler* network_handler_;
  devtools::dom::DOMHandler* dom_handler_;
  devtools::io::IOHandler* io_handler_;
  devtools::service_worker::ServiceWorkerHandler* service_worker_handler_;
  devtools::input::InputHandler* input_handler_;
  devtools::tracing::TracingHandler* tracing_handler_;
  devtools::storage::StorageHandler* storage_handler_;
  devtools::browser::BrowserHandler* browser_handler_;
  devtools::system_info::SystemInfoHandler* system_info_handler_;
  devtools::tethering::TetheringHandler* tethering_handler_;
  devtools::schema::SchemaHandler* schema_handler_;
};

}  // namespace content

#endif  // CONTENT_BROWSER_DEVTOOLS_PROTOCOL_DEVTOOLS_PROTOCOL_DISPATCHER_H_
